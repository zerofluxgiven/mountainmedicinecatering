=== .devcontainer/devcontainer.json ===
{
  "name": "Python 3",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/python:1-3.11-bullseye",
  "customizations": {
    "codespaces": {
      "openFiles": [
        "README.md",
        "app.py"
      ]
    },
    "vscode": {
      "settings": {},
      "extensions": [
        "ms-python.python",
        "ms-python.vscode-pylance"
      ]
    }
  },
  "updateContentCommand": "[ -f packages.txt ] && sudo apt update && sudo apt upgrade -y && sudo xargs apt install -y <packages.txt; [ -f requirements.txt ] && pip3 install --user -r requirements.txt; pip3 install --user streamlit; echo '‚úÖ Packages installed and Requirements met'",
  "postAttachCommand": {
    "server": "streamlit run app.py --server.enableCORS false --server.enableXsrfProtection false"
  },
  "portsAttributes": {
    "8501": {
      "label": "Application",
      "onAutoForward": "openPreview"
    }
  },
  "forwardPorts": [
    8501
  ]
}

=== .firebaserc ===
{
  "projects": {
    "default": "mountainmedicine-6e572"
  }
}


=== .github/workflows/firebase-hosting-merge.yml ===
name: Deploy to Firebase Hosting on merge

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Skip build step (static site)
        run: echo "Skipping npm build step"

      - name: Deploy to Firebase Hosting
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: "${{ secrets.GITHUB_TOKEN }}"
          firebaseServiceAccount: "${{ secrets.FIREBASE_SERVICE_ACCOUNT }}"
          channelId: live


=== .github/workflows/firebase-hosting-pull-request.yml ===
# This file was auto-generated by the Firebase CLI
# https://github.com/firebase/firebase-tools
#
name: Deploy to Firebase Hosting on PR
on: pull_request
permissions:
  checks: write
  contents: read
  pull-requests: write
jobs:
  build_and_preview:
    if: ${{ github.event.pull_request.head.repo.full_name == github.repository }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm ci && npm run build
      - uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: ${{ secrets.GITHUB_TOKEN }}
          firebaseServiceAccount: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_MOUNTAINMEDICINE_6E572 }}
          projectId: mountainmedicine-6e572


=== .gitignore ===
# Python
__pycache__/
*.pyc
*.pyo
*.pyd
env/
.venv/
venv/

# Streamlit
.streamlit/secrets.toml
.streamlit/config.toml

# OS-specific
.DS_Store
Thumbs.db

# Byte-compiled and logs
*.log

# VS Code
.vscode/

# Other
*.bak
# Temporary pip logs
=*


=== .streamlit/config.toml ===
[theme]
base = "light"
primaryColor = "#6C4AB6"
backgroundColor = "#ffffff"
secondaryBackgroundColor = "#f2f2f2"
textColor = "#000000"
font = "sans serif"

[server]
headless = true
enableCORS = false
port = 8501

=== .streamlit/secrets.toml ===
[firebase]
apiKey = "AIzaSyBSpwzSf8hXxb4rBk-u8JPyX7Ha4kGoS8o"
authDomain = "mountainmedicine-6e572.firebaseapp.com"
projectId = "mountainmedicine-6e572"
storageBucket = "mountainmedicine-6e572.firebasestorage.app"
messagingSenderId = "1081705872512"
appId = "1:1081705872512:web:0ddf126c4737e47fd9ba65"

[openai]
api_key = "ZjNsOZvSPvP8SkHypqwuWXrXJnpZxDTEF56eodm7krLoptgw4bKt7T3rvymyJndF94gddNAepjT3BlbkFJh47G-G7paJCWf7nqdvyrXm4tegSM35Cq-u45FlqTN8wT8slsdqUAVY2qKgk38VpvZ0SXzcBp0A"

[firebase_admin]
type = "service_account"
project_id = "mountainmedicine-6e572"
private_key_id = "7945b853735ae7418e220f38888be120233240b3"
private_key = """-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCStyBh6DJQGZQ1
kFzgUSnNBr1dK0sdQdX8CyqTJo+6UyH0QirSFQPqNLYfpdq8GuGYTdLBFUJgXe4a
q7wTgDfGUgUlfnqw5HBIvoL1s6YTqU1uofAPRYvjO2xTfG2kpqcFGLi/vT1yRWNZ
9AB9L8otxyBQ2BwTnaLRMniOoUSVIalDfCflYrBtFEHTyi8qSifakoNk7Ir7MiGf
WLnk04zM2Qp+At7+z/uSsLUpgxiB9rmi3LlptilvxuUsMj6IkhQ7Yj8ux8tSzFKl
A0usDDksEAYJSiMCKlrHlqNOXkI/0zedsXbYhqcAnoLOQmtWQmRdw4scDISJg1ow
ZkTH5iG1AgMBAAECggEACPuaiWFoBTSlDlODWuj1QXxGZ1gxfj4r7cWO6tlgpu8/
RAncvntIFP9QYFHYDuN+yQOzd0bH3IfGaTkhvThA500EdiYkjm8/ewtjustFTEJg
fzkog32GAgNpz5cYd802qtlM5HvKcZQ92pcrLtRYfA2LVQ/U8OmE+2ssQPVZnN94
kvy1JPtdhZYszlZ+O1eQH40yn3l7UG9DKc4NXO2XQnvc2o8zWVy+bqhDj1o+sdNx
IVV0xJI79xg8rwHzTAVvr8KZKQWlTPlg251Kjuzb4WTQHy9oiMX1kMo1lkRodEGD
LXYAl426GjfIixrZthlMZsMkHWks1hkCejxr6V4XoQKBgQDIzt4Gn0wHYVO976T9
SCTzhBxXl1ABfGy8nAE45mLPpBPnO1/kT139R2vnLdMY4cjG0fF7Yg2yp/d3hLHL
PwD/CXcFaZ6TxivfC0gz2o2v8HMTKPp+FGkOCNX9tGlBBpj4e0VWmzKpNAb/Op3W
AI+SXrCLilgZNvlZF8PRb36HlQKBgQC7Cjg+puMrMxUVLAiIrUjlpQaiK/l+2fOK
tBmXhuY+x1nzBxZQHSh/v8UMciSx8LI1Ddd8D/ZkeyR7TAwsMgwQXvV8igE9+YrB
K5fVOYIkekc6YnyAnuOQogkzKbPXR+92Tn2q2GSo3rEJzTfJDXoidZmXPPCEsndA
zNOAuCwpoQKBgQCcfvPzz0POYKCF3vUDW61IhwYbkVYNwm1v1FjzgkExt5q3U8OY
x+3lDTtfsIva0WPK5yU+Vh18xYCMCcMSNejN2g+DDVxDqGbabg14M/TGUCsunHoT
tk5lXKeBEJAS2FRxGojgRRWHXn+xe3o0pL0/gkIujcO46uoK8AVw/GZsvQKBgQCh
C8qj/3RIZQJ5KWHrtTC4MuDEUBLSK33sZuhGNSwYz/NeMzL+Ji0R2iAjeECqSfJX
hiSNOP1RRUqDM1aj0y/aBLlg0z8AitXzP8LLIGozWGnuFpDW+ng8t5guSnEEI3dH
KYxAx3Pch2puYxnubkFEXHez5g++YiAWVoaiJXI5IQKBgGA0qVjQanXEqUPm9jtD
ADl6IuKhvSMcsbAEUFwZ9ecmE8W5Im+Se5ZTnQ9GQ7vV60k5BXCvaWGhPgIT8ldt
VStuLTu9DFDqIGpHjYgEAHBjakoLBY7EORJh12F9fMAQBS4hcJJ0R5LtN2oPhQ2L
489IK/d6KwnCG1oqVXeKTIRp
-----END PRIVATE KEY-----"""

client_email = "firebase-adminsdk-fbsvc@mountainmedicine-6e572.iam.gserviceaccount.com"
client_id = "104184079301366010340"
auth_uri = "https://accounts.google.com/o/oauth2/auth"
token_uri = "https://oauth2.googleapis.com/token"
auth_provider_x509_cert_url = "https://www.googleapis.com/oauth2/v1/certs"
client_x509_cert_url = "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40mountainmedicine-6e572.iam.gserviceaccount.com"
universe_domain = "googleapis.com"

=== README.md ===
# Catering Management App
<!-- Trigger Firebase deploy -->



Instructions and structure overview.

## Parsing Engine
The app uses OpenAI to extract recipes, menus and other structured data.
Responses are requested in JSON format using the API's `response_format` option
to ensure valid output.


=== admin_panel.py ===
# roles.py - Updated for Firebase Authentication

import streamlit as st
from auth import require_role, get_current_user, get_user_role as auth_get_user_role
from firebase_init import db
from utils import delete_button

COLLECTION = "users"

# ----------------------------
# üîç Fetch Roles (Updated for Firebase)
# ----------------------------

def get_all_users() -> list[dict]:
    """Returns all user documents from Firestore."""
    try:
        # Sync Firebase users first
        from auth import sync_firebase_users
        sync_firebase_users()
        
        docs = db.collection(COLLECTION).stream()
        return [doc.to_dict() | {"id": doc.id} for doc in docs]
    except Exception as e:
        st.error(f"Failed to get users: {e}")
        return []

def get_user_role(user_id: str) -> str:
    """Returns a user's role by ID, defaulting to 'viewer'."""
    doc = db.collection(COLLECTION).document(user_id).get()
    if doc.exists:
        return doc.to_dict().get("role", "viewer")
    
    # Try to get from Firebase if not in Firestore
    try:
        from firebase_admin import auth as firebase_auth
        firebase_user = firebase_auth.get_user(user_id)
        # Create user record in Firestore
        role = "admin" if firebase_user.email in ["mistermcfarland@gmail.com"] else "viewer"
        user_data = {
            "id": user_id,
            "email": firebase_user.email, 
            "name": firebase_user.display_name or firebase_user.email.split('@')[0],
            "role": role,
            "created_at": datetime.utcnow(),
            "active": True,
            "email_verified": firebase_user.email_verified
        }
        db.collection(COLLECTION).document(user_id).set(user_data)
        return role
    except:
        return "viewer"

# ----------------------------
# üîÑ Update Role (Firebase Enhanced)
# ----------------------------

def update_user_role(user_id: str, role: str) -> None:
    """Updates a user's role in Firestore and logs the change."""
    try:
        # Update role in Firestore
        db.collection(COLLECTION).document(user_id).update({
            "role": role,
            "role_updated_at": datetime.utcnow()
        })
        
        # Log the role change
        current_user = get_current_user()
        db.collection("logs").add({
            "action": "role_update",
            "target_user_id": user_id,
            "new_role": role,
            "updated_by": current_user.get("id") if current_user else "system",
            "timestamp": datetime.utcnow()
        })
        
        st.success(f"‚úÖ Role updated to **{role}**")
        
        # Send notification
        from notifications import send_notification
        user_doc = db.collection(COLLECTION).document(user_id).get()
        if user_doc.exists:
            user_name = user_doc.to_dict().get("name", "Unknown")
            send_notification(
                f"Role updated for {user_name}: {role}",
                role="admin"
            )
            
    except Exception as e:
        st.error(f"Failed to update role: {e}")

# ----------------------------
# ‚öôÔ∏è Admin UI (Firebase Enhanced)
# ----------------------------

def role_admin_ui() -> None:
    """Displays the role management panel (admin-only) with Firebase integration."""
    st.subheader("üë• User Role Management")

    current_user = get_current_user()
    if not current_user or auth_get_user_role(current_user) != "admin":
        st.warning("Only admins can view or change user roles.")
        return

    # Get all users
    users = get_all_users()
    
    if not users:
        st.info("No users found. Users will appear here after they register.")
        return
    
    # Statistics
    role_stats = {}
    for user in users:
        role = user.get("role", "viewer")
        role_stats[role] = role_stats.get(role, 0) + 1
    
    st.markdown("### üìä Role Statistics")
    cols = st.columns(len(role_stats))
    for i, (role, count) in enumerate(role_stats.items()):
        with cols[i]:
            st.metric(role.title(), count)
    
    st.markdown("---")
    st.markdown(f"### üë• Manage User Roles ({len(users)} users)")
    
    # Current admin ID to prevent self-demotion
    current_admin_id = current_user.get("id")
    
    for user in users:
        with st.expander(f"{user.get('name', 'Unnamed')} ({user.get('email', 'No email')})"):
            col1, col2 = st.columns([2, 1])
            
            with col1:
                # User info
                st.markdown(f"**Email:** {user.get('email', 'Unknown')}")
                st.markdown(f"**User ID:** `{user.get('id', 'Unknown')}`")
                
                # Firebase-specific info
                if user.get('email_verified'):
                    st.markdown("**Email Status:** ‚úÖ Verified")
                else:
                    st.markdown("**Email Status:** ‚ö†Ô∏è Unverified")
                
                if user.get('created_at'):
                    from utils import format_date
                    st.markdown(f"**Joined:** {format_date(user.get('created_at'))}")
            
            with col2:
                current_role = user.get("role", "viewer")
                st.markdown(f"**Current Role:** `{current_role}`")
                
                # Role selection
                can_change_role = True
                warning_msg = None
                
                # Prevent admin from changing own role
                if user.get('id') == current_admin_id:
                    can_change_role = False
                    warning_msg = "Cannot change your own role"
                
                # Prevent demoting last admin
                elif current_role == "admin":
                    other_admins = [u for u in users if u.get("role") == "admin" and u.get("id") != user.get("id")]
                    if not other_admins:
                        can_change_role = False
                        warning_msg = "Cannot demote the last admin"
                
                if warning_msg:
                    st.warning(warning_msg)
                
                if can_change_role:
                    new_role = st.selectbox(
                        "Assign Role",
                        ["viewer", "user", "manager", "admin"],
                        index=["viewer", "user", "manager", "admin"].index(current_role),
                        key=f"role_{user['id']}"
                    )
                    
                    if new_role != current_role:
                        if st.button("üíæ Save Role", key=f"save_{user['id']}", type="primary"):
                            update_user_role(user["id"], new_role)
                            st.rerun()
                else:
                    st.info(f"Role: **{current_role}** (protected)")
            
            # Additional actions
            st.markdown("---")
            col1, col2, col3 = st.columns(3)
            
            with col1:
                # Email verification action
                if not user.get('email_verified', False):
                    if st.button("üìß Send Verification", key=f"verify_{user['id']}"):
                        try:
                            from firebase_admin import auth as firebase_auth
                            verification_link = firebase_auth.generate_email_verification_link(
                                user.get('email')
                            )
                            st.success("‚úÖ Verification email queued!")
                            st.info("Email verification system integration needed")
                        except Exception as e:
                            st.error(f"Failed to send verification: {e}")
            
            with col2:
                # View activity
                if st.button("üìä View Activity", key=f"activity_{user['id']}"):
                    show_user_activity_summary(user)
            
            with col3:
                # Delete user (if not admin or current user)
                if (current_role != "admin" and 
                    user.get('id') != current_admin_id):
                    
                    if delete_button("üóëÔ∏è Delete User", key=f"delete_{user['id']}", type="secondary"):
                        try:
                            from auth import delete_firebase_user
                            if delete_firebase_user(user['id']):
                                st.success("‚úÖ User deleted successfully")
                                st.rerun()
                        except Exception as e:
                            st.error(f"Failed to delete user: {e}")

def show_user_activity_summary(user: dict):
    """Show a brief activity summary for a user"""
    user_id = user.get("id")
    
    with st.container():
        st.markdown(f"#### üìä Activity Summary for {user.get('name', 'Unknown')}")
        
        try:
            # Get user's events
            events_created = list(
                db.collection("events").where("created_by", "==", user_id).stream()
            )
            
            # Get user's files
            files_uploaded = list(
                db.collection("files").where("uploaded_by", "==", user_id).stream()
            )
            
            # Get user's active sessions
            active_sessions = list(
                db.collection("active_sessions")
                .where("user_id", "==", user_id)
                .where("active", "==", True)
                .stream()
            )
            
            # Display metrics
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("Events Created", len(events_created))
            with col2:
                st.metric("Files Uploaded", len(files_uploaded))
            with col3:
                st.metric("Active Sessions", len(active_sessions))
            
            # Show recent events
            if events_created:
                st.markdown("**Recent Events:**")
                for event_doc in events_created[-3:]:  # Show last 3
                    event_data = event_doc.to_dict()
                    st.write(f"‚Ä¢ {event_data.get('name', 'Unnamed')} ({event_data.get('status', 'unknown')})")
            
            # Show last login from Firebase
            try:
                from firebase_admin import auth as firebase_auth
                firebase_user = firebase_auth.get_user(user_id)
                if firebase_user.user_metadata.last_sign_in_timestamp:
                    from datetime import datetime
                    from utils import format_date
                    last_signin = datetime.fromtimestamp(firebase_user.user_metadata.last_sign_in_timestamp / 1000)
                    st.write(f"**Last Sign In:** {format_date(last_signin)}")
            except:
                pass
            
        except Exception as e:
            st.error(f"Could not load activity summary: {e}")

# ----------------------------
# üöÄ Initialization (Firebase Enhanced)
# ----------------------------

def initialize_role_system():
    """Initialize the role management system with Firebase"""
    try:
        # Ensure admin user exists
        from firebase_admin import auth as firebase_auth
        from datetime import datetime
        
        admin_email = "mistermcfarland@gmail.com"
        
        try:
            # Check if admin exists in Firebase
            admin_user = firebase_auth.get_user_by_email(admin_email)
            
            # Ensure admin has correct role in Firestore
            admin_doc = db.collection(COLLECTION).document(admin_user.uid).get()
            if not admin_doc.exists or admin_doc.to_dict().get("role") != "admin":
                admin_data = {
                    "id": admin_user.uid,
                    "email": admin_email,
                    "name": admin_user.display_name or "Admin",
                    "role": "admin",
                    "created_at": datetime.utcnow(),
                    "active": True,
                    "email_verified": admin_user.email_verified
                }
                db.collection(COLLECTION).document(admin_user.uid).set(admin_data, merge=True)
                
        except firebase_auth.UserNotFoundError:
            st.warning(f"Admin user {admin_email} not found in Firebase. Please register this email.")
        
        return True
        
    except Exception as e:
        st.error(f"Failed to initialize role system: {e}")
        return False

# ----------------------------
# üîÑ Legacy Compatibility
# ----------------------------

def role_admin_ui_legacy():
    """Legacy function name - use role_admin_ui instead"""
    return role_admin_ui()


=== admin_utilities.py ===
import streamlit as st
from datetime import datetime, timedelta
from utils import format_timestamp, delete_button
from auth import require_role
from notifications import send_notification
from firebase_init import db, firestore
from google.cloud.firestore_v1.base_query import FieldFilter

# ----------------------------
# üõ†Ô∏è Admin Tools
# ----------------------------
@require_role("admin")
def admin_utilities_ui():
    """Main admin utilities interface"""
    st.title("üõ†Ô∏è Admin Utilities")

    tab1, tab2, tab3, tab4 = st.tabs(["üìä Dashboard", "üìú Audit Logs", "üßπ Cleanup", "üì¶ Archive Events"])

    with tab1:
        _admin_dashboard()
    with tab2:
        _audit_log_viewer()
    with tab3:
        _cleanup_tools()
    with tab4:
        _archive_event_tool()

# ----------------------------
# üìä Dashboard Snapshot
# ----------------------------
def _admin_dashboard():
    """Display admin dashboard with system statistics"""
    st.subheader("üìà App Snapshot")
    
    try:
        col1, col2, col3 = st.columns(3)

        with col1:
            events = list(db.collection("events").stream())
            active_events = len([e for e in events if e.to_dict().get("status") == "active"])
            st.metric("Total Events", len(events))
            st.metric("Active Events", active_events)

        with col2:
            suggestions = list(db.collection("suggestions").where("status", "==", "pending").stream())
            st.metric("Pending Suggestions", len(suggestions))
            
            users = list(db.collection("users").stream())
            st.metric("Total Users", len(users))

        with col3:
            recipes = list(db.collection("recipes").stream())
            st.metric("Total Recipes", len(recipes))
            
            deleted_files = list(db.collection("files").where(filter=FieldFilter("deleted", "==", True)).stream())
            st.metric("Active Files", len(files))

        st.divider()

        # Additional metrics
        col4, col5, col6 = st.columns(3)
        with col4:
            tags = list(db.collection("tags").stream())
            st.metric("Tag Variants", len(tags))
        
        with col5:
            deleted_files = list(db.collection("files").where(filter=FieldFilter("deleted", "==", True)).stream())
            st.metric("Soft-Deleted Files", len(deleted_files))
        
        with col6:
            now = datetime.utcnow()
            month_ago = now - timedelta(days=30)
            recent_logs = list(db.collection("logs").where(filter=FieldFilter("timestamp", ">=", month_ago)).stream())
            unique_users = set(log.to_dict().get("user_id") for log in recent_logs if log.to_dict().get("user_id"))
            st.metric("Active Users (30d)", len(unique_users))

        # System health indicators
        st.markdown("### üîç System Health")
        
        # Check for common issues
        warnings = []
        
        if len(suggestions) > 10:
            warnings.append(f"‚ö†Ô∏è {len(suggestions)} pending suggestions need review")
        
        if len(deleted_files) > 50:
            warnings.append(f"‚ö†Ô∏è {len(deleted_files)} deleted files could be cleaned up")
        
        orphaned_files = 0
        for file_doc in files:
            file_data = file_doc.to_dict()
            if file_data.get("event_id"):
                event_exists = db.collection("events").document(file_data["event_id"]).get().exists
                if not event_exists:
                    orphaned_files += 1
        
        if orphaned_files > 0:
            warnings.append(f"‚ö†Ô∏è {orphaned_files} files linked to non-existent events")
        
        if warnings:
            for warning in warnings:
                st.warning(warning)
        else:
            st.success("‚úÖ System health looks good!")

    except Exception as e:
        st.error(f"‚ö†Ô∏è Could not load dashboard data: {e}")

# ----------------------------
# üìú Audit Log Viewer
# ----------------------------
def _audit_log_viewer():
    """Display recent audit logs"""
    st.subheader("üìú Audit Logs")
    
    try:
        # Get filter options
        col1, col2 = st.columns(2)
        with col1:
            days_back = st.selectbox("Show logs from:", [1, 7, 30, 90], index=1)
        with col2:
            limit = st.selectbox("Max entries:", [50, 100, 200], index=0)
        
        # Calculate date filter
        cutoff_date = datetime.utcnow() - timedelta(days=days_back)
        
        # Query logs
        logs_query = (db.collection("logs")
                     .where("timestamp", ">=", cutoff_date)
                      .order_by("timestamp", direction=firestore.Query.DESCENDING)
                     .limit(limit))
        
        logs = list(logs_query.stream())
        
        if not logs:
            st.info("No logs found for the selected time period.")
            return
        
        st.info(f"Showing {len(logs)} log entries from the last {days_back} days")
        
        for log_doc in logs:
            log_data = log_doc.to_dict()
            
            timestamp = format_timestamp(log_data.get('timestamp'))
            action = log_data.get('action', 'Unknown')
            user_id = log_data.get('user_id', 'System')
            details = log_data.get('details', {})
            
            with st.expander(f"üïí {timestamp} - {action} by {user_id}"):
                st.markdown(f"**Action:** {action}")
                st.markdown(f"**User:** {user_id}")
                st.markdown(f"**Timestamp:** {timestamp}")
                
                if details:
                    st.markdown("**Details:**")
                    st.json(details)
                
                # Additional fields
                for key, value in log_data.items():
                    if key not in ['timestamp', 'action', 'user_id', 'details']:
                        st.markdown(f"**{key.title()}:** {value}")

    except Exception as e:
        st.error(f"‚ö†Ô∏è Could not load audit logs: {e}")

# ----------------------------
# üßπ Cleanup Tools
# ----------------------------
def _cleanup_tools():
    """System cleanup utilities"""
    st.subheader("üßπ System Cleanup")
    
    # Stale suggestions cleanup
    st.markdown("### üìù Stale Suggestions")
    
    col1, col2 = st.columns(2)
    with col1:
        days_old = st.number_input("Mark suggestions as stale after (days):", min_value=1, value=14)
    with col2:
        if st.button("üßπ Clean Stale Suggestions"):
            try:
                cutoff = datetime.utcnow() - timedelta(days=days_old)
                stale_query = (db.collection("suggestions")
             .where(filter=FieldFilter("status", "==", "pending"))
             .where(filter=FieldFilter("created_at", "<", cutoff)))
                
                stale_suggestions = list(stale_query.stream())
                count = 0
                
                for suggestion_doc in stale_suggestions:
                    db.collection("suggestions").document(suggestion_doc.id).update({
                        "status": "rejected",
                        "reviewed_by": "system_cleanup",
                        "reviewed_at": datetime.utcnow(),
                        "rejection_reason": f"Automatically rejected after {days_old} days"
                    })
                    count += 1
                
                if count > 0:
                    st.success(f"‚úÖ Rejected {count} stale suggestions older than {days_old} days.")
                    
                    # Log the cleanup action
                    db.collection("logs").add({
                        "action": "cleanup_stale_suggestions",
                        "user_id": st.session_state.get("user", {}).get("id", "system"),
                        "timestamp": datetime.utcnow(),
                        "details": {"count": count, "days_old": days_old}
                    })
                else:
                    st.info("No stale suggestions found.")
                    
            except Exception as e:
                st.error(f"‚ùå Cleanup failed: {e}")
    
    st.divider()
    
    # Orphaned files cleanup
    st.markdown("### üìÅ Orphaned Files")
    st.caption("Files linked to events that no longer exist")
    
    if st.button("üîç Find Orphaned Files"):
        try:
            deleted_files = list(db.collection("files").where(filter=FieldFilter("deleted", "==", True)).stream())
            orphaned = []
            
            for file_doc in files:
                file_data = file_doc.to_dict()
                if file_data.get("event_id"):
                    event_exists = db.collection("events").document(file_data["event_id"]).get().exists
                    if not event_exists:
                        orphaned.append((file_doc.id, file_data))
            
            if orphaned:
                st.warning(f"Found {len(orphaned)} orphaned files:")
                
                for file_id, file_data in orphaned:
                    st.write(f"- {file_data.get('filename', 'Unknown')} (linked to {file_data.get('event_id')})")
                
                if st.button("üßπ Unlink Orphaned Files"):
                    for file_id, _ in orphaned:
                        db.collection("files").document(file_id).update({"event_id": None})
                    
                    st.success(f"‚úÖ Unlinked {len(orphaned)} orphaned files")
            else:
                st.success("‚úÖ No orphaned files found")
                
        except Exception as e:
            st.error(f"‚ùå Could not check for orphaned files: {e}")
    
    st.divider()
    
    # Permanent deletion of soft-deleted files
    st.markdown("### üóëÔ∏è Permanent Deletion")
    st.caption("Permanently delete files that have been soft-deleted")
    
    try:
        deleted_files = list(db.collection("files").where(filter=FieldFilter("deleted", "==", True)).stream())
        
        if deleted_files:
            st.warning(f"Found {len(deleted_files)} soft-deleted files")
            
            # Show some examples
            st.write("Examples:")
            for i, file_doc in enumerate(deleted_files[:5]):
                file_data = file_doc.to_dict()
                deleted_at = format_timestamp(file_data.get('deleted_at'))
                st.write(f"- {file_data.get('filename', 'Unknown')} (deleted {deleted_at})")
            
            if len(deleted_files) > 5:
                st.write(f"... and {len(deleted_files) - 5} more")
            
            st.error("‚ö†Ô∏è **Warning:** This action cannot be undone!")
            
            confirm_text = st.text_input("Type 'DELETE PERMANENTLY' to confirm:")
            
            if confirm_text == "DELETE PERMANENTLY" and delete_button("üóëÔ∏è Delete Permanently", key="permadelete"):
                count = 0
                for file_doc in deleted_files:
                    try:
                        db.collection("files").document(file_doc.id).delete()
                        count += 1
                    except Exception as e:
                        st.error(f"Failed to delete {file_doc.id}: {e}")
                
                if count > 0:
                    st.success(f"‚úÖ Permanently deleted {count} files")
                    
                    # Log the action
                    db.collection("logs").add({
                        "action": "permanent_file_deletion",
                        "user_id": st.session_state.get("user", {}).get("id", "system"),
                        "timestamp": datetime.utcnow(),
                        "details": {"count": count}
                    })
        else:
            st.info("No soft-deleted files found")
            
    except Exception as e:
        st.error(f"‚ùå Could not check deleted files: {e}")

# ----------------------------
# üì¶ Archive Events
# ----------------------------
def _archive_event_tool():
    """Archive completed events"""
    st.subheader("üì¶ Archive Completed Events")
    
    try:
        # Find completed events that aren't archived
        completed_events = list(db.collection("events")
                               .where("status", "==", "complete")
                               .where("archived", "==", False)
                               .stream())
        
        if not completed_events:
            st.success("‚úÖ No completed events need archiving")
            return
        
        st.info(f"Found {len(completed_events)} completed events ready for archival")
        
        # Show events that will be archived
        st.markdown("### Events to Archive:")
        for event_doc in completed_events[:10]:  # Show first 10
            event_data = event_doc.to_dict()
            st.write(f"- **{event_data.get('name', 'Unnamed')}** ({event_data.get('start_date', 'Unknown date')})")
        
        if len(completed_events) > 10:
            st.write(f"... and {len(completed_events) - 10} more")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("üì¶ Archive All Completed Events"):
                archived_count = 0
                
                for event_doc in completed_events:
                    try:
                        db.collection("events").document(event_doc.id).update({
                            "archived": True,
                            "archived_at": datetime.utcnow()
                        })
                        archived_count += 1
                    except Exception as e:
                        st.error(f"Failed to archive event {event_doc.id}: {e}")
                
                if archived_count > 0:
                    st.success(f"‚úÖ Archived {archived_count} completed events")
                    
                    # Send notification
                    send_notification(
                        f"Archived {archived_count} completed events",
                        role="admin"
                    )
                    
                    # Log the action
                    db.collection("logs").add({
                        "action": "archive_completed_events",
                        "user_id": st.session_state.get("user", {}).get("id", "system"),
                        "timestamp": datetime.utcnow(),
                        "details": {"count": archived_count}
                    })
                    
                    st.rerun()
        
        with col2:
            # Option to archive events older than X days
            days_old = st.number_input("Or archive events completed more than X days ago:", min_value=1, value=30)
            
            if st.button(f"üì¶ Archive Events Older Than {days_old} Days"):
                cutoff_date = datetime.utcnow() - timedelta(days=days_old)
                
                old_events = [
                    event_doc for event_doc in completed_events
                    if event_doc.to_dict().get('completed_at', datetime.min) < cutoff_date
                ]
                
                if old_events:
                    for event_doc in old_events:
                        db.collection("events").document(event_doc.id).update({
                            "archived": True,
                            "archived_at": datetime.utcnow()
                        })
                    
                    st.success(f"‚úÖ Archived {len(old_events)} events older than {days_old} days")
                else:
                    st.info(f"No events found that are older than {days_old} days")
        
    except Exception as e:
        st.error(f"‚ö†Ô∏è Could not load completed events: {e}")

# ----------------------------
# üìä System Statistics
# ----------------------------
def get_system_stats():
    """Get comprehensive system statistics"""
    try:
        stats = {
            "events": {
                "total": 0,
                "active": 0,
                "completed": 0,
                "archived": 0
            },
            "users": {"total": 0, "admins": 0, "managers": 0},
            "files": {"total": 0, "deleted": 0},
            "suggestions": {"pending": 0, "approved": 0, "rejected": 0}
        }
        
        # Count events
        events = list(db.collection("events").stream())
        stats["events"]["total"] = len(events)
        
        for event_doc in events:
            event_data = event_doc.to_dict()
            status = event_data.get("status", "planning")
            if status == "active":
                stats["events"]["active"] += 1
            elif status == "complete":
                stats["events"]["completed"] += 1
            
            if event_data.get("archived"):
                stats["events"]["archived"] += 1
        
        # Count users
        users = list(db.collection("users").stream())
        stats["users"]["total"] = len(users)
        
        for user_doc in users:
            user_data = user_doc.to_dict()
            role = user_data.get("role", "viewer")
            if role == "admin":
                stats["users"]["admins"] += 1
            elif role == "manager":
                stats["users"]["managers"] += 1
        
        # Count files
        files = list(db.collection("files").stream())
        stats["files"]["total"] = len(files)
        stats["files"]["deleted"] = len([f for f in files if f.to_dict().get("deleted")])
        
        # Count suggestions
        suggestions = list(db.collection("suggestions").stream())
        for suggestion_doc in suggestions:
            suggestion_data = suggestion_doc.to_dict()
            status = suggestion_data.get("status", "pending")
            if status in stats["suggestions"]:
                stats["suggestions"][status] += 1
        
        return stats
        
    except Exception as e:
        st.error(f"Could not calculate system statistics: {e}")
        return None


=== ai_chat.py ===
import streamlit as st
from datetime import datetime
from auth import get_user_role
from firebase_init import db
from utils import format_date, generate_id, get_active_event, get_active_event_id, value_to_text, delete_button
import json
from google.cloud.firestore_v1.base_query import FieldFilter
from firebase_admin import firestore

# Initialize OpenAI client
try:
    from openai import OpenAI
    
    api_key = st.secrets.get("openai", {}).get("api_key", "")
    if api_key and api_key != "":
        client = OpenAI(api_key=api_key)
    else:
        client = None
        st.warning("‚ö†Ô∏è OpenAI API key not configured")
except ImportError:
    client = None
    st.error("‚ùå OpenAI library not installed")
except Exception as e:
    client = None
    st.error(f"‚ùå OpenAI initialization failed: {e}")

# ----------------------------
# üí¨ AI Chat Assistant UI
# ----------------------------
def ai_chat_ui():
    st.title("üí¨ Assistant")
    st.caption("Your AI-powered catering assistant for event planning, menus, and coordination.")

    user = st.session_state.get("user")
    if not user:
        st.warning("You must be signed in to use the assistant.")
        return
    selected_recipe_id = st.session_state.get("selected_recipe_id")
    recipe_context = None
    if selected_recipe_id:
        try:
            recipe_doc = db.collection("recipes").document(selected_recipe_id).get()
            if recipe_doc.exists:
                recipe_context = recipe_doc.to_dict()
        except Exception as e:
            st.warning(f"‚ö†Ô∏è Failed to load recipe context: {e}")


    # Check if OpenAI is available
    if not client:
        st.error("ü§ñ AI Assistant is currently unavailable. Please check the configuration.")
        return

    role = get_user_role(user)

    # Show current context
    active_event = get_active_event()
    if active_event:
        st.info(f"üéØ Active Event: **{active_event.get('name', 'Unknown')}** ({active_event.get('guest_count', 0)} guests)")
    else:
        st.info("üí° No active event. AI will provide general catering assistance.")

    # Quick action buttons
    st.markdown("### üéØ Quick Actions")
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        if st.button("üõí Shopping List", use_container_width=True):
            handle_quick_action("shopping")
    
    with col2:
        if st.button("üìã Menu Plan", use_container_width=True):
            handle_quick_action("menu")
    
    with col3:
        if st.button("‚è∞ Timeline", use_container_width=True):
            handle_quick_action("timeline")
    
    with col4:
        if st.button("üìä Quantities", use_container_width=True):
            handle_quick_action("quantities")

    # Initialize chat history
    if "chat_history" not in st.session_state:
        st.session_state.chat_history = []

    if recipe_context:
        with st.expander("üìò Recipe Context (linked)", expanded=False):
            st.markdown(f"**Name:** {recipe_context.get('name', 'Unnamed')}")
            st.markdown(f"**Author:** {recipe_context.get('author_name', 'Unknown')}")
            st.markdown(f"**Ingredients:**\n{value_to_text(recipe_context.get('ingredients', ''))}")
            st.markdown(f"**Instructions:**\n{value_to_text(recipe_context.get('instructions', ''))}")
            if st.button("üß† Ask AI about this recipe"):
                st.session_state.chat_history.append({
                    "sender": "user",
                    "content": f"Analyze or suggest improvements for this recipe: {recipe_context.get('name', '')}",
                    "timestamp": format_date(datetime.now())
                })
                st.rerun()


    # Chat interface
    st.markdown("### üí¨ Conversation")
    
    # Display chat history
    for i, chat in enumerate(st.session_state.chat_history[-20:]):  # Show last 20 messages
        if chat.get("sender") == "user":
            st.markdown(f"**üßë You:** {chat.get('content', '')}")
        else:
            with st.expander(f"ü§ñ **AI** - {chat.get('timestamp', 'Now')}", expanded=(i == len(st.session_state.chat_history) - 1)):
                st.markdown(chat.get('content', ''))
                
                # Show action buttons if AI suggested actions
                if chat.get('actions'):
                    st.markdown("**Suggested Actions:**")
                    for action in chat['actions']:
                        if st.button(action['label'], key=f"action_{i}_{action['id']}"):
                            handle_ai_action(action)

    # Chat input
    with st.form("chat_input_form", clear_on_submit=True):
        user_input = st.text_area(
            "Ask your question:", 
            placeholder="E.g., 'Help me plan a menu for 50 people with vegetarian options'",
            height=100
        )
        
        col1, col2, col3 = st.columns([1, 1, 3])
        with col1:
            include_context = st.checkbox("Include event details", value=True)
        with col2:
            send_button = st.form_submit_button("Send", type="primary", use_container_width=True)
        
        if send_button and user_input.strip():
            with st.spinner("ü§ñ Thinking..."):
                response = get_openai_response(user_input.strip(), role, user, include_context)
                
                # Add to chat history
                st.session_state.chat_history.append({
                    "sender": "user",
                    "content": user_input.strip(),
                    "timestamp": format_date(datetime.now())
                })
                
                st.session_state.chat_history.append({
                    "sender": "ai",
                    "content": response["content"],
                    "actions": response.get("actions", []),
                    "timestamp": format_date(datetime.now())
                })
                
                # Log conversation
                log_conversation(user["id"], user_input.strip(), response["content"], role)
                
                st.rerun()

    # Clear chat button
    if delete_button("üóëÔ∏è Clear Conversation", key="clear_chat"):
        st.session_state.chat_history = []
        st.success("Conversation cleared")
        st.rerun()

# ----------------------------
# ü§ñ AI Response Generation
# ----------------------------
def get_openai_response(prompt: str, role: str, user: dict, include_context: bool = True) -> dict:
    """Get response from OpenAI with full context"""
    if not client:
        return {
            "content": "‚ö†Ô∏è AI service is not available. Please check the configuration.",
            "actions": []
        }
    
    try:
        # Build context
        context = build_context(user, include_context)
        
        # System message
        system_message = f"""You are a professional catering assistant for Mountain Medicine Catering. 
You help with event planning, menu design, shopping lists, timelines, and coordination.

User role: {role}
{context}

Provide practical, actionable advice. Be specific with quantities, timings, and steps.
When relevant, suggest concrete actions the user can take.
Format your responses with clear sections using markdown.
If you suggest creating lists or documents, format them properly."""

        # Get recent chat history for context
        recent_history = []
        for chat in st.session_state.get("chat_history", [])[-10:]:
            recent_history.append({
                "role": "user" if chat["sender"] == "user" else "assistant",
                "content": chat["content"]
            })

        # Build messages
        messages = [
            {"role": "system", "content": system_message}
        ]
        messages.extend(recent_history)
        messages.append({"role": "user", "content": prompt})

        # Get response
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=messages,
            temperature=0.7,
            max_tokens=1000,
        )
        
        content = response.choices[0].message.content.strip()
        
        # Extract any actionable items
        actions = extract_actions(content, prompt)
        
        return {
            "content": content,
            "actions": actions
        }
        
    except Exception as e:
        return {
            "content": f"‚ö†Ô∏è I encountered an error: {str(e)}. Please try again or rephrase your question.",
            "actions": []
        }

# ----------------------------
# üéØ Quick Action Handlers
# ----------------------------
def handle_quick_action(action_type: str):
    """Handle quick action button clicks"""
    active_event = get_active_event()
    
    if not active_event and action_type != "general":
        st.warning("Please activate an event first to use this quick action.")
        return
    
    prompts = {
        "shopping": f"Create a detailed shopping list for {active_event.get('name', 'the event')} with {active_event.get('guest_count', 20)} guests. Include quantities and organize by store sections.",
        "menu": f"Suggest a complete menu for {active_event.get('name', 'the event')} with {active_event.get('guest_count', 20)} guests. Consider dietary restrictions: {active_event.get('dietary_restrictions', 'none specified')}",
        "timeline": f"Create a detailed preparation timeline for {active_event.get('name', 'the event')} on {active_event.get('start_date', 'the event date')}. Include all prep stages.",
        "quantities": f"Calculate ingredient quantities for {active_event.get('guest_count', 20)} guests. Include portion sizes and account for 10% buffer."
    }
    
    if action_type in prompts:
        # Add to chat as if user typed it
        st.session_state.setdefault("chat_history", []).append({
            "sender": "user",
            "content": prompts[action_type],
            "timestamp": format_date(datetime.now())
        })
        
        # Get AI response
        user = st.session_state.get("user")
        role = get_user_role(user)
        
        with st.spinner("ü§ñ Generating..."):
            response = get_openai_response(prompts[action_type], role, user, True)
            
            st.session_state.chat_history.append({
                "sender": "ai",
                "content": response["content"],
                "actions": response.get("actions", []),
                "timestamp": format_date(datetime.now())
            })
            
            log_conversation(user["id"], prompts[action_type], response["content"], role)
        
        st.rerun()

# ----------------------------
# üîß Helper Functions
# ----------------------------
def build_context(user: dict, include_event: bool = True) -> str:
    """Build context string for AI"""
    context_parts = []
        # Add recipe context if available
    recipe_id = st.session_state.get("selected_recipe_id")
    if recipe_id:
        try:
            recipe_doc = db.collection("recipes").document(recipe_id).get()
            if recipe_doc.exists:
                recipe = recipe_doc.to_dict()
                context_parts.append(f"Recipe: {recipe.get('name', 'Unnamed')}")
                context_parts.append("Ingredients:\n" + recipe.get("ingredients", "‚Äî"))
                context_parts.append("Instructions:\n" + recipe.get("instructions", "‚Äî"))
        except Exception as e:
            context_parts.append("‚ö†Ô∏è Failed to load selected recipe context.")

    
    if include_event:
        active_event = get_active_event()
        if active_event:
            context_parts.append(f"Active Event: {active_event.get('name', 'Unknown')}")
            context_parts.append(f"Date: {active_event.get('start_date', 'TBD')} to {active_event.get('end_date', 'TBD')}")
            context_parts.append(f"Location: {active_event.get('location', 'TBD')}")
            context_parts.append(f"Guests: {active_event.get('guest_count', 0)}")
            context_parts.append(f"Staff: {active_event.get('staff_count', 0)}")
            
            if active_event.get('dietary_restrictions'):
                context_parts.append(f"Dietary Restrictions: {active_event['dietary_restrictions']}")
            if active_event.get('food_allergies'):
                context_parts.append(f"Allergies: {active_event['food_allergies']}")
            
            # Get menu items count
            try:
                menu_count = len(list(db.collection("menus").where("event_id", "==", active_event["id"]).stream()))
                context_parts.append(f"Menu Items: {menu_count}")
            except:
                pass
    
    return "\n".join(context_parts) if context_parts else "No active event context."

def extract_actions(content: str, prompt: str) -> list:
    """Extract actionable items from AI response"""
    actions = []
    
    # Check for shopping list generation
    if any(word in content.lower() for word in ['shopping list', 'grocery list', 'ingredients to buy']):
        actions.append({
            "id": "create_shopping",
            "label": "üìù Save as Shopping List",
            "type": "shopping_list",
            "data": content
        })
    
    # Check for menu suggestions
    if any(word in content.lower() for word in ['menu suggestion', 'menu plan', 'dishes']):
        actions.append({
            "id": "save_menu",
            "label": "üíæ Save Menu Suggestions",
            "type": "menu",
            "data": content
        })
    
    # Check for timeline
    if any(word in content.lower() for word in ['timeline', 'schedule', 'preparation steps']):
        actions.append({
            "id": "create_timeline",
            "label": "üìÖ Create Tasks from Timeline",
            "type": "timeline",
            "data": content
        })
    
    return actions

def handle_ai_action(action: dict):
    """Handle action button clicks from AI suggestions"""
    action_type = action.get("type")
    data = action.get("data", "")
    
    if action_type == "shopping_list":
        # Parse and save shopping list
        try:
            active_event_id = get_active_event_id()
            if active_event_id:
                save_ai_shopping_list(active_event_id, data)
                st.success("‚úÖ Shopping list saved to the event!")
            else:
                st.warning("Please activate an event first")
        except Exception as e:
            st.error(f"Failed to save shopping list: {e}")
    
    elif action_type == "menu":
        # Save menu suggestions
        st.info("Menu saving feature coming soon!")
    
    elif action_type == "timeline":
        # Create tasks from timeline
        st.info("Task creation feature coming soon!")
    
    st.rerun()

def save_ai_shopping_list(event_id: str, content: str):
    """Parse AI content and save as shopping items"""
    # Simple parsing - this could be enhanced
    lines = content.split('\n')
    shopping_ref = db.collection("events").document(event_id).collection("shopping_items")
    
    current_category = "Other"
    for line in lines:
        line = line.strip()
        if not line:
            continue
            
        # Check if it's a category header
        if line.startswith('**') and line.endswith('**'):
            current_category = line.strip('*').strip(':').strip()
        elif line.startswith('‚Ä¢') or line.startswith('-'):
            # It's an item
            item_text = line.strip('‚Ä¢-').strip()
            
            # Try to extract quantity
            parts = item_text.split('(')
            if len(parts) > 1:
                name = parts[0].strip()
                qty_part = parts[1].strip(')')
                # Simple quantity extraction
                quantity = qty_part.split()[0] if qty_part else ""
                unit = ' '.join(qty_part.split()[1:]) if len(qty_part.split()) > 1 else ""
            else:
                name = item_text
                quantity = ""
                unit = ""
            
            if name:
                item_id = generate_id("shop")
                shopping_ref.document(item_id).set({
                    "id": item_id,
                    "name": name,
                    "quantity": quantity,
                    "unit": unit,
                    "category": current_category,
                    "purchased": False,
                    "created_at": datetime.utcnow(),
                    "created_by": "ai_assistant"
                })

def log_conversation(user_id: str, query: str, response: str, user_role: str):
    """Log conversation to database"""
    try:
        db.collection("ai_logs").add({
            "query": query,
            "response": response,
            "user_id": user_id,
            "user_role": user_role,
            "created_at": datetime.utcnow(),
            "event_id": get_active_event_id()
        })
    except Exception as e:
        print(f"Failed to log conversation: {e}")

# ----------------------------
# üìä AI Usage Analytics
# ----------------------------
def show_ai_usage_analytics():
    """Show AI usage statistics"""
    st.subheader("üìä AI Assistant Usage")
    
    try:
        # Get usage logs
        logs = list(db.collection("ai_logs").order_by("created_at", direction=firestore.Query.DESCENDING).limit(100).stream())
        
        if not logs:
            st.info("No AI usage data yet.")
            return
        
        # Calculate metrics
        total_queries = len(logs)
        unique_users = len(set(log.to_dict().get("user_id") for log in logs))
        
        # Common query types
        query_types = {
            "shopping": 0,
            "menu": 0,
            "timeline": 0,
            "quantities": 0,
            "other": 0
        }
        
        for log in logs:
            query = log.to_dict().get("query", "").lower()
            if "shopping" in query or "grocery" in query:
                query_types["shopping"] += 1
            elif "menu" in query or "food" in query or "dish" in query:
                query_types["menu"] += 1
            elif "timeline" in query or "schedule" in query:
                query_types["timeline"] += 1
            elif "quantity" in query or "portion" in query or "how much" in query:
                query_types["quantities"] += 1
            else:
                query_types["other"] += 1
        
        # Display metrics
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Total Queries", total_queries)
        with col2:
            st.metric("Unique Users", unique_users)
        with col3:
            avg_per_user = total_queries / unique_users if unique_users > 0 else 0
            st.metric("Avg Queries/User", f"{avg_per_user:.1f}")
        
        # Query type breakdown
        st.markdown("#### Query Types")
        for qtype, count in sorted(query_types.items(), key=lambda x: x[1], reverse=True):
            if count > 0:
                percentage = (count / total_queries) * 100
                st.write(f"**{qtype.title()}:** {count} ({percentage:.1f}%)")
        
    except Exception as e:
        st.error(f"Could not load analytics: {e}")


=== ai_parsing_engine.py ===
import io
import os
import tempfile
import mimetypes
import csv
import re
import openai
import fitz  # PyMuPDF
from PIL import Image
import pytesseract
from docx import Document
import requests
from bs4 import BeautifulSoup
import json
from datetime import datetime
import streamlit as st
from firebase_init import db, firestore
from utils import normalize_keys, normalize_recipe_quantities
from recipes import (
    save_recipe_to_firestore,
    save_event_to_firestore,
    save_menu_to_firestore,
    save_ingredient_to_firestore,
)

client = openai.OpenAI(api_key=st.secrets["openai"]["api_key"])

# --------------------------------------------
# üßπ Central Cleaning & Validation Utils
# --------------------------------------------

def clean_raw_text(text: str) -> str:
    text = text.replace("\r", "").strip()
    lines = text.split("\n")
    cleaned = [line for line in lines if len(line.strip()) > 2 and not line.lower().startswith("http")]
    return "\n".join(cleaned)

def is_meaningful_recipe(recipe: dict) -> bool:
    if not isinstance(recipe, dict):
        return False
    if not (recipe.get("name") or recipe.get("title")):
        return False
    return bool(recipe.get("ingredients") or recipe.get("instructions"))

# --------------------------------------------
# üß† Main Entry Point (Patched)
# --------------------------------------------

def parse_file(uploaded_file, target_type="all", user_id=None, file_id=None):
    st.warning("üß™ Running parse_file()...")
    print("üìÑ STARTING parse_file()")

    raw_text = extract_text(uploaded_file)
    st.session_state["extracted_text"] = raw_text
    image_url = extract_image_from_file(uploaded_file)

    if raw_text and raw_text.strip():
        st.success("‚úÖ Some text extracted.")
        print("üìÑ Extracted text:", raw_text[:300])
    else:
        st.warning("‚ùå No text extracted from file.")
        return {}

    parsed = {}
    target_types = [target_type] if target_type != "all" else [
        "recipes", "menus", "tags", "ingredients", "allergens"
    ]

    cleaned_text = clean_raw_text(raw_text)

    for t in target_types:
        parsed[t] = query_ai_parser(cleaned_text, t)
        if t == "recipes":
            recipe_data = parsed[t]
            if isinstance(recipe_data, dict) and "recipes" in recipe_data:
                recipe_data = recipe_data["recipes"]
            if isinstance(recipe_data, list):
                recipe_data = [normalize_keys(r) for r in recipe_data]
                if image_url:
                    for r in recipe_data:
                        r.setdefault("image_url", image_url)
            else:
                recipe_data = normalize_keys(recipe_data)
                if image_url:
                    recipe_data.setdefault("image_url", image_url)
            normalize_recipe_quantities(recipe_data)
            parsed[t] = recipe_data

    if file_id:
        parsed_record = {
            "parsed": parsed,
            "version": 1,
            "status": "unusable" if not is_meaningful_recipe(parsed.get("recipes", {})) else "pending_review",
            "raw_text": raw_text[:5000],
            "last_updated": datetime.utcnow(),
            "user_id": user_id
        }
        try:
            db.collection("files").document(file_id).update({"parsed_data": parsed_record})
            st.warning("‚úÖ Saved parsed_data to Firestore")
        except Exception as e:
            print(f"Error saving parsed data to Firestore: {e}")

    return parsed

# --------------------------------------------
# üìÑ Text Extraction
# --------------------------------------------

def extract_text(uploaded_file):
    mime_type, _ = mimetypes.guess_type(uploaded_file.name)
    try:
        uploaded_file.seek(0)
        if uploaded_file.type.startswith("text"):
            return uploaded_file.read().decode("utf-8")
        elif uploaded_file.type == "application/pdf":
            return extract_text_from_pdf(uploaded_file)
        elif uploaded_file.type.startswith("image"):
            return extract_text_from_image(uploaded_file)
        elif uploaded_file.type in ("text/csv", "application/vnd.ms-excel", "application/csv"):
            return extract_text_from_csv(uploaded_file)
        elif uploaded_file.type in (
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "application/msword",
        ):
            return extract_text_from_docx(uploaded_file)
        else:
            return uploaded_file.read().decode("utf-8", errors="ignore")
    except Exception as e:
        print(f"Text extraction error: {e}")
        return ""

def extract_text_from_pdf(uploaded_file):
    text = ""
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp:
            tmp.write(uploaded_file.read())
            tmp_path = tmp.name
        doc = fitz.open(tmp_path)
        for page in doc:
            text += page.get_text()
        doc.close()
        os.remove(tmp_path)
    except Exception as e:
        print(f"PDF parse error: {e}")
    return text

def extract_text_from_image(uploaded_file):
    try:
        image = Image.open(uploaded_file)
        return pytesseract.image_to_string(image)
    except Exception as e:
        print(f"Image OCR error: {e}")
        return ""

def extract_text_from_csv(uploaded_file):
    try:
        text = uploaded_file.read().decode("utf-8", errors="ignore")
        uploaded_file.seek(0)
        reader = csv.reader(io.StringIO(text))
        return "\n".join([", ".join(row) for row in reader])
    except Exception as e:
        print(f"CSV parse error: {e}")
        return ""

def extract_text_from_docx(uploaded_file):
    try:
        document = Document(uploaded_file)
        return "\n".join([para.text for para in document.paragraphs])
    except Exception as e:
        print(f"DOCX parse error: {e}")
        return ""

# --------------------------------------------
# üñºÔ∏è Image Extraction Helpers
# --------------------------------------------

import base64
from urllib.parse import urljoin


def extract_image_from_pdf(uploaded_file):
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp:
            tmp.write(uploaded_file.read())
            tmp_path = tmp.name
        doc = fitz.open(tmp_path)
        for page in doc:
            images = page.get_images(full=True)
            if images:
                xref = images[0][0]
                base_image = doc.extract_image(xref)
                img_bytes = base_image.get("image")
                ext = base_image.get("ext", "png")
                b64 = base64.b64encode(img_bytes).decode("utf-8")
                doc.close()
                os.remove(tmp_path)
                return f"data:image/{ext};base64,{b64}"
        doc.close()
        os.remove(tmp_path)
    except Exception as e:
        print(f"PDF image extraction error: {e}")
    return None


def extract_image_from_docx_file(uploaded_file):
    try:
        document = Document(uploaded_file)
        for rel in document.part._rels.values():
            target = rel.target_part
            if "image" in target.content_type:
                b64 = base64.b64encode(target.blob).decode("utf-8")
                ext = target.content_type.split("/")[-1]
                return f"data:image/{ext};base64,{b64}"
    except Exception as e:
        print(f"DOCX image extraction error: {e}")
    return None


def extract_image_from_file(uploaded_file):
    try:
        uploaded_file.seek(0)
        if uploaded_file.type.startswith("image"):
            b64 = base64.b64encode(uploaded_file.read()).decode("utf-8")
            return f"data:{uploaded_file.type};base64,{b64}"
        elif uploaded_file.type == "application/pdf":
            return extract_image_from_pdf(uploaded_file)
        elif uploaded_file.type in (
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "application/msword",
        ):
            return extract_image_from_docx_file(uploaded_file)
    except Exception as e:
        print(f"Image extraction error: {e}")
    return None


def extract_image_from_soup(soup, base_url):
    props = ["og:image", "og:image:url", "twitter:image"]
    for prop in props:
        tag = soup.find("meta", property=prop)
        if tag and tag.get("content"):
            return urljoin(base_url, tag["content"])
    img_tag = soup.find("img")
    if img_tag and img_tag.get("src"):
        return urljoin(base_url, img_tag["src"])
    return None

# --------------------------------------------
# ü§ñ AI Prompt Routing (Patched)
# --------------------------------------------

def query_ai_parser(raw_text, target_type):
    system_prompt = (
        "You are an expert data parser. Extract only structured data from unstructured text.\n"
        "Return only a JSON object using proper capitalization.\n"
        "When parsing recipes, include a concise list of relevant tags such as cuisine, meal type, diets or allergens.\n"
        "- recipes ‚Üí include name, ingredients, instructions, servings, tags\n"
        "- menus ‚Üí day, meal, items\n"
        "- tags ‚Üí list of relevant tags\n"
        "- ingredients ‚Üí list of items with quantity + unit if available\n"
        "- allergens ‚Üí list of known allergens mentioned"
    )

    user_prompt = f"""
Extract structured {target_type} data from the following text. 
Use common section headers like:
- Ingredients:
- Instructions:
- Steps:
- Servings:

Only return a JSON object.

```
{raw_text[:6000]}
```
"""

    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.3,
            response_format={"type": "json_object"}
        )

        raw_output = response.choices[0].message.content
        print("üîç AI raw output:", raw_output)
        st.warning("üîç AI raw output:\n" + raw_output)

        try:
            return json.loads(raw_output)
        except json.JSONDecodeError:
            match = re.search(r"\{.*\}", raw_output, re.DOTALL)
            if match:
                return json.loads(match.group(0))
            raise

    except json.JSONDecodeError:
        st.error("‚ùå Failed to parse AI response as valid JSON.")
        return {}

    except Exception as e:
        st.error(f"OpenAI error: {e}")
        return {}

# --------------------------------------------
# üåê Parse Recipe From URL (Patched)
# --------------------------------------------

def parse_recipe_from_url(url: str) -> dict:
    try:
        resp = requests.get(url, timeout=10)
        resp.raise_for_status()
        soup = BeautifulSoup(resp.text, "html.parser")
        text = soup.get_text(separator="\n")
        image_url = extract_image_from_soup(soup, url)
    except Exception as e:
        st.error(f"Failed to fetch page: {e}")
        return {}

    cleaned_text = clean_raw_text(text)
    parsed = query_ai_parser(cleaned_text, "recipes")

    # API may return the recipe nested under a "recipes" key
    recipe = parsed
    if isinstance(parsed, dict) and "recipes" in parsed:
        recipe = parsed["recipes"]
        if isinstance(recipe, list):
            recipe = recipe[0] if recipe else {}

    # Normalize key casing for downstream logic
    recipe = normalize_keys(recipe)
    normalize_recipe_quantities(recipe)
    if image_url and not recipe.get("image_url"):
        recipe["image_url"] = image_url

    if not is_meaningful_recipe(recipe):
        st.warning(
            "‚ö†Ô∏è Recipe content extracted from URL appears to be incomplete or unusable."
        )
        return {}

    return recipe

# --------------------------------------------
# üíæ Modular Save Buttons
# --------------------------------------------

def render_extraction_buttons(file_id, parsed_data, user_id=None):
    from utils import get_active_event_id

    if not parsed_data:
        st.info("No parsed data available.")
        return

    st.markdown("## üíæ Save Extracted Content")

    if "recipes" in parsed_data and parsed_data["recipes"]:
        recipes = parsed_data["recipes"]
        recipes = recipes if isinstance(recipes, list) else [recipes]
        if st.button("üì• Save Recipes"):
            try:
                for r in recipes:
                    save_recipe_to_firestore(r, user_id=user_id, file_id=file_id)
                st.success("‚úÖ Recipes saved to database")
            except Exception as e:
                st.error(f"Failed to save recipes: {e}")

    if "menus" in parsed_data and parsed_data["menus"]:
        menus = parsed_data["menus"]
        menus = menus if isinstance(menus, list) else [menus]
        event_id = get_active_event_id()
        if st.button("üì• Save Menus"):
            try:
                for m in menus:
                    save_menu_to_firestore(m, event_id=event_id, user_id=user_id, file_id=file_id)
                st.success("‚úÖ Menus saved to database")
            except Exception as e:
                st.error(f"Failed to save menus: {e}")

    if "events" in parsed_data and parsed_data["events"]:
        events = parsed_data["events"]
        events = events if isinstance(events, list) else [events]
        if st.button("üì• Save Events"):
            try:
                for e in events:
                    save_event_to_firestore(e, user_id=user_id, file_id=file_id)
                st.success("‚úÖ Events saved to database")
            except Exception as e:
                st.error(f"Failed to save events: {e}")

    if "ingredients" in parsed_data and parsed_data["ingredients"]:
        ingredients = parsed_data["ingredients"]
        if st.button("üì• Save Ingredients"):
            try:
                for ing in ingredients:
                    save_ingredient_to_firestore(ing, user_id=user_id, file_id=file_id)
                st.success("‚úÖ Ingredients saved to database")
            except Exception as e:
                st.error(f"Failed to save ingredients: {e}")

    st.markdown("---")
    st.subheader("üß™ Parsed Data")
    st.json(parsed_data)


=== allergies.py ===
# allergies.py

import streamlit as st
from utils import generate_id, format_date, get_active_event_id, get_event_by_id, delete_button
from auth import require_login, get_user_role
from datetime import datetime
from typing import List, Dict, Optional
import re


# ----------------------------
# üö® Allergy Management
# ----------------------------

def add_allergy_to_event(event_id: str, allergy_data: Dict) -> bool:
    """Add an allergy entry to an event"""
    try:
        allergy_id = generate_id("allergy")
        allergy_data['id'] = allergy_id
        allergy_data['created_at'] = datetime.utcnow()
        
        # Add to event's allergies subcollection
        db.collection("events").document(event_id).collection("allergies").document(allergy_id).set(allergy_data)
        
        # Update ingredient allergen info
        for ingredient_id in allergy_data.get('ingredient_ids', []):
            _update_ingredient_allergen_info(ingredient_id, allergy_data['person_name'], allergy_data['allergies'])
        
        return True
        
    except Exception as e:
        st.error(f"Failed to add allergy: {e}")
        return False

def get_event_allergies(event_id: str) -> List[Dict]:
    """Get all allergies for an event"""
    try:
        allergies = db.collection("events").document(event_id).collection("allergies").stream()
        return [doc.to_dict() for doc in allergies]
    except Exception as e:
        st.error(f"Failed to get allergies: {e}")
        return []

def update_allergy(event_id: str, allergy_id: str, updates: Dict) -> bool:
    """Update an allergy entry"""
    try:
        db.collection("events").document(event_id).collection("allergies").document(allergy_id).update(updates)
        return True
    except Exception as e:
        st.error(f"Failed to update allergy: {e}")
        return False

def delete_allergy(event_id: str, allergy_id: str) -> bool:
    """Delete an allergy entry"""
    try:
        # Get allergy data first to remove allergen info from ingredients
        allergy_doc = db.collection("events").document(event_id).collection("allergies").document(allergy_id).get()
        if allergy_doc.exists:
            allergy_data = allergy_doc.to_dict()
            person_name = allergy_data.get('person_name')
            
            # Remove allergen info from ingredients
            for ingredient_id in allergy_data.get('ingredient_ids', []):
                _remove_ingredient_allergen_info(ingredient_id, person_name)
        
        # Delete the allergy
        db.collection("events").document(event_id).collection("allergies").document(allergy_id).delete()
        return True
        
    except Exception as e:
        st.error(f"Failed to delete allergy: {e}")
        return False

def _update_ingredient_allergen_info(ingredient_id: str, person_name: str, allergies: List[str]):
    """Update ingredient with allergen information"""
    try:
        ingredient_ref = db.collection("ingredients").document(ingredient_id)
        ingredient_doc = ingredient_ref.get()
        
        if ingredient_doc.exists:
            current_allergen_info = ingredient_doc.to_dict().get('allergen_info', {})
            current_allergen_info[person_name] = allergies
            ingredient_ref.update({'allergen_info': current_allergen_info})
            
    except Exception as e:
        print(f"Failed to update ingredient allergen info: {e}")

def _remove_ingredient_allergen_info(ingredient_id: str, person_name: str):
    """Remove allergen information from ingredient"""
    try:
        ingredient_ref = db.collection("ingredients").document(ingredient_id)
        ingredient_doc = ingredient_ref.get()
        
        if ingredient_doc.exists:
            current_allergen_info = ingredient_doc.to_dict().get('allergen_info', {})
            if person_name in current_allergen_info:
                del current_allergen_info[person_name]
                ingredient_ref.update({'allergen_info': current_allergen_info})
                
    except Exception as e:
        print(f"Failed to remove ingredient allergen info: {e}")

# ----------------------------
# üîç Allergy Checking
# ----------------------------

def check_recipe_for_allergies(recipe_id: str, event_id: str) -> Dict[str, List[Dict]]:
    """Check if a recipe contains any allergens for the event"""
    try:
        # Get recipe
        recipe_doc = db.collection("recipes").document(recipe_id).get()
        if not recipe_doc.exists:
            return {}
        
        recipe = recipe_doc.to_dict()
        recipe_ingredient_ids = recipe.get('ingredient_ids', [])
        
        # Get event allergies
        allergies = get_event_allergies(event_id)
        
        # Check for conflicts
        conflicts = {}
        
        for allergy in allergies:
            person = allergy.get('person_name')
            allergen_ids = allergy.get('ingredient_ids', [])
            allergen_tags = allergy.get('tags', [])
            
            # Check ingredient matches
            matching_ingredients = set(recipe_ingredient_ids) & set(allergen_ids)
            
            # Check tag matches
            recipe_tags = recipe.get('tags', [])
            matching_tags = set(recipe_tags) & set(allergen_tags)
            
            if matching_ingredients or matching_tags:
                conflicts[person] = {
                    'ingredients': list(matching_ingredients),
                    'tags': list(matching_tags),
                    'allergies': allergy.get('allergies', [])
                }
        
        return conflicts
        
    except Exception as e:
        st.error(f"Failed to check allergies: {e}")
        return {}

def get_safe_recipes_for_event(event_id: str) -> List[Dict]:
    """Get all recipes that are safe for all attendees"""
    try:
        # Get all event allergies
        allergies = get_event_allergies(event_id)
        
        # Collect all allergen ingredients and tags
        allergen_ingredients = set()
        allergen_tags = set()
        
        for allergy in allergies:
            allergen_ingredients.update(allergy.get('ingredient_ids', []))
            allergen_tags.update(allergy.get('tags', []))
        
        # Get all recipes
        all_recipes = db.collection("recipes").stream()
        safe_recipes = []
        
        for doc in all_recipes:
            recipe = doc.to_dict()
            recipe['id'] = doc.id
            
            # Check if recipe is safe
            recipe_ingredients = set(recipe.get('ingredient_ids', []))
            recipe_tags = set(recipe.get('tags', []))
            
            if not (recipe_ingredients & allergen_ingredients) and not (recipe_tags & allergen_tags):
                safe_recipes.append(recipe)
        
        return safe_recipes
        
    except Exception as e:
        st.error(f"Failed to get safe recipes: {e}")
        return []

# ----------------------------
# üé® Allergy Management UI
# ----------------------------

#@require_login
def allergy_management_ui(user: dict):
    """Main allergy management interface"""
    st.title("üö® Allergy Management")
    
    # Check for active event
    active_event_id = get_active_event_id()
    if not active_event_id:
        st.warning("Please activate an event to manage allergies")
        return
    
    event = get_event_by_id(active_event_id)
    if not event:
        st.error("Active event not found")
        return
    
    st.info(f"Managing allergies for: **{event.get('name', 'Unknown Event')}**")
    
    tab1, tab2, tab3 = st.tabs(["View Allergies", "Add Allergy", "Check Recipes"])
    
    with tab1:
        _view_allergies_tab(active_event_id)
    
    with tab2:
        _add_allergy_tab(active_event_id, user)
    
    with tab3:
        _check_recipes_tab(active_event_id)

def _view_allergies_tab(event_id: str):
    """View and manage existing allergies"""
    st.subheader("üìã Current Allergies")
    
    allergies = get_event_allergies(event_id)
    
    if not allergies:
        st.info("No allergies recorded for this event")
        return
    
    st.markdown(f"### {len(allergies)} people with allergies")
    
    for allergy in allergies:
        with st.expander(f"üßë {allergy.get('person_name', 'Unknown')} - {len(allergy.get('allergies', []))} allergies"):
            # Person details
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("**Allergies:**")
                for a in allergy.get('allergies', []):
                    st.write(f"‚Ä¢ {a}")
                
                st.markdown("**Severity:** " + allergy.get('severity', 'Unknown'))
            
            with col2:
                st.markdown("**Notes:**")
                st.write(allergy.get('notes', 'No notes'))
            
            # Allergen details
            st.markdown("---")
            
            # Show flagged ingredients
            ingredient_ids = allergy.get('ingredient_ids', [])
            if ingredient_ids:
                st.markdown("**‚ö†Ô∏è Flagged Ingredients:**")
                
                # Get ingredient names
                for ing_id in ingredient_ids[:10]:  # Show first 10
                    try:
                        ing_doc = db.collection("ingredients").document(ing_id).get()
                        if ing_doc.exists:
                            ing_name = ing_doc.to_dict().get('name', 'Unknown')
                            st.write(f"‚Ä¢ {ing_name}")
                    except:
                        pass
                
                if len(ingredient_ids) > 10:
                    st.write(f"... and {len(ingredient_ids) - 10} more")
            
            # Show flagged tags
            tags = allergy.get('tags', [])
            if tags:
                st.markdown("**üè∑Ô∏è Flagged Tags:**")
                tag_html = " ".join([f"<span class='tag'>{tag}</span>" for tag in tags])
                st.markdown(tag_html, unsafe_allow_html=True)
            
            # Action buttons
            st.markdown("---")
            col1, col2 = st.columns(2)
            
            with col1:
                if st.button("Edit", key=f"edit_{allergy['id']}"):
                    st.session_state[f"editing_allergy_{allergy['id']}"] = True
                    st.rerun()
            
            with col2:
                if delete_button("Delete", key=f"delete_{allergy['id']}"):
                    if delete_allergy(event_id, allergy['id']):
                        st.success("Allergy deleted")
                        st.rerun()

def _add_allergy_tab(event_id: str, user: dict):
    """Add new allergy"""
    st.subheader("‚ûï Add New Allergy")
    
    with st.form("add_allergy_form"):
        # Person details
        col1, col2 = st.columns(2)
        
        with col1:
            person_name = st.text_input("Person's Name *", placeholder="e.g., John Smith")
            severity = st.selectbox("Severity *", ["Mild", "Moderate", "Severe", "Life-threatening"])
        
        with col2:
            allergies = st.text_area("Allergies (one per line) *", 
                                   placeholder="e.g.,\nPeanuts\nShellfish\nGluten",
                                   height=100)
        
        notes = st.text_area("Additional Notes", 
                           placeholder="e.g., Carries EpiPen, can tolerate small amounts of dairy")
        
        st.markdown("### üîç Flag Allergens")
        st.caption("Select ingredients and tags that should trigger allergy warnings")
        
        # Ingredient search
        st.markdown("**Search Ingredients to Flag:**")
        ingredient_search = st.text_input("Type ingredient names (comma-separated)", 
                                        placeholder="e.g., peanut, shrimp, wheat")
        
        # Tag selection
        st.markdown("**Select Tags to Flag:**")
        
        # Get common allergy-related tags
        common_allergy_tags = ["gluten-free", "dairy-free", "nut-free", "vegan", "vegetarian", 
                              "shellfish", "eggs", "soy", "wheat", "peanuts"]
        
        selected_tags = st.multiselect("Tags", common_allergy_tags)
        
        # Additional tags
        additional_tags = st.text_input("Additional tags (comma-separated)", 
                                      placeholder="e.g., sesame, tree nuts")
        
        submitted = st.form_submit_button("Add Allergy", type="primary")
        
        if submitted:
            if not person_name or not allergies:
                st.error("Please fill in all required fields")
            else:
                # Parse allergies
                allergy_list = [a.strip() for a in allergies.split('\n') if a.strip()]
                
                # Parse ingredients
                ingredient_ids = []
                if ingredient_search:
                    from ingredients import search_ingredients
                    
                    search_terms = [term.strip() for term in ingredient_search.split(',') if term.strip()]
                    for term in search_terms:
                        results = search_ingredients(term)
                        if results:
                            # Add the first match
                            ingredient_ids.append(results[0]['id'])
                
                # Combine tags
                all_tags = selected_tags.copy()
                if additional_tags:
                    all_tags.extend([t.strip() for t in additional_tags.split(',') if t.strip()])
                
                # Create allergy data
                allergy_data = {
                    'person_name': person_name,
                    'allergies': allergy_list,
                    'severity': severity,
                    'notes': notes,
                    'ingredient_ids': ingredient_ids,
                    'tags': all_tags,
                    'created_by': user['id']
                }
                
                if add_allergy_to_event(event_id, allergy_data):
                    st.success(f"‚úÖ Added allergy information for {person_name}")
                    st.rerun()

def _check_recipes_tab(event_id: str):
    """Check recipes for allergens"""
    st.subheader("üîç Check Recipes for Allergens")
    
    # Get event allergies
    allergies = get_event_allergies(event_id)
    
    if not allergies:
        st.info("No allergies recorded. Add allergies first to check recipes.")
        return
    
    # Show allergy summary
    st.markdown("### Active Allergies")
    allergy_summary = []
    for allergy in allergies:
        person = allergy.get('person_name')
        allergens = ", ".join(allergy.get('allergies', []))
        allergy_summary.append(f"**{person}:** {allergens}")
    
    st.write(" | ".join(allergy_summary))
    st.markdown("---")
    
    # Recipe checker
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üü¢ Show Safe Recipes", use_container_width=True):
            with st.spinner("Finding safe recipes..."):
                safe_recipes = get_safe_recipes_for_event(event_id)
                
                if safe_recipes:
                    st.success(f"Found {len(safe_recipes)} safe recipes!")
                    
                    for recipe in safe_recipes[:10]:  # Show first 10
                        st.write(f"‚úÖ {recipe.get('name', 'Unnamed')}")
                    
                    if len(safe_recipes) > 10:
                        st.write(f"... and {len(safe_recipes) - 10} more")
                else:
                    st.warning("No recipes found that are safe for all attendees")
    
    with col2:
        # Get event menu items
        try:
            menu_items = db.collection("menus").where("event_id", "==", event_id).stream()
            menu_list = [doc.to_dict() | {"id": doc.id} for doc in menu_items]
            
            if menu_list:
                if st.button("üîç Check Current Menu", use_container_width=True):
                    st.markdown("### Menu Allergy Check")
                    
                    conflicts_found = False
                    
                    for menu_item in menu_list:
                        # Check if menu item has associated recipe
                        recipe_id = menu_item.get('recipe_id')
                        if recipe_id:
                            conflicts = check_recipe_for_allergies(recipe_id, event_id)
                            
                            if conflicts:
                                conflicts_found = True
                                st.error(f"‚ö†Ô∏è **{menu_item.get('name', 'Unknown')}** contains allergens!")
                                
                                for person, details in conflicts.items():
                                    allergen_list = ", ".join(details['allergies'])
                                    st.write(f"   ‚Üí Unsafe for {person} ({allergen_list})")
                            else:
                                st.success(f"‚úÖ {menu_item.get('name', 'Unknown')} - Safe")
                        else:
                            st.warning(f"‚ö†Ô∏è {menu_item.get('name', 'Unknown')} - No recipe linked")
                    
                    if not conflicts_found:
                        st.success("üéâ All menu items are safe for all attendees!")
            else:
                st.info("No menu items found for this event")
                
        except Exception as e:
            st.error(f"Failed to check menu: {e}")

# ----------------------------
# üè∑Ô∏è Allergy Warning Component
# ----------------------------

def render_allergy_warning(recipe_id: str, event_id: str = None):
    """Render allergy warning for a recipe"""
    if not event_id:
        event_id = get_active_event_id()
    
    if not event_id:
        return
    
    conflicts = check_recipe_for_allergies(recipe_id, event_id)
    
    if conflicts:
        warning_msg = "‚ö†Ô∏è **ALLERGY WARNING:** "
        warnings = []
        
        for person, details in conflicts.items():
            allergens = ", ".join(details['allergies'])
            warnings.append(f"{person} ({allergens})")
        
        warning_msg += " | ".join(warnings)
        st.error(warning_msg)

# ----------------------------
# üìä Allergy Analytics
# ----------------------------

def get_allergy_analytics(event_id: str = None) -> Dict:
    """Get analytics about allergies"""
    try:
        if event_id:
            # Event-specific analytics
            allergies = get_event_allergies(event_id)
            
            # Count unique allergens
            all_allergens = []
            for allergy in allergies:
                all_allergens.extend(allergy.get('allergies', []))
            
            allergen_counts = {}
            for allergen in all_allergens:
                allergen_counts[allergen] = allergen_counts.get(allergen, 0) + 1
            
            return {
                'total_people': len(allergies),
                'allergen_counts': allergen_counts,
                'severity_breakdown': _get_severity_breakdown(allergies)
            }
        else:
            # Global analytics across all events
            # This would aggregate data across all events
            return {}
            
    except Exception as e:
        st.error(f"Failed to get analytics: {e}")
        return {}

def _get_severity_breakdown(allergies: List[Dict]) -> Dict[str, int]:
    """Get breakdown by severity"""
    severity_counts = {
        "Mild": 0,
        "Moderate": 0,
        "Severe": 0,
        "Life-threatening": 0
    }
    
    for allergy in allergies:
        severity = allergy.get('severity', 'Unknown')
        if severity in severity_counts:
            severity_counts[severity] += 1
    
    return severity_counts


=== app.py ===
from upload import upload_ui_mobile, upload_ui_desktop
import streamlit as st

# ‚úÖ Correct Streamlit config placed immediately after import
st.set_page_config(
    page_title="Mountain Medicine Catering",
    layout="wide",
    initial_sidebar_state="collapsed"
)

st.markdown("""
<style>
div[data-testid='stRadio'] > label {
    display: none;
}
</style>
""", unsafe_allow_html=True)

import streamlit.components.v1 as components

components.html("""
<script>
  const expiry = parseInt(localStorage.getItem('mm_token_expiry') || '0', 10);
  if (expiry && Date.now() > expiry) {
    localStorage.removeItem('mm_token');
    localStorage.removeItem('mm_token_expiry');
    localStorage.removeItem('mm_remember');
    window.location.href = '/login';
  }
  const token = localStorage.getItem('mm_token') || "";
  let device = localStorage.getItem('mm_device');
  if (!device) {
    const ua = navigator.userAgent.toLowerCase();
    device = /iphone|ipad|android/.test(ua) ? "mobile" : "desktop";
    localStorage.setItem('mm_device', device);
  }
  const handled = localStorage.getItem('mm_token_handled') === 'true';
  const query = `?token=${token}&device=${device}`;
  if (!window.location.search.includes('token=') && token && !handled) {
    localStorage.setItem('mm_token_handled', 'true');
    window.location.href = window.location.pathname + query;
  }
  const refreshSession = () => {
    const token = localStorage.getItem('mm_token') || "";
    const device = localStorage.getItem('mm_device') || 'desktop';
    const handled = localStorage.getItem('mm_token_handled') === 'true';
    if (!window.location.search.includes('token=') && token && !handled) {
      localStorage.setItem('mm_token_handled', 'true');
      window.location.href = window.location.pathname + `?token=${token}&device=${device}`;
    }
  };

  window.addEventListener('pagehide', () => {
    localStorage.setItem('mm_token_handled', 'false');
  });

  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') {
      localStorage.setItem('mm_token_handled', 'false');
    } else if (document.visibilityState === 'visible') {
      refreshSession();
    }
  });

  window.addEventListener('pageshow', refreshSession);
  window.addEventListener('focus', refreshSession);
</script>
""", height=0)

from auth import get_user, get_user_role
from user_session_initializer import enrich_session_from_token
from dashboard import render_dashboard
from mobile_layout import mobile_layout
from mobile_components import mobile_safe_columns
from notifications import notifications_sidebar
from datetime import datetime
from utils import format_date, get_active_event, session_get, log_user_action
from layout import apply_theme, render_top_navbar, render_enhanced_sidebar, render_leave_event_button
from ui_components import show_event_mode_banner, inject_layout_fixes
from landing import show as show_landing
from events import enhanced_event_ui, get_all_events
from post_event import post_event_ui
from file_storage import file_manager_ui, show_file_analytics
from receipts import receipt_upload_ui
from pdf_export import pdf_export_ui
from event_planning_dashboard import event_planning_dashboard_ui
from event_modifications import event_modifications_ui
from bulk_suggestions import bulk_suggestions_ui
from audit import audit_log_ui
from roles import role_admin_ui as admin_panel_ui
from ingredients import ingredient_catalogue_ui
from allergies import allergy_management_ui
from packing import packing_ui
from ai_chat import ai_chat_ui
from recipes import recipes_page
from admin_utilities import admin_utilities_ui
from historical_menus import historical_menus_ui

def enforce_session_expiry():
    expiry_ts = st.session_state.get("token_expiry")
    if expiry_ts and datetime.utcnow().timestamp() > expiry_ts:
        st.session_state.pop("user", None)
        st.session_state.pop("token_expiry", None)
        import streamlit.components.v1 as components
        components.html("<script>localStorage.removeItem('mm_token');localStorage.removeItem('mm_token_expiry');localStorage.removeItem('mm_remember');window.location.href='/login';</script>", height=0)
        st.stop()

PUBLIC_MODE = False

TABS = {
    "Dashboard": "dashboard",
    "Events": "events",
    "Recipes": "recipes",
    "Ingredients": "ingredients",
    "Allergies": "allergies",
    "Historical Menus": "historical_menus",
    "Upload": "files",
    "Receipts": "receipts",
    "Admin Panel": "admin",
    "Assistant": "assistant"
}

def initialize_event_mode_state():
    user = session_get("user")
    if not user:
        return

    user_id = user.get("id")
    if not user_id:
        return

    session_key = f"initialized_{user_id}"
    if session_key not in st.session_state:
        st.session_state[session_key] = True

        if "active_event_id" not in st.session_state:
            st.session_state["active_event_id"] = None
            st.session_state["active_event"] = None

        try:
            from firebase_init import db, firestore
            user_doc = db.collection("users").document(user_id).get()
            if user_doc.exists:
                user_data = user_doc.to_dict()
                last_event = user_data.get("last_active_event")
                if last_event:
                    st.session_state["recent_event_id"] = last_event
        except Exception:
            pass

def handle_auth_routing():
    import streamlit.components.v1 as components
    query_params = st.query_params

    user_logged_in = "user" in st.session_state

    if "token" not in query_params and not user_logged_in:
        components.html('''
        <script>
        const token = localStorage.getItem("mm_token") || "";
        const device = localStorage.getItem("mm_device") || "desktop";
        if (token) {
            const query = `?token=${token}&device=${device}`;
            window.location.href = window.location.pathname + query;
        } else {
            window.location.href = "/login";
        }
        </script>
        ''', height=0)
        st.stop()

    if query_params.get("logout") == ["true"]:
        log_user_action("logout")
        keys_to_preserve = ["top_nav"]
        preserved = {k: st.session_state[k] for k in keys_to_preserve if k in st.session_state}
        st.session_state.clear()
        st.session_state.update(preserved)
        st.toast("You have been logged out")
        st.switch_page("/login")

    elif "token" in query_params and "user" not in st.session_state:
        token = query_params.get("token")
        if isinstance(token, list):
            token = token[0]
        if not isinstance(token, str) or "." not in token:
            st.error("Malformed or missing token.")
            return
        device = query_params.get("device", ["desktop"])[0]
        st.session_state["device_type"] = device
        st.session_state["mobile_mode"] = (device == "mobile")

        user = enrich_session_from_token(token)
        if user:
            st.session_state["user"] = user
            st.toast(f"Welcome {user.get('name', 'back')} üëã")
            log_user_action(user.get("id", "unknown"), user.get("role", "viewer"), "login")
            st.query_params.clear()
        else:
            st.error("Login failed. Invalid or expired token.")
            return

    elif not get_user():
        st.title("üîê Login Required")
        st.warning("Please log in to continue.")
        return

def validate_tab_state(visible_tabs):
    if "top_nav" not in st.session_state or st.session_state["top_nav"] not in visible_tabs:
        st.session_state["top_nav"] = visible_tabs[0] if visible_tabs else "Dashboard"

def main():
    enforce_session_expiry()
    handle_auth_routing()
    if not get_user():
        st.error("üö´ Login failed or not completed. Please refresh or reauthenticate.")
        return

    from firebase_init import db, firestore

    default_state = {
        "top_nav": "Dashboard",
        "next_nav": None,
        "active_event": None,
        "active_event_id": None,
        "recent_event_id": None,
        "editing_event_id": None,
        "editing_menu_event_id": None,
        "viewing_menu_event_id": None,
        "show_menu_form": False,
        "current_file_data": b"",
        "mobile_detected": st.session_state.get("mobile_mode", False),
    }

    for key, default in default_state.items():
        if key not in st.session_state:
            st.session_state[key] = default

    apply_theme()
    inject_layout_fixes()
    user = get_user()

    if PUBLIC_MODE and not user:
        show_landing()
        return

    initialize_event_mode_state()

    visible_tabs = list(TABS.keys())
    role = user.get("role", "viewer") if user else "viewer"
    if role != "admin":
        for admin_tab in ["Admin Panel", "Suggestions", "Bulk Suggestions", "Audit Logs", "PDF Export"]:
            if admin_tab in visible_tabs:
                visible_tabs.remove(admin_tab)

    next_nav = st.session_state.pop("next_nav", None)
    if next_nav in visible_tabs:
        st.session_state["top_nav"] = next_nav

    validate_tab_state(visible_tabs)

    selected_tab = render_top_navbar(visible_tabs)

    if not selected_tab:
        selected_tab = st.session_state.get("top_nav", "Dashboard")

    if selected_tab not in visible_tabs:
        st.warning(f"‚ö†Ô∏è Invalid tab: {selected_tab}. Resetting.")
        st.session_state["top_nav"] = visible_tabs[0]
        st.rerun()

    try:
        if selected_tab == "Dashboard":
            render_dashboard(user)
        elif selected_tab == "Events":
            render_leave_event_button("main")
            enhanced_event_ui(user)
        elif selected_tab == "Recipes":
            recipes_page()
        elif selected_tab == "Ingredients":
            ingredient_catalogue_ui(user)
        elif selected_tab == "Allergies":
            allergy_management_ui(user)
        elif selected_tab == "Historical Menus":
            historical_menus_ui()
        elif selected_tab == "Upload":
            upload_tab, analytics_tab = st.tabs(["üìÑ Upload Files", "üìä File Analytics"])
            with upload_tab:
                if st.session_state.get("mobile_mode"):
                    upload_ui_mobile()
                else:
                    upload_ui_desktop()
            with analytics_tab:
                show_file_analytics()
        elif selected_tab == "Receipts":
            receipt_upload_ui(user)
        elif selected_tab == "Admin Panel":
            render_admin_panel(user)
        elif selected_tab == "Assistant":
            ai_chat_ui()
        else:
            st.warning("‚ö†Ô∏è Unknown tab selected.")
    except Exception as e:
        st.error(f"üö® Failed to render '{selected_tab}' tab: {e}")

def render_admin_panel(user):
    role = get_user_role()
    if role != "admin":
        st.warning("Access denied. Admins only.")
        return
    admin_panel_ui()

if __name__ == "__main__":
    main()


=== assistant.py ===
# pages/assistant.py
import streamlit as st
from ai_chat import ai_chat_ui

def show():
    st.title("Assistant")
    ai_chat_ui()


=== audit.py ===
import streamlit as st
from firebase_admin import firestore
from utils import format_date
from firebase_admin import firestore

db = firestore.client()

# ----------------------------
# üìú Fetch Recent Logs
# ----------------------------
def get_audit_logs(limit=50):
    docs = db.collection("audit_logs").order_by("timestamp", direction=firestore.Query.DESCENDING).limit(limit).stream()
    return [doc.to_dict() | {"id": doc.id} for doc in docs]

# ----------------------------
# üïµÔ∏è Audit Log UI
# ----------------------------
def audit_log_ui(user=None):
    st.subheader("üïµÔ∏è Audit Logs")

    logs = get_audit_logs()
    if not logs:
        st.info("No logs found.")
        return

    for log in logs:
        ts = format_date(log.get("timestamp"))
        st.markdown(f"**{ts}** ‚Äî {log.get('user', {}).get('name', 'Unknown')} ‚Üí `{log.get('action')}`")
        st.caption(f"Target: `{log.get('target_type')}` / ID: `{log.get('target_id')}`")


=== auth.py ===
# ‚úÖ Final Auth Module ‚Äî Safe, Debuggable, Circular-Free
import streamlit as st
from firebase_admin import auth as admin_auth
from firebase_init import db
from utils import session_get, session_set
from datetime import datetime

# ----------------------------
# üîê Session Helpers
# ----------------------------

def is_logged_in():
    return "user" in st.session_state

def get_user():
    print("üîé get_user called; session keys:", list(st.session_state.keys()))
    return st.session_state.get("user")

def get_user_id(user=None):
    if user is None:
        user = st.session_state.get("user", {})
    return user.get("id") if user else None

def get_user_role(user=None):
    if user is None:
        user = st.session_state.get("user", {})
    return user.get("role", "viewer")

def get_current_user():
    return get_user()

# ----------------------------
# üö´ Access Control Decorators
# ----------------------------

def require_login():
    if not is_logged_in():
        st.warning("You must be logged in to access this page.")
        st.stop()

def require_role(required_role):
    def decorator(func):
        def wrapper(*args, **kwargs):
            user = get_user()
            if not user:
                st.warning("You must be logged in.")
                st.stop()
            role = user.get("role", "viewer")
            hierarchy = ["viewer", "user", "manager", "admin"]
            if hierarchy.index(role) < hierarchy.index(required_role):
                st.error(f"Access denied. Requires role: {required_role}")
                st.stop()
            return func(*args, **kwargs)
        return wrapper
    return decorator

# ----------------------------
# üîë Firebase Web Auth Handler
# ----------------------------

def authenticate_user(token: str):
    import firebase_admin.auth as auth
    import logging

    if not token or not isinstance(token, str):
        logging.error(f"Invalid token input: {token} (type: {type(token)})")
        raise ValueError("Token must be a non-empty string")

    try:
        decoded = auth.verify_id_token(token)
        logging.info(f"Token decoded successfully: {decoded}")
        return decoded
    except Exception as e:
        logging.exception(f"Failed to verify token: {e}")
        raise

# ----------------------------
# ‚úÖ ENRICH AND REGISTER SESSION USER
# ----------------------------

def enrich_session_from_token(token: str) -> dict | None:
    try:
        decoded_token = admin_auth.verify_id_token(token)
        user_id = decoded_token["uid"]
        email = decoded_token.get("email", "").lower()
        email_verified = decoded_token.get("email_verified", False)

        st.session_state["_auth_debug"] = {
            "decoded_uid": user_id,
            "email": email,
            "verified": email_verified,
            "timestamp": str(datetime.utcnow())
        }

        doc_ref = db.collection("users").document(user_id)
        doc = doc_ref.get()

        if doc.exists:
            user_data = doc.to_dict()
            st.session_state["_auth_debug"]["found_in_firestore"] = True
            st.session_state["_auth_debug"]["role"] = user_data.get("role", "none")
            exp = decoded_token.get("exp")
            if exp:
                st.session_state["token_expiry"] = exp
            return user_data

        # Not in DB ‚Üí create new user
        admin_email = st.secrets.get("admin", {}).get("email", "").lower()
        is_admin = email == admin_email
        user_data = {
            "id": user_id,
            "email": email,
            "created_at": datetime.utcnow(),
            "role": "admin" if is_admin else "viewer",
            "active": True,
            "email_verified": email_verified
        }
        doc_ref.set(user_data)

        st.session_state["_auth_debug"]["created_new_user"] = True
        st.session_state["_auth_debug"]["assigned_role"] = user_data["role"]
        exp = decoded_token.get("exp")
        if exp:
            st.session_state["token_expiry"] = exp
        return user_data

    except Exception as e:
        st.session_state["_auth_debug"] = {
            "error": str(e),
            "timestamp": str(datetime.utcnow())
        }
        print(f"[Auth] Token enrichment failed: {e}")
        return None

# ----------------------------
# üîÅ Firebase User Sync Tool
# ----------------------------

def sync_firebase_users():
    synced = 0
    page = admin_auth.list_users()
    while page:
        for user in page.users:
            doc_ref = db.collection("users").document(user.uid)
            if not doc_ref.get().exists:
                doc_ref.set({
                    "id": user.uid,
                    "email": user.email,
                    "name": user.display_name or "",
                    "role": "viewer",
                    "email_verified": user.email_verified,
                    "active": True,
                    "created_at": user.user_metadata.creation_timestamp,
                })
                synced += 1
        page = page.get_next_page()
    return synced

# ----------------------------
# ‚ùå User Deletion
# ----------------------------

def delete_firebase_user(uid):
    try:
        admin_auth.delete_user(uid)
        db.collection("users").document(uid).delete()
        return True
    except Exception as e:
        st.error(f"Failed to delete user: {e}")
        return False


=== bulk_suggestions.py ===
# bulk_suggestions.py
import streamlit as st
from auth import require_role

@require_role("admin")
def bulk_suggestions_ui():
    st.title("üß† Bulk Suggestions")
    st.info("This section is under construction.")


=== dashboard.py ===
import streamlit as st
from event_mode import get_event_context
from utils import format_date
from mobile_layout import mobile_card, mobile_layout

def render_dashboard(user=None):
    st.title("üìä Dashboard")

    if st.session_state.get("mobile_mode"):
        mobile_layout.render_mobile_dashboard(user, get_event_context())
        return

    event = get_event_context()

    if event:
        mobile_card("üóïÔ∏è Active Event", f"**{event.get('name', 'Unnamed')}**")
        st.markdown(f"üìç Location: *{event.get('location', 'Unknown')}*")
        st.markdown(f"üóìÔ∏è Date: *{format_date(event.get('start_datetime'))} ‚Üí {format_date(event.get('end_datetime'))}*")

        st.markdown("### üìà Quick Stats")
        col1, col2, col3 = st.columns(3)
        col1.metric("üë• Guests", event.get("guest_count", "-"))
        col2.metric("ü¶ë Staff", event.get("staff_count", "-"))
        col3.metric("üçΩÔ∏è Menu Items", len(event.get("menu", [])))

        st.markdown("### ‚úÖ Today's Checklist")
        st.checkbox("Prep station setup complete")
        st.checkbox("Reviewed schedule with staff")
        st.checkbox("Checked inventory and supplies")
        st.checkbox("Load equipment into transport")
        st.checkbox("Set up dishwashing station")

    else:
        st.info("No active event selected.")
        st.markdown("Navigate to the **Events** tab to activate or create one.")


=== event_file.py ===
# event_file.py

from firebase_init import db, firestore
from datetime import datetime, timedelta
from utils import generate_id

# ----------------------------
# üì¶ Default Event File Schema
# ----------------------------

def get_default_event_file():
    return {
        "menu": [],
        "notes": "",
        "last_updated": datetime.utcnow(),
        "updated_by": None
    }

# ----------------------------
# üóìÔ∏è Generate Menu Template
# ----------------------------

def generate_menu_template(start_date: str, end_date: str) -> list[dict]:
    """Create blank breakfast/lunch/dinner entries for each event day."""
    try:
        start = datetime.fromisoformat(start_date).date()
        end = datetime.fromisoformat(end_date).date()
    except Exception:
        return []

    menu = []
    current = start
    while current <= end:
        day_str = current.isoformat()
        for meal in ["breakfast", "lunch", "dinner"]:
            menu.append({
                "day": day_str,
                "meal": meal,
                "recipe": "",
                "notes": "",
                "allergens": [],
                "tags": []
            })
        current += timedelta(days=1)
    return menu

# ----------------------------
# üì• Create or Overwrite Event File
# ----------------------------

def initialize_event_file(event_id: str, user_id: str):
    """Create a new event_file doc if it doesn't exist."""
    ref = db.collection("events").document(event_id).collection("meta").document("event_file")
    if not ref.get().exists:
        ref.set(get_default_event_file() | {
            "updated_by": user_id
        })

# ----------------------------
# üîÑ Update Specific Section
# ----------------------------

def update_event_file_field(event_id: str, field: str, value, user_id: str):
    """Update a specific field in the event file."""
    ref = db.collection("events").document(event_id).collection("meta").document("event_file")
    ref.set({
        field: value,
        "last_updated": datetime.utcnow(),
        "updated_by": user_id
    }, merge=True)

# ----------------------------
# üì§ Full Overwrite (Admin only)
# ----------------------------

def overwrite_event_file(event_id: str, new_data: dict, user_id: str):
    """Replace entire event_file contents (dangerous)."""
    ref = db.collection("events").document(event_id).collection("meta").document("event_file")
    new_data["last_updated"] = datetime.utcnow()
    new_data["updated_by"] = user_id
    ref.set(new_data)

# ----------------------------
# üìÑ Get Event File
# ----------------------------

def get_event_file(event_id: str) -> dict:
    """Returns full event_file dict, or default if not found."""
    ref = db.collection("events").document(event_id).collection("meta").document("event_file")
    doc = ref.get()
    return doc.to_dict() if doc.exists else get_default_event_file()


=== event_mode.py ===
# event_mode.py

from utils import get_active_event_id, get_active_event

# -------------------------------
# ‚úÖ Is Event Mode Active?
# -------------------------------

def is_event_mode_active() -> bool:
    """Returns True if Event Mode is active (i.e., an event is selected)."""
    return get_active_event_id() is not None

# -------------------------------
# üîí Should This Item Be Locked?
# -------------------------------

def is_locked(item_event_id: str) -> bool:
    """
    Returns True if the item is locked due to being outside the active event.
    If Event Mode is off, all items are editable.
    """
    active_event_id = get_active_event_id()
    if not active_event_id:
        return False
    return item_event_id != active_event_id

# -------------------------------
# üß† Get the Scoped Event ID
# -------------------------------

def get_scoped_event_id(default=None) -> str | None:
    """Returns the active event ID, or a provided default fallback."""
    return get_active_event_id() or default

# -------------------------------
# üìã Current Event Info (If Any)
# -------------------------------

def get_event_context() -> dict | None:
    """Returns the full active event document, or None if not set."""
    return get_active_event()


=== event_modifications.py ===
# event_modifications.py

import streamlit as st
from firebase_admin import firestore
from auth import require_role
from utils import format_date
from notifications import send_notification
from datetime import datetime

db = firestore.client()

# ----------------------------
# üîß Suggestion Moderation UI
# ----------------------------

@require_role("manager")
def event_modifications_ui(user: dict) -> None:
    """UI to review and moderate pending user/AI suggestions."""
    st.title("üìù Review Suggestions")
    st.caption("Approve or reject pending edits submitted by users or the AI assistant.")

    suggestions_ref = db.collection("suggestions")
    query = suggestions_ref.where("status", "==", "pending")

    active_event_id = st.session_state.get("active_event")
    if active_event_id:
        query = query.where("event_id", "==", active_event_id)
        st.info(f"Filtering by active event: `{active_event_id}`")

    results = query.stream()
    suggestions = [s.to_dict() for s in results]

    if not suggestions:
        st.success("‚úÖ No pending suggestions to review.")
        return

    for s in suggestions:
        with st.expander(f"üóÇÔ∏è {s.get('type', 'Unknown Type')} | Field: {s.get('field', 'Unknown')}"):
            st.markdown(f"**Submitted by:** {s.get('created_by', 'unknown')} | **Time:** {format_date(s.get('created_at'))}")
            st.markdown(f"**Target ID:** `{s.get('target_id')}`")
            st.markdown(f"**Original Value:**\n```\n{s.get('original_value')}```")

            new_val = st.text_area("Suggested Value:", value=s.get("suggested_value"), key=s["id"])
            col1, col2 = st.columns([1, 1])

            with col1:
                if st.button("‚úÖ Approve", key=f"approve_{s['id']}"):
                    _apply_suggestion(s, new_val, user)
                    st.success("Approved and applied.")

            with col2:
                if st.button("‚ùå Reject", key=f"reject_{s['id']}"):
                    _reject_suggestion(s, user)
                    st.warning("Rejected.")

# ----------------------------
# ‚úÖ Apply Suggestion Logic
# ----------------------------

def _apply_suggestion(s: dict, new_value: str, reviewer: dict) -> None:
    target_type = s.get("type")
    target_id = s.get("target_id")
    field = s.get("field")

    target_ref = None
    if target_type == "event_field":
        target_ref = db.collection("events").document(target_id)
    elif target_type == "menu_item":
        target_ref = db.collection("menus").document(target_id)
    elif target_type == "file_tag":
        target_ref = db.collection("files").document(target_id)
    elif target_type == "recipe_note":
        target_ref = db.collection("recipes").document(target_id)

    if target_ref:
        try:
            target_ref.update({field: new_value})
        except Exception as e:
            st.error(f"‚ö†Ô∏è Failed to update {target_type}: {e}")

    db.collection("suggestions").document(s["id"]).update({
        "status": "approved",
        "reviewed_by": reviewer["id"],
        "reviewed_at": datetime.utcnow()
    })

    send_notification(f"Suggestion approved and applied to {target_type}: {target_id}", role="admin")

# ----------------------------
# ‚ùå Reject Suggestion Logic
# ----------------------------

def _reject_suggestion(s: dict, reviewer: dict) -> None:
    db.collection("suggestions").document(s["id"]).update({
        "status": "rejected",
        "reviewed_by": reviewer["id"],
        "reviewed_at": datetime.utcnow()
    })

    send_notification(f"Suggestion rejected for {s.get('type')} {s.get('target_id')}", role="admin")


=== event_planning_dashboard.py ===
import streamlit as st
from mobile_helpers import safe_columns, safe_file_uploader
from firebase_init import db
from utils import session_get, generate_id, format_date, delete_button
from menu_viewer import menu_viewer_ui
from file_storage import save_uploaded_file
from datetime import datetime
from layout import render_event_toolbar
from auth import get_user_id

# ----------------------------
# üßæ Load Event Data
# ----------------------------
def get_event_data(event_id):
    try:
        doc = db.collection("events").document(event_id).get()
        return doc.to_dict() if doc.exists else {}
    except Exception as e:
        st.error(f"‚ùå Failed to load event: {e}")
        return {}

# ----------------------------
# üíæ Save Event Data
# ----------------------------
def save_event_data(event_id, data):
    try:
        db.collection("events").document(event_id).update(data)
        return True
    except Exception as e:
        st.error(f"‚ùå Failed to save event: {e}")
        return False

# ----------------------------
# üìã Event Planning Dashboard - FIXED
# ----------------------------
def event_planning_dashboard_ui(event_id):
    # Get user from Firebase session first
    user = st.session_state.get("firebase_user")
    if not user:
        # Fallback to legacy session
        user = session_get("user")
    
    if not user:
        st.warning("Login required")
        return
    
    # Ensure admin role for mistermcfarland@gmail.com
    if user.get("email") == "mistermcfarland@gmail.com" and user.get("role") != "admin":
        user["role"] = "admin"
        st.session_state["firebase_user"] = user

    event = get_event_data(event_id)
    if not event:
        st.error("Event not found")
        return

    st.markdown("<div style='margin-top: 3.5rem'></div>", unsafe_allow_html=True)
    render_event_toolbar(event_id, context="editing")

    st.markdown("# üìù Event Planning Dashboard")

    if st.button("‚¨ÖÔ∏è Back", key="epd_back_btn"):
        st.session_state["show_event_dashboard"] = False
        st.session_state.pop("editing_event_id", None)
        st.rerun()

    st.info(f"Editing: **{event.get('name', 'Unnamed Event')}**")

    # Show basic event info with status
    start_fmt = format_date(event.get("start_date"))
    end_fmt = format_date(event.get("end_date"))
    status = event.get("status", "planning").title()
    st.write(f"**Dates:** {start_fmt} ‚Üí {end_fmt} | Status: {status}")

    if status.lower() != "complete":
        if st.button("Mark Event Complete", key="complete_event"):
            from events import complete_event_and_end_sessions
            if complete_event_and_end_sessions(event_id):
                st.rerun()

    # ‚úÖ FIXED: Use session state to preserve form values between reruns
    form_key = f"event_form_{event_id}"
    
    # Initialize form state if not exists
    if f"{form_key}_initialized" not in st.session_state:
        st.session_state[f"{form_key}_name"] = event.get("name", "")
        st.session_state[f"{form_key}_description"] = event.get("description", "")
        st.session_state[f"{form_key}_location"] = event.get("location", "")
        st.session_state[f"{form_key}_instructions"] = event.get("instructions", "")
        st.session_state[f"{form_key}_restrictions"] = event.get("dietary_restrictions", "")
        st.session_state[f"{form_key}_allergies"] = event.get("food_allergies", "")
        st.session_state[f"{form_key}_notes"] = event.get("internal_notes", "")
        st.session_state[f"{form_key}_initialized"] = True

    # Main event details form - FIXED
    with st.form("event_form", clear_on_submit=False):  # ‚úÖ Don't clear on submit
        st.markdown("## üìã Event Details")
        
        col1, col2 = safe_columns(2)
        with col1:
            # ‚úÖ FIXED: Use session state values, not database values
            name = st.text_input(
                "Event Name", 
                value=st.session_state.get(f"{form_key}_name", ""),
                key=f"{form_key}_name_input"
            )
            description = st.text_area(
                "Description", 
                value=st.session_state.get(f"{form_key}_description", ""),
                key=f"{form_key}_description_input"
            )
            location = st.text_input(
                "Location", 
                value=st.session_state.get(f"{form_key}_location", ""),
                key=f"{form_key}_location_input"
            )
        
        with col2:
            # ‚úÖ FIXED: Better date handling with error catching
            try:
                start_default = datetime.strptime(event.get("start_date", "2025-01-01"), "%Y-%m-%d").date()
            except (ValueError, TypeError):
                start_default = datetime.now().date()
                
            try:
                end_default = datetime.strptime(event.get("end_date", "2025-01-02"), "%Y-%m-%d").date()
            except (ValueError, TypeError):
                end_default = datetime.now().date()
                
            start = st.date_input("Start Date", value=start_default)
            end = st.date_input("End Date", value=end_default)
            
            # ‚úÖ FIXED: Validate dates
            if start > end:
                st.error("‚ö†Ô∏è Start date must be before end date")
                
            headcount = st.number_input("üë• Expected Guests", min_value=0, value=event.get("guest_count", 0))
            staff_count = st.number_input("üßë‚Äçüç≥ Staff Count", min_value=0, value=event.get("staff_count", 0))

        # Additional details - FIXED
        st.markdown("## üìù Additional Information")
        col1, col2 = safe_columns(2)
        
        with col1:
            instructions = st.text_area(
                "üõ†Ô∏è Special Instructions", 
                value=st.session_state.get(f"{form_key}_instructions", ""),
                key=f"{form_key}_instructions_input"
            )
            restrictions = st.text_area(
                "ü•ó Dietary Restrictions", 
                value=st.session_state.get(f"{form_key}_restrictions", ""),
                key=f"{form_key}_restrictions_input"
            )
        
        with col2:
            allergies = st.text_area(
                "‚ö†Ô∏è Food Allergies", 
                value=st.session_state.get(f"{form_key}_allergies", ""),
                key=f"{form_key}_allergies_input"
            )
            notes = st.text_area(
                "üìå Internal Notes", 
                value=st.session_state.get(f"{form_key}_notes", ""),
                key=f"{form_key}_notes_input"
            )

        # ‚úÖ FIXED: Form submission with proper validation
        if st.form_submit_button("üíæ Save Event Details", type="primary"):
            if not name or not location:
                st.error("‚ùå Please fill in required fields: Name and Location")
            elif start > end:
                st.error("‚ùå Start date must be before end date")
            else:
                # Update session state with current values
                st.session_state[f"{form_key}_name"] = name
                st.session_state[f"{form_key}_description"] = description
                st.session_state[f"{form_key}_location"] = location
                st.session_state[f"{form_key}_instructions"] = instructions
                st.session_state[f"{form_key}_restrictions"] = restrictions
                st.session_state[f"{form_key}_allergies"] = allergies
                st.session_state[f"{form_key}_notes"] = notes
                
                data = {
                    "name": name,
                    "description": description,
                    "location": location,
                    "start_date": str(start),
                    "end_date": str(end),
                    "instructions": instructions,
                    "dietary_restrictions": restrictions,
                    "food_allergies": allergies,
                    "guest_count": headcount,
                    "staff_count": staff_count,
                    "internal_notes": notes,
                    "updated_at": datetime.utcnow()
                }
                
                if save_event_data(event_id, data):
                    st.success("‚úÖ Event details updated successfully!")
                    # Reset form state to show updated values
                    st.session_state[f"{form_key}_initialized"] = False

    # Separate sections for different components
    st.markdown("---")
    
    # Menu Planning Section - FIXED
    with st.expander("üçΩÔ∏è Menu Planning", expanded=True):
        try:
            # Nested expander for current menu
            with st.expander("üçΩÔ∏è Current Menu", expanded=True):
                menu_viewer_ui(event_id=event_id, key_prefix=f"{event_id}_", show_headers=False)
        except Exception as e:
            st.error(f"Could not load menu editor: {e}")
            st.info("You can manage menus from the Recipes tab.")

    # Shopping List Section - FIXED
    with st.expander("üõí Shopping List", expanded=False):
        _render_shopping_list_editor(event_id)

    # Equipment List Section - FIXED
    with st.expander("üéí Equipment List", expanded=False):
        _render_equipment_list_editor(event_id)

    # Tasks Section - FIXED
    with st.expander("‚úÖ Tasks & Checklist", expanded=False):
        _render_task_list_editor(event_id)

    # Allergies Section - FIXED
    with st.expander("üö® Allergies & Dietary Restrictions", expanded=False):
        _render_allergies_section(event_id, user)

    # File Uploads Section - FIXED
    with st.expander("üìé Event Files", expanded=False):
        _render_file_upload_section(event_id, user)

    # AI Suggestions Section - FIXED
    if st.checkbox("ü§ñ Show AI Assistant Suggestions"):
        _render_ai_suggestions(event_id)

        # ‚úÖ Show menu form if requested
        if st.session_state.get("show_menu_form"):
            _render_quick_menu_form(event_id, user)

# ----------------------------
# ‚ûï Quick Menu Form - NEW
# ----------------------------
def _render_quick_menu_form(event_id: str, user: dict):
    """Quick menu item creation form"""
    st.markdown("### ‚ûï Add Menu Item")
    
    with st.form("quick_menu_form"):
        col1, col2 = safe_columns(2)
        
        with col1:
            name = st.text_input("Menu Item Name *")
            category = st.selectbox("Category", ["Appetizer", "Main Course", "Side Dish", "Dessert", "Beverage"])
        
        with col2:
            description = st.text_area("Description")
            ingredients = st.text_area("Ingredients")
        
        col1, col2 = safe_columns(2)
        with col1:
            if st.form_submit_button("Add Menu Item", type="primary"):
                if not name:
                    st.error("Please provide a menu item name")
                else:
                    try:
                        menu_id = generate_id("menu")
                        menu_data = {
                            "id": menu_id,
                            "name": name,
                            "category": category,
                            "description": description,
                            "ingredients": ingredients,
                            "event_id": event_id,
                            "created_by": user["id"],
                            "created_at": datetime.utcnow()
                        }
                        
                        db.collection("menus").document(menu_id).set(menu_data)
                        st.success(f"‚úÖ Added: {name}")
                        st.session_state["show_menu_form"] = False
                        
                    except Exception as e:
                        st.error(f"Failed to add menu item: {e}")
        
        with col2:
            if st.form_submit_button("Cancel"):
                st.session_state["show_menu_form"] = False

# ----------------------------
# üõí Shopping List Editor - FIXED
# ----------------------------
def _render_shopping_list_editor(event_id):
    st.subheader("Shopping List Management")
    
    # ‚úÖ FIXED: Better error handling
    try:
        shopping_ref = db.collection("events").document(event_id).collection("shopping_items")
        items = [doc.to_dict() | {"id": doc.id} for doc in shopping_ref.stream()]
    except Exception as e:
        st.error(f"Failed to load shopping items: {e}")
        items = []
    
    # Display existing items - FIXED
    if items:
        st.markdown("#### Current Shopping List")
        for item in items:
            col1, col2, col3, col4 = safe_columns([3, 1, 1, 1])
            
            with col1:
                st.write(f"‚Ä¢ {item.get('name', 'Unknown')}")
            with col2:
                st.write(f"{item.get('quantity', '')} {item.get('unit', '')}")
            with col3:
                # ‚úÖ FIXED: Checkbox state persistence with unique keys
                current_state = item.get('purchased', False)
                new_state = st.checkbox(
                    "Got it", 
                    value=current_state, 
                    key=f"shop_{item['id']}_{event_id}"
                )
                if new_state != current_state:
                    try:
                        shopping_ref.document(item['id']).update({"purchased": new_state})
                    except Exception as e:
                        st.error(f"Failed to update: {e}")
            with col4:
                if delete_button("üóëÔ∏è", key=f"del_shop_{item['id']}_{event_id}"):
                    try:
                        shopping_ref.document(item['id']).delete()
                        st.success("Item deleted")
                    except Exception as e:
                        st.error(f"Failed to delete: {e}")
    
    # Add new item - FIXED
    st.markdown("#### Add Shopping Item")
    with st.form(f"add_shopping_{event_id}"):
        col1, col2, col3 = safe_columns([3, 1, 1])
        
        with col1:
            item_name = st.text_input("Item Name *")
        with col2:
            quantity = st.text_input("Quantity")
        with col3:
            unit = st.selectbox("Unit", ["", "lbs", "kg", "oz", "cups", "pieces", "dozen", "cases"])
        
        category = st.selectbox("Category", ["Produce", "Protein", "Dairy", "Dry Goods", "Beverages", "Supplies", "Other"])
        
        if st.form_submit_button("Add Item"):
            if not item_name:
                st.error("Please enter an item name")
            else:
                try:
                    item_id = generate_id("shop")
                    shopping_ref.document(item_id).set({
                        "id": item_id,
                        "name": item_name,
                        "quantity": quantity,
                        "unit": unit,
                        "category": category,
                        "purchased": False,
                        "created_at": datetime.utcnow()
                    })
                    st.success(f"Added: {item_name}")
                except Exception as e:
                    st.error(f"Failed to add item: {e}")

# ----------------------------
# üéí Equipment List Editor - FIXED
# ----------------------------
def _render_equipment_list_editor(event_id):
    st.subheader("Equipment Management")
    
    # ‚úÖ FIXED: Better error handling
    try:
        equipment_ref = db.collection("events").document(event_id).collection("equipment")
        items = [doc.to_dict() | {"id": doc.id} for doc in equipment_ref.stream()]
    except Exception as e:
        st.error(f"Failed to load equipment: {e}")
        items = []
    
    # Display existing items - FIXED
    if items:
        st.markdown("#### Current Equipment List")
        for item in items:
            col1, col2, col3, col4 = safe_columns([3, 1, 1, 1])
            
            with col1:
                st.write(f"‚Ä¢ {item.get('name', 'Unknown')}")
            with col2:
                st.write(f"Qty: {item.get('quantity', 1)}")
            with col3:
                # ‚úÖ FIXED: Checkbox state persistence
                current_state = item.get('packed', False)
                new_state = st.checkbox(
                    "Packed", 
                    value=current_state, 
                    key=f"eq_{item['id']}_{event_id}"
                )
                if new_state != current_state:
                    try:
                        equipment_ref.document(item['id']).update({"packed": new_state})
                    except Exception as e:
                        st.error(f"Failed to update: {e}")
            with col4:
                if delete_button("üóëÔ∏è", key=f"del_eq_{item['id']}_{event_id}"):
                    try:
                        equipment_ref.document(item['id']).delete()
                        st.success("Equipment removed")
                    except Exception as e:
                        st.error(f"Failed to delete: {e}")
    
    # Add new equipment - FIXED
    st.markdown("#### Add Equipment")
    with st.form(f"add_equipment_{event_id}"):
        col1, col2 = safe_columns([3, 1])
        
        with col1:
            equipment_name = st.text_input("Equipment Name *")
        with col2:
            quantity = st.number_input("Quantity", min_value=1, value=1)
        
        category = st.selectbox("Category", ["Cooking", "Serving", "Storage", "Transport", "Safety", "Other"])
        
        if st.form_submit_button("Add Equipment"):
            if not equipment_name:
                st.error("Please enter equipment name")
            else:
                try:
                    eq_id = generate_id("eq")
                    equipment_ref.document(eq_id).set({
                        "id": eq_id,
                        "name": equipment_name,
                        "quantity": quantity,
                        "category": category,
                        "packed": False,
                        "created_at": datetime.utcnow()
                    })
                    st.success(f"Added: {equipment_name}")
                except Exception as e:
                    st.error(f"Failed to add equipment: {e}")

# ----------------------------
# ‚úÖ Task List Editor - FIXED
# ----------------------------
def _render_task_list_editor(event_id):
    st.subheader("Task Management")
    
    # ‚úÖ FIXED: Better error handling
    try:
        tasks_ref = db.collection("events").document(event_id).collection("tasks")
        tasks = [doc.to_dict() | {"id": doc.id} for doc in tasks_ref.stream()]
    except Exception as e:
        st.error(f"Failed to load tasks: {e}")
        tasks = []
    
    # Display existing tasks - FIXED
    if tasks:
        st.markdown("#### Current Tasks")
        for task in tasks:
            col1, col2 = safe_columns([4, 1])
            
            with col1:
                # ‚úÖ FIXED: Task checkbox state persistence
                current_state = task.get('done', False)
                new_state = st.checkbox(
                    task.get('label', 'Unknown task'),
                    value=current_state,
                    key=f"task_{task['id']}_{event_id}"
                )
                if new_state != current_state:
                    try:
                        tasks_ref.document(task['id']).update({"done": new_state})
                    except Exception as e:
                        st.error(f"Failed to update task: {e}")
            
            with col2:
                if delete_button("üóëÔ∏è", key=f"del_task_{task['id']}_{event_id}"):
                    try:
                        tasks_ref.document(task['id']).delete()
                        st.success("Task deleted")
                    except Exception as e:
                        st.error(f"Failed to delete task: {e}")
    
    # Add new task - FIXED
    st.markdown("#### Add Task")
    with st.form(f"add_task_{event_id}"):
        task_label = st.text_input("Task Description *")
        priority = st.selectbox("Priority", ["High", "Medium", "Low"])
        
        if st.form_submit_button("Add Task"):
            if not task_label:
                st.error("Please enter a task description")
            else:
                try:
                    task_id = generate_id("task")
                    tasks_ref.document(task_id).set({
                        "id": task_id,
                        "label": task_label,
                        "priority": priority,
                        "done": False,
                        "created_at": datetime.utcnow()
                    })
                    st.success(f"Added task: {task_label}")
                except Exception as e:
                    st.error(f"Failed to add task: {e}")

# ----------------------------
# üö® Allergies Section - FIXED
# ----------------------------
def _render_allergies_section(event_id, user):
    """Render allergies management within event planning - FIXED"""
    try:
        # ‚úÖ FIXED: Try importing allergies functions, with fallback
        try:
            from allergies import get_event_allergies, add_allergy_to_event, delete_allergy
            allergies_available = True
        except ImportError:
            allergies_available = False
            st.warning("‚ö†Ô∏è Allergies module not available")
    
        st.subheader("Allergy Management")
        
        if not allergies_available:
            st.info("Allergies management is not available. Check the Allergies tab.")
            return
        
        # Get existing allergies
        allergies = get_event_allergies(event_id)
        
        if allergies:
            st.markdown(f"#### {len(allergies)} People with Allergies")
            
            for allergy in allergies:
                col1, col2, col3 = safe_columns([3, 1, 1])
                
                with col1:
                    st.write(f"**{allergy.get('person_name', 'Unknown')}**")
                    allergens = ", ".join(allergy.get('allergies', []))
                    st.caption(f"Allergies: {allergens}")
                    st.caption(f"Severity: {allergy.get('severity', 'Unknown')}")
                
                with col2:
                    if allergy.get('notes'):
                        st.caption(f"Notes: {allergy.get('notes')}")
                
                with col3:
                    if delete_button("üóëÔ∏è", key=f"del_allergy_{allergy['id']}_{event_id}"):
                        try:
                            if delete_allergy(event_id, allergy['id']):
                                st.success("Allergy removed")
                        except Exception as e:
                            st.error(f"Failed to delete allergy: {e}")
        else:
            st.info("No allergies recorded yet")
        
        # Quick add allergy form - FIXED
        st.markdown("#### Quick Add Allergy")
        with st.form(f"quick_allergy_{event_id}"):
            col1, col2 = safe_columns(2)
            
            with col1:
                person_name = st.text_input("Person's Name *")
                severity = st.selectbox("Severity", ["Mild", "Moderate", "Severe", "Life-threatening"])
            
            with col2:
                allergies_text = st.text_input("Allergies (comma-separated) *")
                notes = st.text_input("Notes (optional)")
            
            if st.form_submit_button("Add Allergy"):
                if not person_name or not allergies_text:
                    st.error("Please provide name and allergies")
                else:
                    try:
                        allergy_list = [a.strip() for a in allergies_text.split(',') if a.strip()]
                        
                        allergy_data = {
                            'person_name': person_name,
                            'allergies': allergy_list,
                            'severity': severity,
                            'notes': notes,
                            'ingredient_ids': [],
                            'tags': [],
                            'created_by': user['id']
                        }
                        
                        if add_allergy_to_event(event_id, allergy_data):
                            st.success(f"Added allergy info for {person_name}")
                    except Exception as e:
                        st.error(f"Failed to add allergy: {e}")
        
        # Link to full allergy management - FIXED
        if st.button("üîç Advanced Allergy Management", key=f"advanced_allergies_{event_id}"):
            st.session_state["active_event_id"] = event_id
            st.session_state["next_nav"] = "Allergies"
            
    except Exception as e:
        st.error(f"Error in allergies section: {e}")

# ----------------------------
# üìé File Upload Section - FIXED
# ----------------------------
def _render_file_upload_section(event_id, user):
    st.subheader("Event Files")
    
    # Show existing files for this event - FIXED
    try:
        files = db.collection("files").where("event_id", "==", event_id).where("deleted", "==", False).stream()
        file_list = [doc.to_dict() | {"id": doc.id} for doc in files]
        
        if file_list:
            st.markdown("#### Current Files")
            for file in file_list:
                col1, col2 = safe_columns([4, 1])
                with col1:
                    st.write(f"üìÑ {file.get('filename', 'Unknown')}")
                    if file.get('tags'):
                        st.caption(f"Tags: {', '.join(file['tags'])}")
                with col2:
                    if file.get('url'):
                        st.link_button("üì•", file['url'], key=f"download_{file['id']}")
    except Exception as e:
        st.error(f"Failed to load files: {e}")
    
    # Upload new file - FIXED
    st.markdown("#### Upload New File")
    uploaded_file = safe_file_uploader(
        "Choose file",
        type=["pdf", "png", "jpg", "jpeg", "txt", "doc", "docx", "xlsx", "xls", "csv"],
        key=f"upload_{event_id}"
    )
    
    if uploaded_file:
        col1, col2 = safe_columns(2)
        
        with col1:
            st.write(f"**File:** {uploaded_file.name}")
            st.write(f"**Size:** {len(uploaded_file.getvalue()) / 1024:.1f} KB")
        
        with col2:
            if st.button("Upload to Event", key=f"upload_btn_{event_id}"):
                try:
                    # ‚úÖ FIXED: Proper file upload with error handling
                    file_id = save_uploaded_file(uploaded_file, event_id, get_user_id(user))
                    if file_id:
                        st.success("File uploaded successfully!")
                    else:
                        st.error("Failed to upload file")
                except Exception as e:
                    st.error(f"Upload failed: {e}")

# ----------------------------
# ü§ñ AI Suggestions - FIXED
# ----------------------------
def _render_ai_suggestions(event_id):
    st.subheader("ü§ñ AI Assistant Suggestions")
    
    # ‚úÖ FIXED: More realistic AI suggestions based on event data
    try:
        event = get_event_data(event_id)
        guest_count = event.get('guest_count', 0)
        dietary_restrictions = event.get('dietary_restrictions', '')
        
        suggestions = []
        
        # Generate contextual suggestions
        if guest_count > 50:
            suggestions.append("Consider adding additional serving stations for large group")
        
        if dietary_restrictions:
            suggestions.append(f"Remember to accommodate dietary restrictions: {dietary_restrictions}")
        
        if not event.get('staff_count'):
            suggestions.append("Don't forget to set your staff count for proper planning")
            
        # Get menu count
        try:
            menu_count = len(list(db.collection("menus").where("event_id", "==", event_id).stream()))
            if menu_count == 0:
                suggestions.append("No menu items yet - start planning your menu")
        except Exception:
            pass
            
        # Default suggestions if none generated
        if not suggestions:
            suggestions = [
                "Consider adding vegetarian options to accommodate all guests",
                "Equipment list seems incomplete - check serving utensils",
                "Shopping list could be organized by store sections for efficiency"
            ]
        
        for i, suggestion in enumerate(suggestions):
            with st.expander(f"üí° Suggestion {i+1}"):
                st.write(suggestion)
                col1, col2 = safe_columns(2)
                with col1:
                    if st.button("‚úÖ Helpful", key=f"helpful_sugg_{i}_{event_id}"):
                        st.success("Thanks for the feedback!")
                with col2:
                    if st.button("‚ùå Dismiss", key=f"dismiss_sugg_{i}_{event_id}"):
                        st.info("Suggestion dismissed")
                        
    except Exception as e:
        st.error(f"Failed to generate suggestions: {e}")
        st.info("AI suggestions temporarily unavailable")


# ----------------------------
# üîÑ Backward Compatibility
# ----------------------------

def event_planning_dashboard(event_id: str):
    """Compatibility wrapper calling the updated UI function."""
    return event_planning_dashboard_ui(event_id)


=== events.py ===
# events.py - Complete Fixed Version with Smart Context Buttons

import streamlit as st
from utils import get_active_event_id, format_date, generate_id, delete_button
from ui_components import show_event_mode_banner
from layout import render_status_indicator
from datetime import datetime
from firebase_init import db, firestore

# ----------------------------
# üî• Get All Events
# ----------------------------

def save_user_event_preference(user_id: str, event_id: str = None):
    """Save user's last active event to their profile"""
    try:
        db.collection("users").document(user_id).update({
            "last_active_event": event_id,
            "last_event_update": datetime.utcnow()
        })
    except Exception:
        # If user doesn't exist, create the preference
        try:
            db.collection("users").document(user_id).set({
                "last_active_event": event_id,
                "last_event_update": datetime.utcnow()
            }, merge=True)
        except Exception as e:
            st.warning(f"Could not save event preference: {e}")

def get_all_events() -> list[dict]:
    """Fetch all events with attached event_file data."""
    try:
        events_ref = db.collection("events")
        docs = events_ref.order_by("start_date", direction=firestore.Query.DESCENDING).stream()
        events = []
        for doc in docs:
            data = doc.to_dict()
            meta_ref = events_ref.document(doc.id).collection("meta").document("event_file")
            meta_doc = meta_ref.get()
            if meta_doc.exists:
                data["event_file"] = meta_doc.to_dict()
            data["id"] = doc.id
            events.append(data)
        return events
    except Exception as e:
        st.error(f"‚ö†Ô∏è Failed to fetch events: {e}")
        return []

# ----------------------------
# ‚ö° Smart Event Management
# ----------------------------

def activate_event(event_id: str) -> None:
    """Sets the active event globally and updates status if needed."""
    try:
        # Set global Event Mode
        db.collection("config").document("global").set({"active_event": event_id}, merge=True)
        
        # Ensure session state is updated
        st.session_state["active_event"] = event_id
        st.session_state["active_event_id"] = event_id

        # Save user preference
        user = st.session_state.get("user")
        if user and user.get("id"):
            save_user_event_preference(user["id"], event_id)
        
        # Update event status to 'active' if it's still in 'planning'
        event_ref = db.collection("events").document(event_id)
        event_doc = event_ref.get()
        if event_doc.exists:
            event_data = event_doc.to_dict()
            if event_data.get('status') == 'planning':
                update_event(event_id, {"status": "active"})
        
        st.success(f"‚úÖ Event Mode activated: {event_id}")
    except Exception as e:
        st.error(f"‚ùå Could not activate event: {e}")

def deactivate_event_mode() -> None:
    """Deactivates the currently active event mode globally."""
    try:
        # Update global config
        db.collection("config").document("global").update({"active_event": None})
        
        # Ensure session state is cleared
        if "active_event_id" in st.session_state:
            del st.session_state["active_event_id"]
            
        # Force synchronization with app state
        st.session_state["active_event"] = None

        # Clear user preference
        user = st.session_state.get("user")
        if user and user.get("id"):
            save_user_event_preference(user["id"], None)
        
        st.success("‚úÖ Event Mode deactivated")
    except Exception as e:
        st.error(f"‚ùå Could not deactivate Event Mode: {e}")

def complete_event_and_end_sessions(event_id: str) -> bool:
    """Complete an event and clear all user sessions"""
    try:
        # Update event status to complete
        update_event(event_id, {"status": "complete"})
        
        # Clear global active event
        db.collection("config").document("global").update({"active_event": None})
        
        # Clear all user preferences for this event
        users_with_event = db.collection("users").where("last_active_event", "==", event_id).stream()
        batch = db.batch()
        for user_doc in users_with_event:
            user_ref = db.collection("users").document(user_doc.id)
            batch.update(user_ref, {
                "last_active_event": None,
                "last_event_update": datetime.utcnow()
            })
        batch.commit()
        
        # Clear current session
        if st.session_state.get("active_event_id") == event_id:
            st.session_state["active_event_id"] = None
            st.session_state["active_event"] = None
        
        st.success("‚úÖ Event completed and all sessions ended")
        return True
        
    except Exception as e:
        st.error(f"‚ùå Failed to complete event: {e}")
        return False

# ----------------------------
# üìÖ Create New Event
# ----------------------------

def create_event(event_data: dict, user_id: str) -> str:
    """Create a new event with validation"""
    try:
        event_id = generate_id("evt")
        
        # Add metadata
        event_data.update({
            "id": event_id,
            "created_by": user_id,
            "created_at": datetime.utcnow(),
            "status": "planning",
            "version": 1,
            "deleted": False
        })
        
        # Ensure required fields have defaults
        event_data.setdefault("guest_count", 0)
        event_data.setdefault("staff_count", 0)
        event_data.setdefault("menu", [])
        event_data.setdefault("shopping_list", [])
        event_data.setdefault("equipment_list", [])
        
        db.collection("events").document(event_id).set(event_data)

         # ‚úÖ Create canonical event_file under /events/{eventId}/meta/event_file
        db.collection("events").document(event_id).collection("meta").document("event_file").set({
            "menu": [],
            "menu_html": "",
            "schedule": [],
            "equipment": [],
            "notes": ""
        })

        return event_id
        
    except Exception as e:
        st.error(f"‚ùå Failed to create event: {e}")
        return None

# ----------------------------
# ‚úèÔ∏è Edit Event
# ----------------------------

def update_event(event_id: str, updates: dict) -> bool:
    """Update an existing event"""
    try:
        # Add update metadata
        updates.update({
            "updated_at": datetime.utcnow(),
            "version": firestore.Increment(1)
        })
        
        db.collection("events").document(event_id).update(updates)
        return True
        
    except Exception as e:
        st.error(f"‚ùå Failed to update event: {e}")
        return False

# ----------------------------
# üóëÔ∏è Delete Event
# ----------------------------

def delete_event(event_id: str) -> bool:
    """Soft delete an event"""
    try:
        db.collection("events").document(event_id).update({
            "deleted": True,
            "deleted_at": datetime.utcnow()
        })
        
        # If this was the active event, clear it and store as recent
        active_event_id = get_active_event_id()
        if active_event_id == event_id:
            st.session_state["recent_event_id"] = event_id
            db.collection("config").document("global").update({"active_event": None})
            if "active_event_id" in st.session_state:
                del st.session_state["active_event_id"]
        
        return True
        
    except Exception as e:
        st.error(f"‚ùå Failed to delete event: {e}")
        return False

# ----------------------------
# üìÜ Upcoming Events Helper
# ----------------------------

def get_upcoming_events(events: list[dict], count: int = 5) -> list[dict]:
    """Return the next `count` upcoming events sorted by start date."""
    today = datetime.utcnow().date()

    def _parse_date(ev):
        try:
            return datetime.fromisoformat(ev.get("start_date", "")).date()
        except Exception:
            return datetime.max.date()

    future_events = [e for e in events if not e.get("deleted") and _parse_date(e) >= today]
    future_events.sort(key=_parse_date)
    return future_events[:count]

# ----------------------------
# üÜï Create Event Section
# ----------------------------

def render_create_event_section(user: dict) -> None:
    """Render the create event form inside an expander."""
    with st.expander("Create New Event", expanded=False):
        with st.form("create_event_form"):
            col1, col2 = st.columns(2)
            with col1:
                name = st.text_input("Event Name *", placeholder="e.g., Summer Retreat 2025")
                location = st.text_input("Location *", placeholder="e.g., Mountain Lodge")
                sd_col1, sd_col2 = st.columns(2)
                with sd_col1:
                    start_date = st.date_input("Start Date *", format="MM/DD/YYYY")
                with sd_col2:
                    end_date = st.date_input("End Date *", format="MM/DD/YYYY")
            with col2:
                description = st.text_area("Description", placeholder="Brief description of the event...")
                guest_count = st.number_input("Expected Guests", min_value=0, value=20)

            submitted = st.form_submit_button("Create Event", type="primary")

            if submitted:
                if not all([name, location, start_date, end_date]):
                    st.error("Please fill in all required fields (*)")
                elif start_date > end_date:
                    st.error("Start date must be before end date")
                else:
                    event_data = {
                        "name": name,
                        "location": location,
                        "description": description,
                        "start_date": start_date.isoformat(),
                        "end_date": end_date.isoformat(),
                        "guest_count": guest_count,
                    }
                    event_id = create_event(event_data, user["id"])
                    if event_id:
                        st.success(f"‚úÖ Event created: {name}")
                        st.rerun()

# ----------------------------
# üÜï Event Details Page
# ----------------------------

def _render_event_details(event: dict, user: dict) -> None:
    """Render a sleek event detail page."""
    st.markdown(f"### {event.get('name', 'Unnamed Event')}")
    start_fmt = format_date(event.get("start_date"))
    end_fmt = format_date(event.get("end_date"))
    st.write(f"**Dates:** {start_fmt} ‚Üí {end_fmt}")
    st.write(f"**Location:** {event.get('location', 'Unknown')}")
    st.write(f"**Guests:** {event.get('guest_count', '-')}")
    if event.get("description"):
        st.write(event.get("description"))

    col1, col2, col3 = st.columns(3)
    if col1.button("Back"):
        st.session_state.pop("selected_event_id", None)
        st.rerun()
    if col2.button("Edit"):
        st.session_state["editing_event_id"] = event["id"]
        st.session_state["next_nav"] = "Events"
        st.session_state["show_event_dashboard"] = True
        st.session_state.pop("selected_event_id", None)
        st.rerun()
    can_delete = (user.get("id") == event.get("created_by") or st.session_state.get("user_role") == "admin")
    if can_delete:
        if delete_button("Delete", key=f"del_detail_{event['id']}"):
            if delete_event(event["id"]):
                st.success("Event deleted")
                st.session_state.pop("selected_event_id", None)
                st.rerun()
# ----------------------------
# üéõ Enhanced Events Tab UI
# ----------------------------


def event_ui(user: dict | None, events: list[dict]) -> None:
    """Display a list of events with selectable detail view."""

    if not user:
        st.warning("Please log in to manage events.")
        return

    if st.session_state.get("show_event_dashboard"):
        from event_planning_dashboard import event_planning_dashboard_ui
        editing_event_id = st.session_state.get("editing_event_id")
        if editing_event_id:
            event_planning_dashboard_ui(editing_event_id)
        return

    # Detail view of a single event
    selected_id = st.session_state.pop("selected_event_id", None)
    if selected_id:
        st.session_state["editing_event_id"] = selected_id
        st.session_state["show_event_dashboard"] = True
        st.session_state["next_nav"] = "Events"
        st.rerun()

    active_event_id = get_active_event_id()
    if active_event_id:
        active_event = next((e for e in events if e["id"] == active_event_id), None)
        if active_event:
            st.info(f"üü£ Event Mode Active: **{active_event.get('name', 'Unknown Event')}**")

    for idx, event in enumerate(events):
        if event.get("deleted"):
            continue

        name = event.get("name", "Unnamed Event")
        date_str = format_date(event.get("start_date"))
        top_line = f"**{name}** {date_str}"
        bottom_line = f"{event.get('guest_count', '-') } guests - {event.get('location', 'Unknown')}"

        col1, col2 = st.columns([0.85, 0.15])
        with col1:
            label = f"{top_line}\n{bottom_line}"
            if st.button(label, key=f"view_{event['id']}", use_container_width=True):
                st.session_state["editing_event_id"] = event["id"]
                st.session_state["show_event_dashboard"] = True
                st.session_state["next_nav"] = "Events"
                st.rerun()

        can_delete = (
            user.get("id") == event.get("created_by")
            or st.session_state.get("user_role") == "admin"
        )
        if can_delete:
            with col2:
                st.markdown('<div class="event-delete-col">', unsafe_allow_html=True)
                if delete_button("üóëÔ∏è", key=f"del_{event['id']}", use_container_width=True):
                    if delete_event(event["id"]):
                        st.success("Event deleted")
                        st.rerun()
                st.markdown('</div>', unsafe_allow_html=True)

    if st.session_state.get("show_event_dashboard"):
        from event_planning_dashboard import event_planning_dashboard_ui
        editing_event_id = st.session_state.get("editing_event_id")
        if editing_event_id:
            event_planning_dashboard_ui(editing_event_id)

    show_event_mode_banner()

# ----------------------------
# üìä Event Statistics
# ----------------------------

def show_event_statistics():
    """Display event statistics dashboard"""
    try:
        events = get_all_events()
        
        if not events:
            return
        
        st.markdown("### Event Statistics")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            total_events = len([e for e in events if not e.get('deleted')])
            st.metric("Total Events", total_events)
        
        with col2:
            active_events = len([e for e in events if e.get('status') == 'active'])
            st.metric("Active Events", active_events)
        
        with col3:
            completed_events = len([e for e in events if e.get('status') == 'complete'])
            st.metric("Completed Events", completed_events)
        
        with col4:
            total_guests = sum(e.get('guest_count', 0) for e in events if not e.get('deleted'))
            st.metric("Total Guests Served", total_guests)
        
        # Show recent activity
        recent_events = sorted(
            [e for e in events if not e.get('deleted')], 
            key=lambda x: x.get('created_at', datetime.min), 
            reverse=True
        )[:3]
        
        if recent_events:
            st.markdown("#### Recent Events")
            for event in recent_events:
                status = event.get('status', 'planning')
                col1, col2 = st.columns([10, 1])
                with col1:
                    st.write(f"‚Ä¢ **{event.get('name', 'Unnamed')}**")
                with col2:
                    render_status_indicator(status)
                
    except Exception as e:
        st.error(f"‚ö†Ô∏è Could not load statistics: {e}")

# ----------------------------
# üîç Event Search and Filter
# ----------------------------

def render_event_filters():
    """Render event search and filter controls"""
    col1, col2, col3 = st.columns(3)
    
    with col1:
        search_term = st.text_input("Search events", placeholder="Search by name or location...")
    
    with col2:
        status_filter = st.selectbox(
            "Filter by status",
            ["All", "planning", "active", "complete"],
            key="status_filter_select",
        )

    with col3:
        date_filter = st.selectbox(
            "Date range",
            ["All time", "This month", "Next month", "Past events"],
            key="date_filter_select",
        )
    
    return search_term, status_filter, date_filter

def filter_events(events, search_term, status_filter, date_filter):
    """Apply filters to events list"""
    filtered = events
    
    # Apply search filter
    if search_term:
        search_lower = search_term.lower()
        filtered = [e for e in filtered if 
                   search_lower in e.get('name', '').lower() or 
                   search_lower in e.get('location', '').lower()]
    
    # Apply status filter
    if status_filter != "All":
        filtered = [e for e in filtered if e.get('status') == status_filter]
    
    # Apply date filter (simplified)
    if date_filter != "All time":
        # This could be enhanced with actual date filtering logic
        pass
    
    return filtered

# ----------------------------
# üéØ Enhanced Event UI with Filters
# ----------------------------

def enhanced_event_ui(user: dict | None) -> None:
    """Reimagined event UI with upcoming events and expandable sections."""

    if st.session_state.get("show_event_dashboard"):
        from event_planning_dashboard import event_planning_dashboard_ui
        editing_event_id = st.session_state.get("editing_event_id")
        if editing_event_id:
            event_planning_dashboard_ui(editing_event_id)
        return

    events = get_all_events()

    # If a specific event dashboard was requested, show it immediately
    if st.session_state.get("show_event_dashboard"):
        from event_planning_dashboard import event_planning_dashboard_ui
        editing_event_id = st.session_state.get("editing_event_id")
        if editing_event_id:
            event_planning_dashboard_ui(editing_event_id)
        return

    # Upcoming Events section
    st.markdown("### Upcoming Events")
    upcoming = get_upcoming_events(events)
    if upcoming:
        for ev in upcoming:
            name = ev.get("name", "Unnamed Event")
            date_str = format_date(ev.get("start_date"))
            top_line = f"**{name}** {date_str}"
            bottom_line = f"{ev.get('guest_count', '-') } guests - {ev.get('location', 'Unknown')}"

            col1, col2 = st.columns([0.85, 0.15])
            with col1:
                label = f"{top_line}\n{bottom_line}"
                if st.button(label, key=f"upcoming_{ev['id']}", use_container_width=True):
                    st.session_state["editing_event_id"] = ev["id"]
                    st.session_state["show_event_dashboard"] = True
                    st.session_state["next_nav"] = "Events"
                    st.rerun()

            can_delete = (
                user and (
                    user.get("id") == ev.get("created_by")
                    or st.session_state.get("user_role") == "admin"
                )
            )
            if can_delete:
                with col2:
                    st.markdown('<div class="event-delete-col">', unsafe_allow_html=True)
                    if delete_button("üóëÔ∏è", key=f"del_up_{ev['id']}", use_container_width=True):
                        if delete_event(ev["id"]):
                            st.success("Event deleted")
                            st.rerun()
                    st.markdown('</div>', unsafe_allow_html=True)
    else:
        st.write("No upcoming events.")

    if user:
        render_create_event_section(user)
    else:
        st.warning("Please log in to create events.")

    with st.expander("All Events", expanded=False):
        event_ui(user, events)

    with st.expander("Search Event", expanded=False):
        search_term, status_filter, date_filter = render_event_filters()
        filtered = filter_events(events, search_term, status_filter, date_filter)
        if search_term or status_filter != "All" or date_filter != "All time":
            st.info(f"Showing {len(filtered)} matching events")
            for ev in filtered:
                st.markdown(f"**{ev.get('name', 'Unnamed Event')}** {format_date(ev.get('start_date'))}")
                st.markdown(f"{ev.get('guest_count', '-') } guests - {ev.get('location', 'Unknown')}")
        else:
            st.write("Enter search criteria above to find events.")

    with st.expander("Event Statistics", expanded=False):
        show_event_statistics()

# ----------------------------
# üîÑ Backward Compatibility
# ----------------------------

def get_active_event():
    """Get the full active event document"""
    from utils import get_active_event
    return get_active_event()


=== file_storage.py ===
import streamlit as st
from firebase_admin import storage
from utils import format_date, get_active_event_id, session_get, session_set, get_event_by_id, generate_id, delete_button
from recipe_viewer import render_recipe_preview
from recipes import find_recipe_by_name
from datetime import datetime
import uuid
import mimetypes
from ai_parsing_engine import parse_file, extract_text
from io import BytesIO



# ----------------------------
# üìÅ File Manager UI
# ----------------------------

def file_manager_ui(user):
    from firebase_init import get_db
    db = get_db()

    st.subheader("üìÅ File Manager")
    user_id = user.get("id")
    query = db.collection("files").where("deleted", "==", False)
    files = list(query.stream())
    file_data = [doc.to_dict() | {"id": doc.id} for doc in files]

    if 'view_mode' not in st.session_state:
        st.session_state['view_mode'] = 'all'
    if 'search_term' not in st.session_state:
        st.session_state['search_term'] = ''

    view_col, search_col = st.columns([1, 3])
    with view_col:
        st.selectbox(
            "View Mode", 
            ["all", "linked", "unlinked"], 
            key="view_mode"
        )
    with search_col:
        st.text_input("Search files", key="search_term")

    filtered = []
    for file in file_data:
        matches_view = (
            st.session_state.view_mode == "all" or
            (st.session_state.view_mode == "linked" and file.get("event_id")) or
            (st.session_state.view_mode == "unlinked" and not file.get("event_id"))
        )
        matches_search = st.session_state.search_term.lower() in file.get("name", "").lower()
        if matches_view and matches_search:
            filtered.append(file)

    grouped = {}
    for file in filtered:
        event_id = file.get("event_id") or "No Event"
        grouped.setdefault(event_id, []).append(file)

    for group_id, files in grouped.items():
        with st.expander(f"üì¶ {group_id} ({len(files)} files)"):
            for file in files:
                file_name = file.get("name", "Unnamed")
                col_a, col_b, col_c, col_d = st.columns([3, 1, 1, 1])

                with col_a:
                    st.markdown(f"**{file_name}** ({file.get('type', '-')})")
                with col_b:
                    if st.button("View/Edit Data", key=f"view_{file['id']}"):
                        st.session_state["editing_parsed_file"] = file["id"]
                with col_c:
                    if st.button("Save As", key=f"saveas_{file['id']}"):
                        st.session_state["saveas_file"] = file["id"]
                with col_d:
                    if delete_button("Delete", key=f"delete_{file['id']}"):
                        db.collection("files").document(file["id"]).update({"deleted": True})
                        st.rerun()

    if "editing_file" in st.session_state:
        file = st.session_state["editing_file"]
        st.markdown(f"### ‚úèÔ∏è Editing File: {file.get('name', '')}")
        tags = st.text_input("Tags (comma-separated)", value=", ".join(file.get("tags", [])))
        event_id = st.text_input("Linked Event ID", value=file.get("event_id", ""))
        if st.button("Save Changes", key="save_changes"):
            db.collection("files").document(file["id"]).update({
                "tags": [tag.strip() for tag in tags.split(",") if tag.strip()],
                "event_id": event_id
            })
            st.success("‚úÖ File updated.")
            del st.session_state["editing_file"]
            st.rerun()
        if st.button("Cancel", key="cancel_edit"):
            del st.session_state["editing_file"]
            st.rerun()

    if "editing_parsed_file" in st.session_state:
        file_id = st.session_state["editing_parsed_file"]
        doc = db.collection("files").document(file_id).get()
        if doc.exists:
            _render_parsed_data_editor(doc.to_dict() | {"id": file_id}, db)

    if "saveas_file" in st.session_state:
        file_id = st.session_state["saveas_file"]
        doc = db.collection("files").document(file_id).get()
        if doc.exists:
            _render_save_as_options(doc.to_dict() | {"id": file_id})

# ----------------------------
# üìä File Analytics
# ----------------------------

def show_file_analytics():
    from firebase_init import get_db
    db = get_db()

    st.subheader("üìä File Analytics")
    query = db.collection("files").where("deleted", "==", False)
    files = list(query.stream())
    file_data = [doc.to_dict() | {"id": doc.id} for doc in files]

    total_files = len(file_data)
    linked = len([f for f in file_data if f.get("event_id")])
    unlinked = total_files - linked
    types = {}
    contributors = set()

    for file in file_data:
        contributors.add(file.get("uploaded_by", "Unknown"))
        ftype = file.get("type", "other")
        types[ftype] = types.get(ftype, 0) + 1

    st.metric("üìÅ Total Files", total_files)
    st.metric("üîó Linked to Events", linked)
    st.metric("‚ùå Unlinked", unlinked)
    st.metric("üôã Contributors", len(contributors))

    st.markdown("### üìÇ File Type Breakdown")
    for ftype, count in types.items():
        st.markdown(f"- **{ftype}**: {count}")

# ----------------------------
# ‚¨ÜÔ∏è Save Uploaded File
# ----------------------------

def save_uploaded_file(file, event_id: str, uploaded_by: str):
    from firebase_init import get_db, get_bucket
    db = get_db()
    bucket = get_bucket()

    file_id = generate_id("file")
    content = file.getvalue()
    filename = file.name
    mimetype, _ = mimetypes.guess_type(filename)
    mimetype = mimetype or "application/octet-stream"

    folder = event_id or "unlinked"
    storage_path = f"uploads/{folder}/{file_id}_{filename}"
    blob = bucket.blob(storage_path)
    blob.upload_from_string(content, content_type=mimetype)
    blob.make_public()

    raw_text = None
    parsed = {}
    try:
        fcopy = BytesIO(content)
        fcopy.name = filename
        fcopy.type = mimetype
        raw_text = extract_text(fcopy)
        parsed = parse_file(fcopy, target_type="all", user_id=uploaded_by, file_id=file_id)
    except Exception as e:
        print(f"AI parsing failed: {e}")

    metadata = {
        "name": filename,
        "size": len(content),
        "type": mimetype,
        "uploaded_by": uploaded_by,
        "event_id": event_id,
        "created_at": datetime.utcnow(),
        "storage_path": storage_path,
        "public_url": blob.public_url,
        "deleted": False,
        "raw_text": raw_text,
        "parsed_data": {
            "parsed": parsed,
            "version": 1,
            "status": "pending_review",
            "last_updated": datetime.utcnow(),
            "user_id": uploaded_by
        } if parsed else {},
    }

    db.collection("files").document(file_id).set(metadata)
    return {
        "file_id": file_id,
        "parsed": parsed,
        "raw_text": raw_text
    }

# ----------------------------
# üîó Link File to Entity
# ----------------------------

def link_file_to_entity(file_id: str, entity_type: str, entity_id: str):
    from firebase_init import get_db
    db = get_db()

    assert entity_type in {"recipes", "events", "menus", "ingredients"}, "Invalid entity type"
    file_ref = db.collection("files").document(file_id)
    file_doc = file_ref.get()
    if not file_doc.exists:
        raise ValueError("File does not exist")
    data = file_doc.to_dict()
    linked_to = data.get("linked_to", {})
    current_links = linked_to.get(entity_type, [])
    if entity_id not in current_links:
        current_links.append(entity_id)
    linked_to[entity_type] = current_links
    file_ref.update({"linked_to": linked_to})

# ----------------------------
# üß© Link Editor UI
# ----------------------------

def show_link_editor_ui(file_id: str):
    import streamlit as st
    from firebase_init import get_db
    from utils import get_all_docs_as_options
    from file_storage import link_file_to_entity

    db = get_db()
    st.markdown("### üîó Link this file to a record")
    link_targets = ["event", "recipe", "menu", "ingredient"]
    selected_type = st.selectbox("View", ["all", "linked", "unlinked"], key="view_mode")
    collection_map = {
        "event": "events", "recipe": "recipes",
        "menu": "menus", "ingredient": "ingredients"
    }
    options = get_all_docs_as_options(collection_map[selected_type])
    selected_id = st.selectbox(
        f"Select {selected_type} to link",
        options,
        format_func=lambda o: o.get('name', o.get('title', o['id'])),
        key=f"{file_id}_{selected_type}"
    )
    if st.button(f"üîó Link to selected {selected_type}", key=f"link_btn_{file_id}"):
        link_file_to_entity(file_id, collection_map[selected_type], selected_id["id"])
        st.success(f"‚úÖ Linked to {selected_type.capitalize()}")

# ----------------------------
# üìù Parsed Data Editor
# ----------------------------

def _render_parsed_data_editor(file: dict, db):
    import json
    st.markdown(f"### üìù Parsed Data: {file.get('name', '')}")
    parsed = file.get("parsed_data", {}).get("parsed", {})
    if st.session_state.get("_last_inline_file") != file["id"]:
        st.session_state.pop("inline_editor_type", None)
        st.session_state.pop("inline_editor_data", None)
    st.session_state["_last_inline_file"] = file["id"]

    if not parsed:
        st.info("No parsed data available for this file.")
        if st.button("Close", key=f"close_edit_{file['id']}"):
            del st.session_state["editing_parsed_file"]
        return

    # Determine inline editor type based on parsed content
    if "recipes" in parsed and parsed["recipes"]:
        st.session_state["inline_editor_type"] = "recipe"
        st.session_state["inline_editor_data"] = (
            parsed["recipes"][0] if isinstance(parsed["recipes"], list) else parsed["recipes"]
        )
    elif "menus" in parsed and parsed["menus"]:
        st.session_state["inline_editor_type"] = "menu"
        st.session_state["inline_editor_data"] = (
            parsed["menus"][0] if isinstance(parsed["menus"], list) else parsed["menus"]
        )
    elif "ingredients" in parsed and parsed["ingredients"]:
        st.session_state["inline_editor_type"] = "ingredient"
        st.session_state["inline_editor_data"] = (
            parsed["ingredients"][0]
            if isinstance(parsed["ingredients"], list)
            else parsed["ingredients"]
        )

    render_recipe_preview(parsed)

    if "inline_editor_type" not in st.session_state:
        edit_key = f"edit_json_{file['id']}"
        if st.session_state.get(f"edit_mode_{file['id']}"):
            json_text = st.text_area(
                "JSON",
                st.session_state.get(edit_key, json.dumps(parsed, indent=2)),
                height=300,
                key=edit_key,
            )
            col1, col2 = st.columns(2)
            with col1:
                if st.button("Save", key=f"save_json_{file['id']}"):
                    try:
                        new_data = json.loads(json_text)
                        db.collection("files").document(file["id"]).update(
                            {
                                "parsed_data.parsed": new_data,
                                "parsed_data.last_updated": datetime.utcnow(),
                            }
                        )
                        st.success("‚úÖ Data saved")
                        st.session_state[f"edit_mode_{file['id']}"] = False
                        del st.session_state["editing_parsed_file"]
                        st.rerun()
                    except json.JSONDecodeError:
                        st.error("Invalid JSON")
            with col2:
                if st.button("Cancel", key=f"cancel_json_{file['id']}"):
                    st.session_state[f"edit_mode_{file['id']}"] = False
        else:
            st.json(parsed)
            if st.button("Edit", key=f"start_edit_{file['id']}"):
                st.session_state[f"edit_mode_{file['id']}"] = True

    if st.session_state.get("inline_editor_type") == "recipe":
        st.markdown("### ‚úèÔ∏è Edit This Recipe")
        from recipes_editor import recipe_editor_ui
        recipe_editor_ui(prefill_data=st.session_state["inline_editor_data"])
    elif st.session_state.get("inline_editor_type") == "menu":
        st.markdown("### ‚úèÔ∏è Edit This Menu")
        from menu_editor import menu_editor_ui
        menu_editor_ui(prefill_data=st.session_state["inline_editor_data"])
    elif st.session_state.get("inline_editor_type") == "ingredient":
        st.markdown("### ‚úèÔ∏è Edit This Ingredient")
        from ingredients_editor import ingredients_editor_ui
        ingredients_editor_ui(prefill_data=st.session_state["inline_editor_data"])
    if st.button("Close", key=f"close_view_{file['id']}"):
        if f"edit_mode_{file['id']}" in st.session_state:
            del st.session_state[f"edit_mode_{file['id']}"]
        del st.session_state["editing_parsed_file"]
        st.rerun()

# ----------------------------
# üíæ Save-As Options
# ----------------------------

def _render_save_as_options(file: dict):
    from auth import get_user_id
    from shopping_lists import create_shopping_list
    from recipes import (
        save_recipe_to_firestore,
        save_event_to_firestore,
        save_menu_to_firestore,
        save_ingredient_to_firestore,
    )

    file_id = file["id"]
    parsed = file.get("parsed_data", {}).get("parsed", {})
    uploaded_name = parsed.get("title") or parsed.get("name") or file.get("name", "Unnamed File")

    dup_key = f"dup_saveas_{file_id}"
    dup_state = st.session_state.get(dup_key)
    if dup_state:
        st.warning("A recipe with this name already exists.")
        option = st.selectbox(
            "Choose how to proceed:",
            ["Add Version", "Save under Different Name", "Cancel"],
            key=f"dup_saveas_choice_{file_id}",
        )
        new_name = None
        if option == "Save under Different Name":
            new_name = st.text_input(
                "New Recipe Name",
                value=dup_state["data"].get("name"),
                key=f"dup_saveas_newname_{file_id}",
            )
        if st.button("Continue", key=f"dup_saveas_continue_{file_id}"):
            if option == "Add Version":
                doc_ref = db.collection("recipes").document(dup_state["existing_id"])
                doc_ref.collection("versions").document(generate_id("ver")).set(
                    dup_state["data"] | {
                        "timestamp": datetime.utcnow(),
                        "edited_by": dup_state.get("user_id"),
                    }
                )
                st.success("‚úÖ Added as new version")
            elif option == "Save under Different Name":
                dup_state["data"]["name"] = new_name or dup_state["data"].get("name")
                save_recipe_to_firestore(
                    dup_state["data"], user_id=dup_state.get("user_id"), file_id=file_id
                )
                st.success("‚úÖ Recipe saved")
            st.session_state.pop(dup_key)
            del st.session_state["saveas_file"]
            st.rerun()
        if st.button("Cancel", key=f"dup_saveas_cancel_{file_id}"):
            st.session_state.pop(dup_key)
            st.rerun()
        return

    st.markdown(f"### üíæ Save '{uploaded_name}' As...")
    option = st.selectbox(
        "Select type",
        ["Recipe", "Menu", "Shopping List", "Event", "Ingredient"],
        key=f"saveas_option_{file_id}"
    )

    if st.button("Create", key=f"create_{file_id}"):
        user_id = get_user_id()
        if option == "Recipe":
            existing = find_recipe_by_name(uploaded_name)
            if existing:
                st.session_state[dup_key] = {
                    "existing_id": existing["id"],
                    "data": parsed,
                    "user_id": user_id,
                }
                st.rerun()
            else:
                save_recipe_to_firestore(parsed, user_id=user_id, file_id=file_id)
                st.success("‚úÖ Saved as Recipe")
        elif option == "Menu":
            save_menu_to_firestore(parsed, user_id=user_id, file_id=file_id)
            st.success("‚úÖ Saved as Menu")
        elif option == "Event":
            save_event_to_firestore(parsed, user_id=user_id, file_id=file_id)
            st.success("‚úÖ Saved as Event")
        elif option == "Ingredient":
            save_ingredient_to_firestore(parsed, user_id=user_id, file_id=file_id)
            st.success("‚úÖ Saved as Ingredient")
        elif option == "Shopping List":
            create_shopping_list({
                "name": uploaded_name,
                "items": parsed.get("items", []),
                "source_file": file_id,
                "parsed_data": parsed,
            }, user_id=user_id)
            st.success("‚úÖ Saved as Shopping List")
        del st.session_state["saveas_file"]
        st.rerun()
    if st.button("Cancel", key=f"cancel_saveas_{file_id}"):
        del st.session_state["saveas_file"]
        st.rerun()


=== firebase.json ===
{
  "hosting": {
    "public": "public",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}


=== firebase_init.py ===
import firebase_admin
from firebase_admin import credentials, firestore, storage
import streamlit as st

# Initialize Firebase app (only once)
if not firebase_admin._apps:
    cred = credentials.Certificate(dict(st.secrets["firebase_admin"]))
    firebase_admin.initialize_app(cred, {
        "storageBucket": st.secrets["firebase"]["storageBucket"]
    })

# Export Firestore + Storage
db = firestore.client()
bucket = storage.bucket()
firestore = firestore  # expose firestore for Increment, etc.
__all__ = ["db", "bucket", "firestore"]

# Optional accessors for backward compatibility
def get_db():
    return db

def get_bucket():
    return bucket


=== firestore_utils.py ===
from firebase_init import db, firestore
"""
üì¶ Firestore Utility Functions
Use this file for reusable Firestore access patterns such as:
- Batched writes
- Paginated queries
- Generic document helpers
"""

from firebase_init import db, firestore

# Example: Batch update documents
def batch_update(collection_name: str, updates: list[tuple[str, dict]]) -> None:
    """
    Batch update multiple documents in a Firestore collection.
    Args:
        collection_name: Name of the collection
        updates: List of (document_id, data_dict) tuples
    """
    batch = db.batch()
    for doc_id, data in updates:
        ref = db.collection(collection_name).document(doc_id)
        batch.update(ref, data)
    batch.commit()

# Example: Safely fetch a document
def get_doc_safe(collection: str, doc_id: str) -> dict | None:
    try:
        doc = db.collection(collection).document(doc_id).get()
        return doc.to_dict() if doc.exists else None
    except Exception as e:
        print(f"‚ö†Ô∏è Error fetching document {doc_id}: {e}")
        return None


=== historical_menus.py ===
import streamlit as st
from firebase_init import db
from utils import format_date

# ----------------------------
# üìú Historical Menus Viewer
# ----------------------------

def historical_menus_ui():
    st.title("üìú Historical Menus")

    events_ref = db.collection("events")
    events = events_ref.stream()

    menu_events = []
    for event in events:
        event_data = event.to_dict()
        event_id = event.id
        meta_ref = events_ref.document(event_id).collection("meta").document("event_file")
        meta_doc = meta_ref.get()
        if meta_doc.exists and meta_doc.to_dict().get("menu"):
            menu_events.append({
                "id": event_id,
                "name": event_data.get("name", "Unnamed Event"),
                "date": event_data.get("start_date"),
                "menu": meta_doc.to_dict().get("menu", [])
            })

    sort_mode = st.radio("Sort by", ["Newest First", "Oldest First", "Event Name"])

    if sort_mode == "Newest First":
        menu_events.sort(key=lambda e: e["date"] or "", reverse=True)
    elif sort_mode == "Oldest First":
        menu_events.sort(key=lambda e: e["date"] or "")
    else:
        menu_events.sort(key=lambda e: e["name"].lower())

    for event in menu_events:
        st.markdown(f"## üóìÔ∏è {event['name']} ({format_date(event['date'])})")
        menu = event["menu"]

        meal_colors = {
            "breakfast": "#ADD8E6",
            "lunch": "#FFD700",
            "dinner": "#90EE90",
            "note": "#D3D3D3"
        }

        for item in menu:
            bg_color = meal_colors.get(item.get("meal", "note").lower(), "#f0f0f0")
            with st.container():
                st.markdown(f"<div style='background-color:{bg_color};padding:1em;border-radius:8px;'>", unsafe_allow_html=True)
                st.markdown(f"**Day:** {item.get('day', '-')}")
                st.markdown(f"**Meal:** {item.get('meal', '-').capitalize()}")
                st.markdown(f"**Recipe:** {item.get('recipe', '-')}")
                st.markdown(f"**Notes:** {item.get('notes', '-')}")
                st.markdown(f"**Tags:** {', '.join(item.get('tags', []))}")
                st.markdown(f"**Allergens:** {', '.join(item.get('allergens', []))}")
                st.markdown("</div>", unsafe_allow_html=True)

        st.markdown("---")


=== ingredients.py ===
# ingredients.py
import streamlit as st
from firebase_init import get_db
db = get_db()

from firebase_admin import firestore
from utils import generate_id, format_date, normalize_ingredient
from auth import require_login, get_user_role
from datetime import datetime
from typing import List, Dict, Optional
import re
from google.cloud.firestore_v1.base_query import FieldFilter
from utils import normalize_ingredient



# ----------------------------
# ü•ï Ingredient Management
# ----------------------------

def scale_ingredients(ingredients: list, multiplier: float) -> list:
    """Scale quantities of ingredients by a multiplier (e.g., guest count)"""
    for ing in ingredients:
        try:
            qty = float(ing.get("quantity", "1").split()[0])
            ing["quantity"] = str(round(qty * multiplier, 2))
        except:
            pass  # fallback: skip if not numerical
    return ingredients

def get_event_ingredient_list(event_id: str) -> list:
    """Aggregate and scale ingredients for all recipes in the event's menu"""
    try:
        meta_doc = db.collection("events").document(event_id).collection("meta").document("event_file").get()
        if not meta_doc.exists:
            return []
        meta = meta_doc.to_dict()
        menu_recipes = meta.get("menu", [])

        event_doc = db.collection("events").document(event_id).get()
        guest_count = event_doc.to_dict().get("guest_count", 1)

        all_ingredients = []
        for recipe_entry in menu_recipes:
            recipe_name = recipe_entry.get("recipe")
            if not recipe_name:
                continue

            query = db.collection("recipes").where("name", "==", recipe_name).limit(1).stream()
            recipe_doc = next(query, None)
            if not recipe_doc:
                continue

            recipe_data = recipe_doc.to_dict()
            if recipe_data.get("parsed_ingredients"):
                scaled = scale_ingredients(recipe_data["parsed_ingredients"], guest_count)
                all_ingredients.extend(scaled)
        return all_ingredients
    except Exception as e:
        st.error(f"Could not build event ingredient list: {e}")
        return []



def normalize_ingredient(ingredient: str) -> str:
    """Normalize ingredient name for consistency"""
    # Basic normalization - lowercase, strip whitespace, remove plurals
    normalized = ingredient.lower().strip()
    
    # Simple plural handling
    if normalized.endswith('ies'):
        normalized = normalized[:-3] + 'y'
    elif normalized.endswith('es'):
        normalized = normalized[:-2]
    elif normalized.endswith('s') and not normalized.endswith('ss'):
        normalized = normalized[:-1]
    
    return normalized

def parse_ingredient_line(line: str) -> Dict[str, str]:
    """Parse an ingredient line into quantity, unit, and name"""
    # Common measurement patterns
    quantity_pattern = r'^(\d+(?:\.\d+)?(?:/\d+)?|\d+\s*-\s*\d+)'
    unit_pattern = r'(cups?|tbsp?|tsp?|oz|ounces?|lbs?|pounds?|g|grams?|kg|kilograms?|ml|liters?|gallons?|quarts?|pints?|pieces?|cloves?|bunches?|cans?|packages?|boxes?)'
    
    line = line.strip()
    result = {
        'original': line,
        'quantity': '',
        'unit': '',
        'name': line,
        'normalized_name': ''
    }
    
    # Try to extract quantity
    quantity_match = re.match(quantity_pattern, line)
    if quantity_match:
        result['quantity'] = quantity_match.group(1)
        line = line[len(result['quantity']):].strip()
    
    # Try to extract unit
    unit_match = re.match(unit_pattern, line, re.IGNORECASE)
    if unit_match:
        result['unit'] = unit_match.group(1).lower()
        line = line[len(result['unit']):].strip()
    
    # Clean up the ingredient name
    # Remove common words like "of", "fresh", etc.
    cleanup_words = ['of', 'fresh', 'dried', 'chopped', 'minced', 'sliced', 'diced']
    words = line.split()
    cleaned_words = [w for w in words if w.lower() not in cleanup_words]
    
    result['name'] = ' '.join(cleaned_words) if cleaned_words else line
    result['normalized_name'] = normalize_ingredient(result['name'])
    
    return result

def get_or_create_ingredient(name: str, normalized_name: str = None) -> str:
    """Get existing ingredient or create new one, return ingredient ID"""
    if not normalized_name:
        normalized_name = normalize_ingredient(name)
    
    # Check if ingredient exists
    existing = db.collection("ingredients").where("normalized_name", "==", normalized_name).limit(1).stream()
    existing_list = list(existing)
    
    if existing_list:
        return existing_list[0].id
    
    # Create new ingredient
    ingredient_id = generate_id("ing")
    db.collection("ingredients").document(ingredient_id).set({
        "id": ingredient_id,
        "name": name.title(),
        "normalized_name": normalized_name,
        "category": categorize_ingredient(name),
        "created_at": datetime.utcnow(),
        "usage_count": 0,
        "common_units": [],
        "substitutes": [],
        "allergen_info": {}
    })
    
    return ingredient_id

def categorize_ingredient(ingredient_name: str) -> str:
    """Auto-categorize ingredient based on name"""
    name_lower = ingredient_name.lower()
    
    # Category mappings
    categories = {
        "Proteins": ["chicken", "beef", "pork", "fish", "salmon", "tuna", "shrimp", "tofu", "egg", "turkey", "lamb"],
        "Dairy": ["milk", "cheese", "yogurt", "butter", "cream", "sour cream", "cottage cheese", "mozzarella"],
        "Vegetables": ["carrot", "celery", "onion", "garlic", "tomato", "pepper", "broccoli", "spinach", "lettuce", "potato"],
        "Fruits": ["apple", "banana", "orange", "lemon", "lime", "berry", "strawberry", "grape", "peach", "mango"],
        "Grains": ["rice", "pasta", "bread", "flour", "oats", "quinoa", "barley", "wheat", "cereal"],
        "Herbs & Spices": ["salt", "pepper", "basil", "oregano", "thyme", "rosemary", "paprika", "cumin", "cinnamon"],
        "Oils & Fats": ["oil", "olive oil", "butter", "margarine", "shortening", "lard"],
        "Condiments": ["sauce", "ketchup", "mustard", "mayo", "vinegar", "dressing", "salsa"],
        "Baking": ["sugar", "flour", "baking powder", "baking soda", "yeast", "vanilla", "cocoa"],
        "Beverages": ["water", "juice", "coffee", "tea", "soda", "wine", "beer", "broth", "stock"]
    }
    
    for category, keywords in categories.items():
        if any(keyword in name_lower for keyword in keywords):
            return category
    
    return "Other"

# ----------------------------
# üç≥ Recipe Parsing
# ----------------------------

def parse_recipe_ingredients(ingredients_text: str) -> List[Dict]:
    """Parse a recipe's ingredients text into structured data"""
    lines = ingredients_text.strip().split('\n')
    parsed_ingredients = []
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
            
        # Skip section headers (e.g., "For the sauce:")
        if line.endswith(':') or line.startswith('#'):
            continue
        
        parsed = parse_ingredient_line(line)
        
        # Get or create ingredient in database
        ingredient_id = get_or_create_ingredient(parsed['name'], parsed['normalized_name'])
        
        parsed['ingredient_id'] = ingredient_id
        parsed_ingredients.append(parsed)
    
    return parsed_ingredients

def update_recipe_with_parsed_ingredients(recipe_id: str, parsed_ingredients: List[Dict]):
    """Update a recipe with parsed ingredient data"""
    try:
        # Get unique ingredient IDs
        ingredient_ids = list(set(ing['ingredient_id'] for ing in parsed_ingredients))
        
        # Update recipe
        db.collection("recipes").document(recipe_id).update({
            "parsed_ingredients": parsed_ingredients,
            "ingredient_ids": ingredient_ids,
            "ingredients_parsed": True,
            "parsed_at": datetime.utcnow()
        })
        
        # Update ingredient usage counts
        for ing_id in ingredient_ids:
            db.collection("ingredients").document(ing_id).update({
                "usage_count": firestore.Increment(1)
            })
        
        return True
        
    except Exception as e:
        st.error(f"Failed to update recipe: {e}")
        return False

# ----------------------------
# üîç Ingredient Search
# ----------------------------

def search_recipes_by_ingredient(ingredient_id: str) -> List[Dict]:
    """Find all recipes containing a specific ingredient"""
    try:
        recipes = db.collection("recipes").where("ingredient_ids", "array_contains", ingredient_id).stream()
        return [doc.to_dict() | {"id": doc.id} for doc in recipes]
    except Exception as e:
        st.error(f"Failed to search recipes: {e}")
        return []

def search_ingredients(query: str) -> List[Dict]:
    """Search ingredients by name"""
    query_lower = query.lower()
    try:
        # Get all ingredients (in a real app, you'd want to use a proper search index)
        all_ingredients = db.collection("ingredients").stream()
        results = []
        
        for doc in all_ingredients:
            ing = doc.to_dict()
            if query_lower in ing.get('name', '').lower() or query_lower in ing.get('normalized_name', ''):
                results.append(ing)
        
        return sorted(results, key=lambda x: x.get('usage_count', 0), reverse=True)
        
    except Exception as e:
        st.error(f"Failed to search ingredients: {e}")
        return []

# ----------------------------
# üé® Ingredient Catalogue UI
# ----------------------------


def ingredient_catalogue_ui(user: dict):
    """Main ingredient catalogue interface"""
    st.title("ü•ï Ingredient Catalogue")
    
    tab1, tab2, tab3 = st.tabs(["Browse Ingredients", "Recipe Search", "Parse Recipes"])
    
    with tab1:
        _browse_ingredients_tab()
    
    with tab2:
        _ingredient_search_tab()
    
    with tab3:
        _parse_recipes_tab(user)

def _browse_ingredients_tab():
    """Browse and manage ingredients"""
    st.subheader("üìö Browse Ingredients")
    
    # Search box
    search_query = st.text_input("Search ingredients", placeholder="Type to search...")
    
    # Category filter
    categories = ["All", "Proteins", "Dairy", "Vegetables", "Fruits", "Grains", 
                 "Herbs & Spices", "Oils & Fats", "Condiments", "Baking", "Beverages", "Other"]
    selected_category = st.selectbox("Filter by category", categories)
    
    # Get ingredients
    try:
        if selected_category == "All":
            query = db.collection("ingredients").order_by("usage_count", direction=firestore.Query.DESCENDING)
        else:
            query = db.collection("ingredients").where(filter=FieldFilter("category", "==", selected_category))
        
        ingredients = [doc.to_dict() for doc in query.stream()]
        
        # Apply search filter
        if search_query:
            search_lower = search_query.lower()
            ingredients = [ing for ing in ingredients if 
                          search_lower in ing.get('name', '').lower() or 
                          search_lower in ing.get('normalized_name', '')]
        
        if not ingredients:
            st.info("No ingredients found.")
            return
        
        # Display ingredients
        st.markdown(f"### Found {len(ingredients)} ingredients")
        
        # Create a grid layout
        cols = st.columns(3)
        for i, ingredient in enumerate(ingredients):
            with cols[i % 3]:
                with st.container():
                    st.markdown(f"**{ingredient.get('name', 'Unknown')}**")
                    st.caption(f"Category: {ingredient.get('category', 'Other')}")
                    st.caption(f"Used in {ingredient.get('usage_count', 0)} recipes")
                    
                    # Check for allergen warnings
                    allergen_info = ingredient.get('allergen_info', {})
                    if allergen_info:
                        allergen_count = len(allergen_info)
                        st.warning(f"‚ö†Ô∏è {allergen_count} allergen warning(s)")
                    
                    if st.button("View Details", key=f"view_{ingredient['id']}"):
                        _show_ingredient_details(ingredient)
        
    except Exception as e:
        st.error(f"Failed to load ingredients: {e}")

def _ingredient_search_tab():
    """Search recipes by ingredient"""
    st.subheader("üîç Search Recipes by Ingredient")
    
    # Ingredient selector
    ingredient_search = st.text_input("Type ingredient name", placeholder="e.g., chicken, tomato...")
    
    if ingredient_search:
        # Search ingredients
        matching_ingredients = search_ingredients(ingredient_search)
        
        if matching_ingredients:
            # Let user select specific ingredient
            selected_ingredient = st.selectbox(
                "Select ingredient",
                options=matching_ingredients,
                format_func=lambda x: f"{x['name']} ({x['usage_count']} recipes)"
            )
            
            if selected_ingredient and st.button("Search Recipes"):
                # Find recipes with this ingredient
                recipes = search_recipes_by_ingredient(selected_ingredient['id'])
                
                if recipes:
                    st.success(f"Found {len(recipes)} recipes with {selected_ingredient['name']}")
                    
                    for recipe in recipes:
                        with st.expander(f"üìñ {recipe.get('name', 'Unnamed Recipe')}"):
                            st.write(f"**Author:** {recipe.get('author_name', 'Unknown')}")
                            st.write(f"**Created:** {format_date(recipe.get('created_at'))}")
                            
                            # Show how this ingredient is used
                            parsed_ings = recipe.get('parsed_ingredients', [])
                            for ping in parsed_ings:
                                if ping.get('ingredient_id') == selected_ingredient['id']:
                                    st.info(f"Uses: {ping.get('original', 'Unknown amount')}")
                            
                            # Recipe actions
                            col1, col2 = st.columns(2)
                            with col1:
                                if st.button("View Recipe", key=f"view_recipe_{recipe['id']}"):
                                    st.session_state["selected_recipe"] = recipe['id']
                                    st.session_state["next_nav"] = "Recipes"
                else:
                    st.info(f"No recipes found with {selected_ingredient['name']}")
        else:
            st.info("No matching ingredients found")

def _parse_recipes_tab(user: dict):
    """Parse ingredients from existing recipes"""
    st.subheader("üîß Parse Recipe Ingredients")
    st.caption("Extract structured ingredient data from recipe text")
    
    role = get_user_role(user)
    if role not in ["admin", "manager"]:
        st.warning("Only managers and admins can parse recipes")
        return
    
    # Get unparsed recipes
    try:
        unparsed = db.collection("recipes").where("ingredients_parsed", "==", False).stream()
        unparsed_recipes = [doc.to_dict() | {"id": doc.id} for doc in unparsed]
        
        # Also get recipes without the field
        all_recipes = db.collection("recipes").stream()
        for doc in all_recipes:
            recipe = doc.to_dict()
            if "ingredients_parsed" not in recipe:
                recipe["id"] = doc.id
                unparsed_recipes.append(recipe)
        
        if not unparsed_recipes:
            st.success("‚úÖ All recipes have been parsed!")
            
            # Option to re-parse
            if st.checkbox("Show all recipes for re-parsing"):
                all_recipes = db.collection("recipes").stream()
                unparsed_recipes = [doc.to_dict() | {"id": doc.id} for doc in all_recipes]
        
        if unparsed_recipes:
            st.info(f"Found {len(unparsed_recipes)} recipes to parse")
            
            # Select recipe to parse
            selected_recipe = st.selectbox(
                "Select recipe to parse",
                options=unparsed_recipes,
                format_func=lambda x: x.get('name', 'Unnamed Recipe')
            )
            
            if selected_recipe:
                st.markdown(f"### {selected_recipe.get('name', 'Unnamed')}")
                
                # Show current ingredients text
                ingredients_text = selected_recipe.get('ingredients', '')
                st.markdown("**Current ingredients text:**")
                st.text_area(
                    "Ingredients",
                    value=ingredients_text,
                    height=200,
                    disabled=True,
                    label_visibility="collapsed",
                )
                
                if st.button("üîç Parse Ingredients", type="primary"):
                    with st.spinner("Parsing ingredients..."):
                        # Parse the ingredients
                        parsed = parse_recipe_ingredients(ingredients_text)
                        
                        if parsed:
                            st.success(f"‚úÖ Parsed {len(parsed)} ingredients!")
                            
                            # Show parsed results
                            st.markdown("**Parsed ingredients:**")
                            for ping in parsed:
                                cols = st.columns([1, 1, 2, 2])
                                with cols[0]:
                                    st.write(ping.get('quantity', '-'))
                                with cols[1]:
                                    st.write(ping.get('unit', '-'))
                                with cols[2]:
                                    st.write(ping.get('name', '-'))
                                with cols[3]:
                                    st.caption(f"‚Üí {ping.get('normalized_name', '-')}")
                            
                            # Save button
                            if st.button("üíæ Save Parsed Data"):
                                if update_recipe_with_parsed_ingredients(selected_recipe['id'], parsed):
                                    st.success("‚úÖ Recipe updated with parsed ingredients!")
                        else:
                            st.warning("No ingredients could be parsed")
        
    except Exception as e:
        st.error(f"Failed to load recipes: {e}")

def _show_ingredient_details(ingredient: Dict):
    """Show detailed ingredient information in sidebar"""
    with st.sidebar:
        st.markdown(f"## {ingredient.get('name', 'Unknown')}")
        
        # Basic info
        st.markdown("### Basic Information")
        st.write(f"**Category:** {ingredient.get('category', 'Other')}")
        st.write(f"**Usage Count:** {ingredient.get('usage_count', 0)} recipes")
        st.write(f"**Common Units:** {', '.join(ingredient.get('common_units', [])) or 'None recorded'}")
        
        # Allergen information
        allergen_info = ingredient.get('allergen_info', {})
        if allergen_info:
            st.markdown("### ‚ö†Ô∏è Allergen Warnings")
            for person, allergies in allergen_info.items():
                st.warning(f"**{person}:** {', '.join(allergies)}")
        
        # Substitutes
        substitutes = ingredient.get('substitutes', [])
        if substitutes:
            st.markdown("### üîÑ Common Substitutes")
            for sub in substitutes:
                st.write(f"‚Ä¢ {sub}")
        
        # Add substitute
        st.markdown("### Add Information")
        
        new_substitute = st.text_input("Add substitute")
        if st.button("Add Substitute") and new_substitute:
            try:
                current_subs = ingredient.get('substitutes', [])
                current_subs.append(new_substitute)
                db.collection("ingredients").document(ingredient['id']).update({
                    'substitutes': current_subs
                })
                st.success("Substitute added!")
            except Exception as e:
                st.error(f"Failed to add substitute: {e}")

# ----------------------------
# üîÑ Migration Functions
# ----------------------------

def migrate_existing_recipes():
    """One-time migration to parse all existing recipes"""
    try:
        recipes = db.collection("recipes").stream()
        count = 0
        
        for doc in recipes:
            recipe = doc.to_dict()
            if not recipe.get('ingredients_parsed'):
                ingredients_text = recipe.get('ingredients', '')
                if ingredients_text:
                    parsed = parse_recipe_ingredients(ingredients_text)
                    if parsed:
                        update_recipe_with_parsed_ingredients(doc.id, parsed)
                        count += 1
        
        return count
        
    except Exception as e:
        st.error(f"Migration failed: {e}")
        return 0

# ----------------------------
# üìä Analytics Functions
# ----------------------------

def get_ingredient_analytics():
    """Get analytics about ingredient usage"""
    try:
        # Most used ingredients
        top_ingredients = db.collection("ingredients").order_by("usage_count", direction=firestore.Query.DESCENDING).limit(10).stream()
        
        # Category distribution
        all_ingredients = db.collection("ingredients").stream()
        category_counts = {}
        
        for doc in all_ingredients:
            ing = doc.to_dict()
            category = ing.get('category', 'Other')
            category_counts[category] = category_counts.get(category, 0) + 1
        
        return {
            'top_ingredients': [doc.to_dict() for doc in top_ingredients],
            'category_distribution': category_counts
        }
        
    except Exception as e:
        st.error(f"Failed to get analytics: {e}")
        return None


=== ingredients_editor.py ===
import streamlit as st
from firebase_init import db
from auth import get_user_id
from datetime import datetime
from utils import generate_id


def ingredients_editor_ui(ingredient_id=None, prefill_data=None):
    """Edit or create an ingredient."""
    st.title("ü•ï Ingredient Editor")

    user_id = get_user_id()
    doc_ref = None
    ingredient = None

    if ingredient_id:
        doc_ref = db.collection("ingredients").document(ingredient_id)
        doc = doc_ref.get()
        if not doc.exists:
            st.error("Ingredient not found.")
            return
        ingredient = doc.to_dict()
    elif prefill_data:
        ingredient = prefill_data
        st.info("üí° This form is pre-filled from parsed data.")
    else:
        st.warning("No ingredient to show.")
        return

    with st.form("edit_ingredient_form"):
        name = st.text_input("Ingredient Name", value=ingredient.get("name", ""))
        unit = st.text_input("Unit", value=ingredient.get("unit", ""))
        category = st.text_input("Category", value=ingredient.get("category", ""))
        notes = st.text_area("Notes", value=ingredient.get("notes", ""))
        tags = st.text_input(
            "Tags (comma-separated)",
            value=", ".join(ingredient.get("tags", []))
        )

        submitted = st.form_submit_button("üíæ Save")
        if submitted:
            data = {
                "name": name,
                "unit": unit,
                "category": category,
                "notes": notes,
                "tags": [t.strip() for t in tags.split(",") if t.strip()],
                "updated_at": datetime.utcnow(),
                "updated_by": user_id,
            }
            if doc_ref:
                doc_ref.update(data)
                st.success("‚úÖ Ingredient updated!")
            else:
                ing_id = generate_id("ing")
                data["created_at"] = datetime.utcnow()
                data["created_by"] = user_id
                db.collection("ingredients").document(ing_id).set(data)
                st.success("‚úÖ Ingredient saved!")


=== landing.py ===
# landing.py

import streamlit as st

def show():
    st.set_page_config(page_title="Mountain Medicine", layout="centered")


    # üìä Replace these with live Firestore queries if needed
    meals_cooked = 3240
    recipes_shared = 182
    retreats_catered = 29
    guests_served = 1875

    # üîê Top-right login button
    st.markdown("""
        <div style="position: absolute; top: 1rem; right: 1rem;">
            <a href='/?signin=true' style='text-decoration: none; font-weight: bold; color: white; background: #6C4AB6; padding: 0.5rem 1rem; border-radius: 8px;'>Login</a>
        </div>
    """, unsafe_allow_html=True)

    # üé® Centered logo + title + tagline
    st.markdown("""
        <div style="text-align: center; margin-top: 4rem;">
            <div style="width: 100px; height: 100px; background-color: #ccc; border-radius: 50%; margin: 0 auto 1rem;">
                <!-- Logo Placeholder -->
            </div>
            <h1 style="color: #6C4AB6;">Mountain Medicine</h1>
            <p style="font-size: 1.2rem; font-style: italic; color: #555;">
                Bringing humanity closer through man's original primal ceremony
            </p>
        </div>
    """, unsafe_allow_html=True)

    st.markdown("### üç≤ Impact Snapshot")
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Meals Cooked", meals_cooked)
    col2.metric("Recipes", recipes_shared)
    col3.metric("Retreats", retreats_catered)
    col4.metric("Guests Served", guests_served)

    st.markdown("---")
    st.info("Want to participate or help cook? Log in to view events, menus, and more.")


=== layout.py ===
# layout.py - Complete redesign with all requested features

import streamlit as st
from pathlib import Path
from utils import session_get, format_date, get_event_by_id, get_active_event
from auth import get_user_role, get_user
from datetime import datetime


# ----------------------------
# üé® Inject Custom CSS + JS
# ----------------------------
def inject_custom_css():
    """Inject custom CSS styling for the application"""
    # Load the updated CSS file
    css_path = Path(__file__).resolve().parent / "style.css"
    try:
        with open(css_path, "r") as f:
            css_content = f.read()
        st.markdown(f"<style>{css_content}</style>", unsafe_allow_html=True)
    except FileNotFoundError:
        # Fallback to inline CSS if file not found
        css_content = """
        <style>
        /* Fallback styling */\n[data-testid='stSidebar'] { display: none; }
        :root {
            --primary-purple: #6C4AB6;
            --light-purple: #B8A4D4;
            --accent-purple: #563a9d;
            --border-radius: 8px;
        }
        
        button, .stButton > button {
            background-color: var(--primary-purple) !important;
            color: white !important;
            border: none !important;
            border-radius: var(--border-radius) !important;
            padding: 0.5rem 1rem !important;
            font-weight: 500 !important;
            transition: all 0.2s ease !important;
            min-height: 44px !important;
        }
        
        button:hover, .stButton > button:hover {
            background-color: var(--accent-purple) !important;
        }
        </style>
        """
        st.markdown(css_content, unsafe_allow_html=True)

# ----------------------------
# üéõÔ∏è Simple Event Mode Indicator
# ----------------------------
def render_event_mode_indicator():
    """Render simple event mode indicator in top right"""
    from utils import get_active_event_id, get_active_event
    
    active_event_id = get_active_event_id()
    
    if active_event_id:
        active_event = get_active_event()
        event_name = active_event.get("name", "Unknown Event") if active_event else "Unknown"
        
        indicator_html = f"""
        <div class="event-mode-simple-indicator">
            EVENT MODE ON: <strong>{event_name}</strong>
        </div>
        """
        st.markdown(indicator_html, unsafe_allow_html=True)


def render_chat_bubble():
    """Render the floating chat bubble with full drag functionality"""
    # Initialize position in session state if not exists
    if "chat_button_position" not in st.session_state:
        st.session_state.chat_button_position = {"bottom": 30, "right": 30}
    
    # Chat bubble with working toggle
    if st.button("üí¨", key="floating_chat_toggle", 
                 help="Toggle AI Assistant - Drag to move",
                 use_container_width=False):
        st.session_state.chat_window_open = not st.session_state.chat_window_open
        st.rerun()
    
    # Get current position from session state
    bottom = st.session_state.chat_button_position.get("bottom", 30)
    right = st.session_state.chat_button_position.get("right", 30)
    
    # Position the button using CSS and add draggable functionality
    st.markdown(f"""
    <style>
    /* Draggable chat button */
    .stButton:has([data-testid*="floating_chat_toggle"]) {{
        position: fixed !important;
        bottom: {bottom}px !important;
        right: {right}px !important;
        z-index: 1000 !important;
        width: 60px !important;
        height: 60px !important;
        transition: none !important;
    }}
    
    .stButton:has([data-testid*="floating_chat_toggle"]) button {{
        width: 60px !important;
        height: 60px !important;
        border-radius: 50% !important;
        font-size: 24px !important;
        background: var(--primary-purple, #6C4AB6) !important;
        box-shadow: 0 4px 12px rgba(108, 74, 182, 0.3) !important;
        cursor: move !important;
        position: relative !important;
        overflow: visible !important;
    }}
    
    .stButton:has([data-testid*="floating_chat_toggle"]) button:hover {{
        transform: scale(1.1) !important;
        background: var(--accent-purple, #563a9d) !important;
    }}
    
    .stButton:has([data-testid*="floating_chat_toggle"]).dragging button {{
        opacity: 0.8 !important;
        transform: scale(1.15) !important;
        cursor: grabbing !important;
    }}
    
    /* Drag handle indicator */
    .stButton:has([data-testid*="floating_chat_toggle"]) button::after {{
        content: '‚ãÆ‚ãÆ';
        position: absolute;
        bottom: -5px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 10px;
        color: rgba(255, 255, 255, 0.5);
        letter-spacing: -2px;
    }}
    
    /* Prevent text selection during drag */
    body.dragging {{
        user-select: none !important;
        -webkit-user-select: none !important;
        -moz-user-select: none !important;
        -ms-user-select: none !important;
    }}
    </style>
    
    <script>
    (function() {{
        let dragButton = null;
        let isDragging = false;
        let startX, startY;
        let startBottom, startRight;
        let dragTimeout;
        
        // Wait for the button to be rendered
        const initDraggable = () => {{
            const button = document.querySelector('[data-testid*="floating_chat_toggle"]');
            if (button && button !== dragButton) {{
                dragButton = button;
                const container = button.closest('.stButton');
                if (container) {{
                    setupDraggable(container, button);
                }}
            }}
        }};
        
        // Check periodically for the button
        setInterval(initDraggable, 500);
        
        function setupDraggable(container, button) {{
            // Remove any existing listeners
            button.removeEventListener('mousedown', handleMouseDown);
            button.removeEventListener('touchstart', handleTouchStart);
            
            // Add new listeners
            button.addEventListener('mousedown', handleMouseDown);
            button.addEventListener('touchstart', handleTouchStart, {{ passive: false }});
            
            function handleMouseDown(e) {{
                // Only drag on direct button click, not on any child elements
                if (e.target !== button && !button.contains(e.target) return;
                
                startDrag(e.clientX, e.clientY);
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                
                // Prevent click event after drag
                dragTimeout = setTimeout(() => {{
                    e.preventDefault();
                    e.stopPropagation();
                }}, 150);
            }}
            
            function handleTouchStart(e) {{
                if (e.touches.length !== 1) return;
                
                const touch = e.touches[0];
                startDrag(touch.clientX, touch.clientY);
                
                document.addEventListener('touchmove', handleTouchMove, {{ passive: false }});
                document.addEventListener('touchend', handleTouchEnd);
                
                // Prevent default touch behavior
                e.preventDefault();
            }}
            
            function startDrag(clientX, clientY) {{
                isDragging = true;
                startX = clientX;
                startY = clientY;
                
                const rect = container.getBoundingClientRect();
                startBottom = window.innerHeight - rect.bottom;
                startRight = window.innerWidth - rect.right;
                
                container.classList.add('dragging');
                document.body.classList.add('dragging');
            }}
            
            function handleMouseMove(e) {{
                if (!isDragging) return;
                performDrag(e.clientX, e.clientY);
            }}
            
            function handleTouchMove(e) {{
                if (!isDragging || e.touches.length !== 1) return;
                const touch = e.touches[0];
                performDrag(touch.clientX, touch.clientY);
                e.preventDefault();
            }}
            
            function performDrag(clientX, clientY) {{
                const deltaX = clientX - startX;
                const deltaY = clientY - startY;
                
                let newRight = startRight - deltaX;
                let newBottom = startBottom - deltaY;
                
                // Keep button on screen with padding
                const padding = 10;
                const buttonSize = 60;
                
                newRight = Math.max(padding, Math.min(window.innerWidth - buttonSize - padding, newRight);
                newBottom = Math.max(padding, Math.min(window.innerHeight - buttonSize - padding, newBottom);
                
                // Apply new position
                container.style.right = newRight + 'px';
                container.style.bottom = newBottom + 'px';
                container.style.left = 'auto';
                container.style.top = 'auto';
            }}
            
            function handleMouseUp(e) {{
                endDrag();
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                
                // Clear drag timeout
                if (dragTimeout) {{
                    clearTimeout(dragTimeout);
                    dragTimeout = null;
                }}
            }}
            
            function handleTouchEnd(e) {{
                endDrag();
                document.removeEventListener('touchmove', handleTouchMove);
                document.removeEventListener('touchend', handleTouchEnd);
            }}
            
            function endDrag() {{
                if (!isDragging) return;
                
                isDragging = false;
                container.classList.remove('dragging');
                document.body.classList.remove('dragging');
                
                // Get final position
                const rect = container.getBoundingClientRect();
                const finalBottom = window.innerHeight - rect.bottom;
                const finalRight = window.innerWidth - rect.right;
                
                // Save position to Streamlit
                const positionData = {{
                    bottom: Math.round(finalBottom),
                    right: Math.round(finalRight)
                }};
                
                // Try to update Streamlit session state
                if (window.parent && window.parent.postMessage) {{
                    window.parent.postMessage({{
                        isStreamlitMessage: true,
                        type: 'streamlit:componentMessage',
                        args: {{
                            key: 'chat_position_update',
                            value: positionData
                        }}
                    }}, '*');
                }}
                
                // Also try direct update (for some Streamlit versions)
                try {{
                    window.parent.streamlit.setComponentValue(positionData);
                }} catch (e) {{
                    console.log('Position update via direct method failed, using postMessage');
                }}
            }}
        }}
    }})();
    </script>
    """, unsafe_allow_html=True)
    
    # Hidden component to receive position updates
    # This is a workaround since Streamlit doesn't directly support postMessage updates
    position_receiver = st.empty()
    with position_receiver:
        position_update = st.text_input(
            "position_update", 
            value="", 
            key="chat_position_receiver",
            label_visibility="hidden"
        )
        
        if position_update:
            try:
                import json
                new_pos = json.loads(position_update)
                if isinstance(new_pos, dict) and "bottom" in new_pos and "right" in new_pos:
                    st.session_state.chat_button_position = new_pos
                    st.rerun()
            except:
                pass


# Alternative approach using Streamlit Components (if you have streamlit-components installed)
def render_fully_draggable_chat():
    """Alternative implementation using custom component approach"""
    # This would be even more robust but requires additional setup
    
    chat_html = f"""
    <div id="draggable-chat-container">
        <button id="chat-bubble" class="chat-bubble">
            üí¨
        </button>
    </div>
    
    <style>
    #draggable-chat-container {{
        position: fixed;
        bottom: {st.session_state.get('chat_bottom', 30)}px;
        right: {st.session_state.get('chat_right', 30)}px;
        z-index: 1000;
    }}
    
    .chat-bubble {{
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: #6C4AB6;
        color: white;
        border: none;
        font-size: 24px;
        cursor: move;
        box-shadow: 0 4px 12px rgba(108, 74, 182, 0.3);
        transition: transform 0.2s ease;
    }}
    
    .chat-bubble:hover {{
        transform: scale(1.1);
        background: #563a9d;
    }}
    
    .chat-bubble:active {{
        cursor: grabbing;
        transform: scale(1.15);
        opacity: 0.8;
    }}
    </style>
    
    <script>
    // Make the chat bubble draggable
    const makeDraggable = (element) => {{
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        element.onmousedown = dragMouseDown;
        
        function dragMouseDown(e) {{
            e = e || window.event;
            e.preventDefault();
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }}
        
        function elementDrag(e) {{
            e = e || window.event;
            e.preventDefault();
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            
            const container = element.parentElement;
            const newTop = container.offsetTop - pos2;
            const newLeft = container.offsetLeft - pos1;
            
            // Constrain to viewport
            const maxTop = window.innerHeight - element.offsetHeight - 10;
            const maxLeft = window.innerWidth - element.offsetWidth - 10;
            
            container.style.top = Math.max(10, Math.min(maxTop, newTop) + "px";
            container.style.left = Math.max(10, Math.min(maxLeft, newLeft) + "px";
            container.style.bottom = "auto";
            container.style.right = "auto";
        }}
        
        function closeDragElement() {{
            document.onmouseup = null;
            document.onmousemove = null;
            
            // Send final position to Streamlit
            const container = element.parentElement;
            const bottom = window.innerHeight - container.offsetTop - element.offsetHeight;
            const right = window.innerWidth - container.offsetLeft - element.offsetWidth;
            
            // Update position
            window.parent.postMessage({{
                type: 'streamlit:chat_position',
                bottom: bottom,
                right: right
            }}, '*');
        }}
    }};
    
    // Initialize draggable
    document.addEventListener('DOMContentLoaded', () => {{
        const chatBubble = document.getElementById('chat-bubble');
        if (chatBubble) {{
            makeDraggable(chatBubble);
            
            // Handle click to toggle chat
            chatBubble.addEventListener('click', (e) => {{
                if (!e.defaultPrevented) {{
                    window.parent.postMessage({{
                        type: 'streamlit:toggle_chat'
                    }}, '*');
                }}
            }});
        }}
    }});
    </script>
    """
    
    st.components.v1.html(chat_html, height=0)

# Updated render_chat_window function for layout.py
# Replace the existing render_chat_window function with this:

def render_chat_window():
    """Render the chat window when open with proper input functionality"""
    # Create a unique container for the chat
    chat_container = st.container()
    
    with chat_container:
        # Use columns to create the chat layout
        chat_col = st.columns([1])[0]
        
        with chat_col:
            # Create the chat interface with custom HTML/CSS
            st.markdown("""
            <div class="ai-chat-window" id="chatWindow">
                <div class="chat-header">
                    <h3>ü§ñ AI Assistant</h3>
                    <button class="close-button" onclick="document.getElementById('chatWindow').style.display='none';">‚úï</button>
                </div>
                <div class="chat-body" id="chatBody">
                    <div class="chat-messages-container">
            """, unsafe_allow_html=True)
            
            # Display chat messages
            if not st.session_state.get("chat_history"):
                st.markdown('<div class="chat-message-center">üëã Hi! How can I help with your event?</div>', unsafe_allow_html=True)
            else:
                for msg in st.session_state.chat_history[-10:]:  # Show last 10 messages
                    sender_class = "user" if msg.get("sender") == "user" else "ai"
                    sender_label = "You" if msg.get("sender") == "user" else "AI"
                    content = msg.get("content", "").replace("\n", "<br>")
                    
                    st.markdown(f'''
                    <div class="chat-message {sender_class}">
                        <strong>{sender_label}:</strong> {content}
                    </div>
                    ''', unsafe_allow_html=True)
            
            st.markdown("""
                    </div>
                </div>
            </div>
            """, unsafe_allow_html=True)
            
            # Quick action buttons
            st.markdown("**Quick Actions:**")
            col1, col2, col3 = st.columns(3)
            
            with col1:
                if st.button("üõí Shopping List", key="chat_shopping", use_container_width=True):
                    _process_chat_input("Generate a shopping list for the active event")
                    st.rerun()
            
            with col2:
                if st.button("üìã Menu Ideas", key="chat_menu", use_container_width=True):
                    _process_chat_input("Suggest menu items for the active event")
                    st.rerun()
            
            with col3:
                if st.button("‚è∞ Timeline", key="chat_timeline", use_container_width=True):
                    _process_chat_input("Create a timeline for event preparation")
                    st.rerun()
            
            # Chat input form
            with st.form("chat_form", clear_on_submit=True):
                user_input = st.text_input(
                    "Type your message:", 
                    placeholder="Ask me anything about your event...",
                    key="chat_message_input"
                )
                col1, col2 = st.columns([4, 1])
                
                with col2:
                    submitted = st.form_submit_button("Send", type="primary", use_container_width=True)
                
                if submitted and user_input:
                    _process_chat_input(user_input)
                    st.rerun()

def _process_chat_input(message: str):
    """Process chat input and get AI response"""
    # Add user message
    if "chat_history" not in st.session_state:
        st.session_state.chat_history = []
    
    st.session_state.chat_history.append({
        "sender": "user",
        "content": message,
        "timestamp": datetime.now()
    })
    
    # Get AI response
    with st.spinner("ü§ñ Thinking..."):
        # For now, use the existing response logic
        # This will be replaced with real OpenAI integration
        response = _get_ai_response_improved(message)
        
        st.session_state.chat_history.append({
            "sender": "ai",
            "content": response,
            "timestamp": datetime.now()
        })

def _get_ai_response_improved(message: str) -> str:
    """Improved AI response with context awareness"""
    from utils import get_active_event
    
    # Get context
    active_event = get_active_event()
    event_context = ""
    
    if active_event:
        event_context = f"Currently planning: {active_event.get('name', 'Unknown Event')} with {active_event.get('guest_count', 0)} guests."
    
    # Enhanced responses based on keywords
    message_lower = message.lower()
    
    # Shopping list
    if any(word in message_lower for word in ['shopping', 'grocery', 'ingredients', 'buy']):
        if active_event:
            return f"""Here's a shopping list for {active_event.get('name', 'your event')}:

**Produce:**
‚Ä¢ Fresh vegetables (for {active_event.get('guest_count', 20)} people)
‚Ä¢ Salad greens
‚Ä¢ Fresh herbs (basil, cilantro, parsley)
‚Ä¢ Seasonal fruits

**Proteins:**
‚Ä¢ Chicken breasts (2 per person)
‚Ä¢ Fish fillets
‚Ä¢ Vegetarian options (tofu/tempeh)

**Staples:**
‚Ä¢ Rice/pasta (1/2 cup dry per person)
‚Ä¢ Cooking oil
‚Ä¢ Seasonings and spices

**Beverages:**
‚Ä¢ Water (1 gallon per 4 people)
‚Ä¢ Assorted beverages

Would you like me to adjust quantities or add specific items?"""
        else:
            return "I'd be happy to create a shopping list! First, please activate an event so I know how many people you're serving."
    
    # Menu suggestions
    elif any(word in message_lower for word in ['menu', 'food', 'meal', 'recipe']):
        if active_event:
            dietary = active_event.get('dietary_restrictions', '')
            return f"""Here are menu suggestions for {active_event.get('name', 'your event')}:

**Appetizers:**
‚Ä¢ Seasonal vegetable crudit√© with herb dip
‚Ä¢ Stuffed mushrooms
‚Ä¢ Bruschetta trio

**Main Courses:**
‚Ä¢ Herb-crusted chicken with lemon
‚Ä¢ Grilled vegetable stack (vegetarian)
‚Ä¢ Pan-seared fish with seasonal salsa

**Sides:**
‚Ä¢ Wild rice pilaf
‚Ä¢ Roasted seasonal vegetables
‚Ä¢ Fresh garden salad

**Dessert:**
‚Ä¢ Fruit tart
‚Ä¢ Chocolate mousse cups

{f'Note: Accounting for dietary restrictions: {dietary}' if dietary else ''}

Would you like detailed recipes for any of these?"""
        else:
            return "I can suggest menus! Please activate an event first so I can tailor suggestions to your guest count and preferences."
    
    # Timeline
    elif any(word in message_lower for word in ['timeline', 'schedule', 'when', 'timing']):
        if active_event:
            from datetime import datetime, timedelta
            try:
                event_date = datetime.strptime(active_event.get('start_date', ''), '%Y-%m-%d')
                return f"""Here's a suggested timeline for {active_event.get('name', 'your event')}:

**2 Weeks Before:**
‚Ä¢ Finalize menu and guest count
‚Ä¢ Order special equipment
‚Ä¢ Create shopping lists

**1 Week Before:**
‚Ä¢ Shop for non-perishables
‚Ä¢ Confirm staff assignments
‚Ä¢ Review event flow

**2 Days Before:**
‚Ä¢ Shop for fresh ingredients
‚Ä¢ Begin prep work
‚Ä¢ Set up equipment

**1 Day Before:**
‚Ä¢ Complete vegetable prep
‚Ä¢ Marinate proteins
‚Ä¢ Organize service items

**Day Of Event:**
‚Ä¢ 6 hours before: Start cooking
‚Ä¢ 4 hours before: Final prep
‚Ä¢ 2 hours before: Set up service area
‚Ä¢ 1 hour before: Final touches
‚Ä¢ Service time: Execute and enjoy!

Need a more detailed timeline for any phase?"""
            except:
                return "I'll create a timeline once you set the event date in the event details."
        else:
            return "I'd be happy to create a timeline! Please activate an event first."
    
    # Default contextual response
    else:
        if active_event:
            return f"""I'm here to help with {active_event.get('name', 'your event')}! {event_context}

I can help you with:
‚Ä¢ Creating shopping lists
‚Ä¢ Planning menus
‚Ä¢ Building timelines
‚Ä¢ Managing tasks
‚Ä¢ Calculating quantities
‚Ä¢ Suggesting recipes

What would you like to work on?"""
        else:
            return """I'm your catering assistant! I can help with event planning, menus, shopping lists, and more.

To get started, please activate an event from the Events tab. Once you have an active event, I can provide specific recommendations for:
‚Ä¢ Shopping lists with quantities
‚Ä¢ Menu suggestions
‚Ä¢ Preparation timelines
‚Ä¢ Task management
‚Ä¢ And much more!

What would you like to know about?"""

def render_chat_messages():
    """Render chat messages as HTML"""
    messages = []
    if not st.session_state.chat_history:
        messages.append('<div class="chat-message-center">üëã Hi! How can I help with your event?</div>')
    else:
        for msg in st.session_state.chat_history[-10:]:
            sender_class = "user" if msg.get("sender") == "user" else "ai"
            sender_label = "You" if msg.get("sender") == "user" else "AI"
            content = msg.get("content", "").replace("\n", "<br>")
            messages.append(f'''
                <div class="chat-message {sender_class}">
                    <strong>{sender_label}:</strong> {content}
                </div>
            ''')
    return messages

def _add_message(sender: str, content: str):
    """Add a message to chat history"""
    st.session_state.chat_history.append({
        "sender": sender,
        "content": content,
        "timestamp": st.session_state.get("current_time", "now")
    })

def _get_ai_response(message: str):
    """Get AI response (simplified for this fix)"""
    responses = {
        "shopping": "Here's a shopping list for your event:\n‚Ä¢ Fresh vegetables\n‚Ä¢ Proteins (chicken, fish)\n‚Ä¢ Grains (rice, pasta)\n‚Ä¢ Seasonings and spices",
        "menu": "Menu suggestions:\n‚Ä¢ Grilled chicken with herbs\n‚Ä¢ Seasonal vegetable medley\n‚Ä¢ Wild rice pilaf\n‚Ä¢ Fresh fruit dessert",
        "timeline": "Event timeline:\n‚Ä¢ 2 days before: Shop for ingredients\n‚Ä¢ 1 day before: Prep vegetables\n‚Ä¢ Day of: Start cooking 4 hours before\n‚Ä¢ 1 hour before: Final plating"
    }
    
    # Simple keyword matching
    if "shopping" in message.lower():
        response = responses["shopping"]
    elif "menu" in message.lower():
        response = responses["menu"]
    elif "timeline" in message.lower():
        response = responses["timeline"]
    else:
        response = "I'd be happy to help with your catering needs! Ask me about shopping lists, menu planning, or event timelines."
    
    _add_message("ai", response)

# ----------------------------
# üß≠ Purple Tab Navigation
# ----------------------------
def render_top_navbar(tabs):
    """Render clean purple-themed navigation tabs using Streamlit native components"""
    if not tabs:
        st.warning("‚ö†Ô∏è No navigation tabs defined.")
        return

    # Inject logo banner above tabs
    st.markdown(
        """
        <div style="text-align:center; padding: 1rem 0;">
            <img src="/mountain_logo_banner.png" style="max-width: 600px; height: auto;" alt="Mountain Medicine">
        </div>
        """,
        unsafe_allow_html=True,
    )

    default_tab = "Dashboard" if "Dashboard" in tabs else tabs[0]
    current_tab = st.session_state.get("top_nav", default_tab)

    if current_tab not in tabs:
        current_tab = default_tab
        st.session_state["top_nav"] = current_tab

    user = get_user()
    role = get_user_role(user)

    if role == "admin":
        main_tabs = tabs
    else:
        main_tabs = [tab for tab in tabs if tab not in [
            "Admin Panel", "Suggestions", "Bulk Suggestions", "Audit Logs", "PDF Export"
        ]]

    if not main_tabs:
        main_tabs = tabs  # fallback

    if "top_nav" in st.session_state and st.session_state["top_nav"] in main_tabs:
        selected = st.radio(
            "Navigation",
            main_tabs,
            key="top_nav",
            horizontal=True,
            label_visibility="collapsed"
        )
    else:
        selected = st.radio(
            "Navigation",
            main_tabs,
            index=main_tabs.index(current_tab) if current_tab in main_tabs else 0,
            key="top_nav",
            horizontal=True,
            label_visibility="collapsed"
        )

    # Stylize the nav bar
    st.markdown(
        """
    <style>
    .stRadio > div {
        display: flex !important;
        gap: 0 !important;
        overflow: hidden !important;
        background: var(--primary-purple, #6C4AB6) !important;
        border-radius: var(--border-radius) !important;
    }
    .stRadio > div > label {
        flex: 1 1 auto !important;
        background: transparent !important;
        color: #ffffff !important;
        opacity: 0.85 !important;
        border: none !important;
        border-right: 1px solid rgba(255,255,255,0.4) !important;
        border-radius: 0 !important;
        padding: 0.5rem 1rem !important;
        font-weight: 500 !important;
        font-size: 0.9rem !important;
        cursor: pointer !important;
    }
    .stRadio > div > label:last-child {
        border-right: none !important;
    }
    .stRadio > div > label[aria-checked="true"] {
        background: var(--accent-purple, #563a9d) !important;
        color: #fff !important;
        opacity: 1 !important;
    }
    .stRadio input[type="radio"] { display: none !important; }
    </style>
    """,
        unsafe_allow_html=True,
    )

    return selected


# ----------------------------
# üéØ Leave Event Mode Button
# ----------------------------
def render_leave_event_button(location="main"):
    """Render leave event mode button"""
    from utils import get_active_event_id
    from events import deactivate_event_mode, update_event
    
    active_event_id = get_active_event_id()
    
    if active_event_id:
        button_key = f"leave_event_{location}_{active_event_id}"
        
        if location == "sidebar":
            if st.sidebar.button("üö™ Leave Event Mode", key=button_key):
                update_event(active_event_id, {"status": "planning"})
                deactivate_event_mode()
                st.rerun()
        else:
            if st.button("üö™ Leave Event Mode", key=button_key, help="Exit event mode"):
                update_event(active_event_id, {"status": "planning"})
                deactivate_event_mode()
                st.rerun()

# ----------------------------
# üìä Status Indicator
# ----------------------------
def render_status_indicator(status):
    """Render enhanced status indicator badge - NO BUTTON"""
    # Skip rendering planning status indicators
    if status.lower() == "planning":
        return
    
    status_lower = status.lower()
    st.markdown(f'<span class="status-{status_lower}">{status.title()}</span>', unsafe_allow_html=True)

# ----------------------------
# üé® Apply Theme
# ----------------------------
def apply_theme():
    """Apply the complete Mountain Medicine theme"""
    import time
    st.session_state["current_location"] = f"main_header_{int(time.time())}"

    inject_custom_css()
    # If the user is on a mobile device, load the mobile-specific theme
    from mobile_layout import mobile_layout
    if st.session_state.get("mobile_mode"):
        mobile_layout.apply_mobile_theme()
        try:
            from mobile_components import inject_mobile_styles
            inject_mobile_styles()
        except Exception:
            pass
    render_event_mode_indicator()

# ----------------------------
# üì± Mobile Responsive Container
# ----------------------------
def responsive_container():
    """Create a responsive container with mobile considerations"""
    container = st.container()
    
    # Add mobile-specific styling
    st.markdown("""
    <style>
    @media (max-width: 768px) {
        .main .block-container {
            padding-top: 1rem;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
        }
        
        /* Mobile navigation */
        .nav-tabs {
            flex-direction: row !important;
            flex-wrap: nowrap !important;
            overflow-x: auto !important;
            -webkit-overflow-scrolling: touch !important;
            gap: 0.5rem !important;
        }

        .nav-tab {
            flex: 0 0 auto !important;
        }
        
        /* Mobile event indicator */
        .event-mode-simple-indicator {
            position: relative !important;
            margin: 0.5rem 0 !important;
            font-size: 0.8rem !important;
        }
        
        /* Mobile chat window */
        .ai-chat-window {
            width: 100% !important;
            height: 80vh !important;
            bottom: 0 !important;
            right: 0 !important;
            left: 0 !important;
            border-radius: 12px 12px 0 0 !important;
        }
    }
    </style>
    """, unsafe_allow_html=True)
    
    return container

# ----------------------------
# üéØ Enhanced Sidebar Content
# ----------------------------
def render_enhanced_sidebar():
    """Render enhanced sidebar with admin tools"""
    user = session_get("user")
    if not user:
        return
    
    user_role = get_user_role(user)
    
    with st.sidebar:
        st.markdown("### üõ†Ô∏è Tools & Admin")
        
        # Leave Event Mode button in sidebar
        render_leave_event_button("sidebar")
        
        # Admin tools
        if user_role in ["admin", "manager"]:
            st.markdown("---")
            if st.button("üîê Admin Panel", key="sidebar_admin"):
                st.session_state["next_nav"] = "Admin Panel"
                st.rerun()
            
            if st.button("üìù Suggestions", key="sidebar_suggestions"):
                st.session_state["next_nav"] = "Suggestions"
                st.rerun()
            
            if st.button("üß† Bulk Suggestions", key="sidebar_bulk"):
                st.session_state["next_nav"] = "Bulk Suggestions"
                st.rerun()
            
            if st.button("üìú Audit Logs", key="sidebar_audit"):
                st.session_state["next_nav"] = "Audit Logs"
                st.rerun()
            
            if st.button("üìÑ PDF Export", key="sidebar_pdf"):
                st.session_state["next_nav"] = "PDF Export"
                st.rerun()
        
        # User info at bottom
        st.markdown("---")
        st.markdown(f"**User:** {user.get('name', 'Unknown')}")
        st.markdown(f"**Role:** {user_role}")

# ----------------------------
# üéØ Smart Context Buttons
# ----------------------------
def render_smart_event_button(event, user, key_suffix: str = ""):
    """Render context-aware event button with unique keys.

    Parameters
    ----------
    event : dict
        Event data dictionary containing at least an ``id`` field.
    user : dict
        The currently logged in user.
    key_suffix : str, optional
        Extra string appended to the widget key to guarantee uniqueness
        when this function is called multiple times within loops.
    """
    from utils import get_active_event_id
    from events import activate_event, deactivate_event_mode, update_event
    
    active_event_id = get_active_event_id()
    event_id = event["id"]
    
    button_key = f"smart_event_btn_{event_id}_{key_suffix}"
    
    if active_event_id == event_id:
        button_text = "üö™ Deactivate Event Mode"
        button_type = "secondary"
        action = "deactivate"
    elif active_event_id and active_event_id != event_id:
        button_text = "‚ö° Switch to This Event"
        button_type = "secondary"
        action = "switch"
    else:
        button_text = "üîò Activate Event Mode"
        button_type = "primary"
        action = "activate"
    
    if st.button(button_text, key=button_key, type=button_type, use_container_width=True):
        if action == "activate":
            update_event(event_id, {"status": "active"})
            activate_event(event_id)
            st.success(f"Event activated: {event.get('name', 'Unknown')}")
        elif action == "deactivate":
            st.session_state["recent_event_id"] = event_id
            update_event(event_id, {"status": "planning"})
            deactivate_event_mode()
            st.success("Event Mode deactivated")
        elif action == "switch":
            if active_event_id:
                st.session_state["recent_event_id"] = active_event_id
                update_event(active_event_id, {"status": "planning"})
            update_event(event_id, {"status": "active"})
            activate_event(event_id)
            st.success(f"Switched to: {event.get('name', 'Unknown')}")
        
        st.rerun()

# ----------------------------
# üìã Enhanced Info Cards
# ----------------------------
def render_info_card(title, content, icon="‚ÑπÔ∏è", card_type="info"):
    """Render styled information card"""
    card_colors = {
        "info": "#e3f2fd",
        "success": "#e8f5e8", 
        "warning": "#fff3e0",
        "error": "#ffebee"
    }
    
    bg_color = card_colors.get(card_type, card_colors["info"])
    
    st.markdown(f"""
    <div class="card" style="background-color: {bg_color};">
        <h4>{icon} {title}</h4>
        <p>{content}</p>
    </div>
    """, unsafe_allow_html=True)

# For backward compatibility
def render_floating_assistant():
    """Legacy function name"""

def show_event_mode_banner():
    """Empty function for compatibility"""
    pass

def render_event_toolbar(event_id, context="active"):
    """Render event toolbar"""
    event = get_event_by_id(event_id)
    if not event:
        return
    
    st.markdown(f"""
    <div class="event-toolbar">
        <strong>üé™ {event.get('name', 'Unnamed Event')}</strong>
        <small>{event.get('location', 'Unknown')} | {event.get('start_date', 'Unknown')}</small>
    </div>
    """, unsafe_allow_html=True)

# ----------------------------
# üîì Top-Right Login/Logout Button
# ----------------------------
def render_login_status_button():
    from auth import get_user
    user = get_user()
    if user:
        name = user.get("name") or user.get("email")
        st.markdown(f"""
        <div style='position: fixed; top: 1rem; right: 1rem; z-index: 999;'>
            <form action='/' method='post'>
                <button onclick=\"window.location.href='/?logout=true'\">üîì {name}</button>
            </form>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.markdown("""
        <div style='position: fixed; top: 1rem; right: 1rem; z-index: 999;'>
            <button onclick=\"window.location.href='/login'\">üîê Login</button>
        </div>
        """, unsafe_allow_html=True)


=== menu.txt ===
The menu subsystem manages menu items for each event. When a new event is
created the application stores a canonical `event_file` document under
`/events/{eventId}/meta/event_file`. This document now starts with an empty
`menu` list instead of pre‚Äëgenerated meal entries.

`menu_viewer_ui` provides the interface for viewing and editing an event‚Äôs
menu. Each existing item is editable in place and all changes are persisted to
the `event_file`. Adding a menu item immediately updates the stored JSON and
refreshes the interface so no separate save step is required.

`menu_editor_ui` (used less frequently) follows the same pattern‚Äîall menu
entries are written back to the event document automatically when the screen is
rendered.

These changes remove the previous logic that generated placeholder menu items
based on event duration and eliminate the explicit ‚ÄúSave Menu‚Äù buttons. Menu
items are stored per event and are displayed in the event planning dashboard
through the menu viewer component.


=== menu_editor.py ===
import streamlit as st
from firebase_init import db
from utils import get_active_event_id, generate_id
from auth import get_user_id
from datetime import datetime
import json

# ----------------------------
# üçΩÔ∏è Menu Editor (Single)
# ----------------------------

def menu_editor_ui(menu_id=None, prefill_data=None):
    """Edit or create a menu."""
    st.title("üçΩÔ∏è Menu Editor")

    user_id = get_user_id()
    doc_ref = None
    menu = None

    if menu_id:
        doc_ref = db.collection("menus").document(menu_id)
        doc = doc_ref.get()
        if not doc.exists:
            st.error("Menu not found.")
            return
        menu = doc.to_dict()
    elif prefill_data:
        menu = prefill_data
        st.info("üí° This form is pre-filled from parsed data.")
    else:
        st.warning("No menu to show.")
        return

    with st.form("edit_menu_form"):
        title = st.text_input("Menu Title", value=menu.get("title", ""))
        meals_json = st.text_area("Meals (JSON)", value=json.dumps(menu.get("meals", []), indent=2))
        tags = st.text_input("Tags (comma-separated)", value=", ".join(menu.get("tags", [])))

        submitted = st.form_submit_button("üíæ Save")
        if submitted:
            data = {
                "title": title,
                "meals": json.loads(meals_json) if meals_json else [],
                "tags": [t.strip() for t in tags.split(",") if t.strip()],
                "updated_at": datetime.utcnow(),
                "updated_by": user_id,
            }
            if doc_ref:
                doc_ref.update(data)
                st.success("‚úÖ Menu updated!")
            else:
                menu_id = generate_id("menu")
                data["created_at"] = datetime.utcnow()
                data["created_by"] = user_id
                db.collection("menus").document(menu_id).set(data)
                st.success("‚úÖ Menu saved!")

# ----------------------------
# üçΩÔ∏è Full Menu Editor UI
# ----------------------------

def full_menu_editor_ui(event_id=None, key_prefix: str = ""):
    """Full menu editor UI with scoped widget keys."""
    st.title("üçΩÔ∏è Event Menu Editor")

    # Shortcut to historical menu viewer
    if st.button("üìú View Historical Menus"):
        st.session_state["next_nav"] = "Historical Menus"

    user_id = get_user_id()
    if not event_id:
        event_id = get_active_event_id()
    if not event_id:
        st.warning("No active event selected.")
        return

    ref = db.collection("events").document(event_id).collection("meta").document("event_file")
    doc = ref.get()
    if not doc.exists:
        st.error("Menu not initialized.")
        return

    data = doc.to_dict()
    menu = data.get("menu", [])

    # Leave menu empty if none exists

    st.markdown("### üìã Current Menu")
    meal_colors = {
        "breakfast": "#ADD8E6",
        "lunch": "#FFD700",
        "dinner": "#90EE90",
        "note": "#D3D3D3"
    }

    # Fetch recipe options once for dropdowns including saved versions
    recipe_docs = list(db.collection("recipes").stream())
    recipe_options = [""]
    for doc in sorted(recipe_docs, key=lambda d: d.to_dict().get("name", "")):
        data = doc.to_dict() or {}
        base_name = data.get("name", "")
        if base_name:
            recipe_options.append(base_name)

        try:
            versions = doc.reference.collection("versions").stream()
        except Exception:
            versions = []
        for v in versions:
            vdata = v.to_dict() or {}
            label = vdata.get("special_version") or base_name
            recipe_options.append("    " + label)

    updated_menu = []
    for i, item in enumerate(menu):
        bg_color = meal_colors.get(item.get("meal", "note").lower(), "#f0f0f0")
        if item.get("recipe") and item.get("recipe") not in recipe_options:
            recipe_options.append(item.get("recipe"))
        with st.expander(
            f"{item.get('day', 'Day')} - {item.get('meal', 'Meal').capitalize()}",
            expanded=False,
        ):
            st.markdown(
                f"<div style='background-color:{bg_color};padding:1em;border-radius:8px;'>",
                unsafe_allow_html=True,
            )
            st.markdown(f"**Date:** {item.get('day','')}")
            st.markdown(f"**Meal:** {item.get('meal','').capitalize()}")
            recipe_name = st.selectbox(
                "Recipe",
                recipe_options,
                index=recipe_options.index(item.get("recipe", "")) if item.get("recipe", "") in recipe_options else 0,
                key=f"{key_prefix}recipe_{i}"
            )
            st.markdown("</div>", unsafe_allow_html=True)

            updated_menu.append({
                "day": item.get("day", ""),
                "meal": item.get("meal", ""),
                "recipe": recipe_name,
                "notes": "",
                "allergens": [],
                "tags": []
            })

    # Automatically persist changes without an explicit save button
    ref.update({
        "menu": updated_menu,
        "last_updated": datetime.utcnow(),
        "updated_by": user_id
    })
    st.success("‚úÖ Menu updated!")

# ----------------------------
# üîß Helpers
# ----------------------------

def _get_meal_index(meal: str):
    options = ["Breakfast", "Lunch", "Dinner", "Note"]
    return options.index(meal.capitalize()) if meal and meal.capitalize() in options else 0


=== menu_viewer.py ===
# menu_viewer.py

import streamlit as st
from auth import require_role, get_user_id
from utils import delete_button
from firebase_init import db
from utils import (
    get_active_event_id,
    get_active_event,
    get_event_by_id,
    format_day_label,
)
from datetime import datetime, timedelta
from event_file import get_event_file, update_event_file_field, initialize_event_file
from recipes import save_menu_to_firestore

MEAL_COLORS = {
    "breakfast": "#fff9c4",
    "lunch": "#d4edda",
    "dinner": "#d1e7ff",
    "after ceremony": "#ffe6f0",
}

DAY_COLORS = {
    "monday": "rgba(255,0,0,0.2)",
    "tuesday": "rgba(255,165,0,0.2)",
    "wednesday": "rgba(255,255,0,0.2)",
    "thursday": "rgba(0,255,0,0.2)",
    "friday": "rgba(0,255,255,0.2)",
    "saturday": "rgba(0,0,255,0.2)",
    "sunday": "rgba(255,0,255,0.2)",
}

# ----------------------------
# üìã View & Edit Menu (Structured)
# ----------------------------

@require_role("user")
def menu_viewer_ui(event_id=None, key_prefix: str = "", show_headers: bool = True):
    """Display and edit an event menu with scoped widget keys."""
    if show_headers:
        st.title("üçΩÔ∏è Event Menu")

    if not event_id:
        event_id = get_active_event_id()
    if not event_id:
        st.warning("No active event selected.")
        return

    user_id = get_user_id()

    # Initialize event file if not present
    initialize_event_file(event_id, user_id)

    event_file = get_event_file(event_id)
    menu = event_file.get("menu", [])

    # Build list of selectable dates between event start and end
    active_event = get_event_by_id(event_id) or get_active_event()
    date_options = []
    if active_event and active_event.get("start_date") and active_event.get("end_date"):
        try:
            start = datetime.fromisoformat(active_event["start_date"]).date()
            end = datetime.fromisoformat(active_event["end_date"]).date()
            current = start
            while current <= end:
                iso = current.isoformat()
                date_options.append(iso)
                current += timedelta(days=1)
        except Exception:
            pass

    if show_headers:
        st.markdown("### üßæ Current Menu")

    updated_menu = list(menu)

    grouped = {}
    for idx, item in enumerate(updated_menu):
        day = item.get("day", "")
        meal = item.get("meal", "")
        grouped.setdefault(day, {}).setdefault(meal, []).append((idx, item))

    for day, meal_map in sorted(grouped.items()):
        day_name = "Unknown"
        try:
            day_name = datetime.fromisoformat(day).strftime("%A")
        except Exception:
            pass
        day_color = DAY_COLORS.get(day_name.lower(), "rgba(0,0,0,0.1)")
        with st.expander(format_day_label(day), expanded=True):
            st.markdown(f"<div style='background-color:{day_color};padding:0.5em;border-radius:8px;'>", unsafe_allow_html=True)
            if delete_button("\U0001F5D1", key=f"del_day_{day}"):
                updated_menu = [m for m in updated_menu if m.get('day') != day]
                update_event_file_field(event_id, 'menu', updated_menu, user_id)
                st.rerun()
            for meal, items in meal_map.items():
                with st.expander(meal.capitalize(), expanded=False):
                    if delete_button("\U0001F5D1", key=f"del_meal_{day}_{meal}"):
                        updated_menu = [m for m in updated_menu if not (m.get('day') == day and m.get('meal') == meal)]
                        update_event_file_field(event_id, 'menu', updated_menu, user_id)
                        st.rerun()
                    for idx, itm in items:
                        color = MEAL_COLORS.get(meal.lower(), "#f0f0f0")
                        with st.expander(itm.get('name', 'Untitled'), expanded=False):
                            st.markdown(f"<div style='background-color:{color};padding:0.5em;border-radius:8px;'>", unsafe_allow_html=True)
                            st.write(itm.get('description', ''))
                            if delete_button("\U0001F5D1", key=f"del_dish_{idx}"):
                                updated_menu.pop(idx)
                                update_event_file_field(event_id, 'menu', updated_menu, user_id)
                                st.rerun()
                            st.markdown("</div>", unsafe_allow_html=True)
            st.markdown("</div>", unsafe_allow_html=True)

    with st.expander("‚ûï Add New Menu Item", expanded=False):
        form_key = f"{key_prefix}new_menu_item_form"
        with st.form(form_key, clear_on_submit=True):
            # Fetch recipe options for autocomplete dropdown
            recipe_docs = db.collection("recipes").stream()
            recipe_map: dict[str, list[str]] = {}
            for doc in recipe_docs:
                data = doc.to_dict() or {}
                base = data.get("name", "Unnamed Recipe")
                special = data.get("special_version", "").strip()
                recipe_map.setdefault(base, [])
                if special:
                    recipe_map[base].append(special)

            options = []
            for base in sorted(recipe_map.keys()):
                options.append({"label": base, "value": base})
                for sp in recipe_map[base]:
                    options.append({"label": f"   \u21b3 {sp}", "value": f"{base} - {sp}"})

            new_name_choice = st.selectbox(
                "New Dish Name",
                options,
                format_func=lambda x: x["label"],
                key=f"{key_prefix}new_name"
            )
            new_name = new_name_choice["value"]

            col_c, col_d = st.columns(2)
            with col_c:
                new_meal = st.selectbox(
                    "Meal",
                    ["Breakfast", "Lunch", "Dinner", "After Ceremony"],
                    key=f"{key_prefix}new_meal",
                )
            with col_d:
                new_day = st.selectbox(
                    "Date",
                    date_options or [""],
                    format_func=format_day_label,
                    key=f"{key_prefix}new_day",
                )
            new_description = st.text_area("New Description", key=f"{key_prefix}new_desc")

            submitted = st.form_submit_button("Add Menu Item")
            if submitted and new_name.strip():
                updated_menu.append({
                    "name": new_name.strip(),
                    "meal": new_meal,
                    "day": new_day,
                    "description": new_description.strip(),
                    "tags": []
                })
                update_event_file_field(event_id, "menu", updated_menu, user_id)
                st.success(f"‚úÖ Added: {new_name.strip()}")
                st.rerun()




# ----------------------------
# üîß Helpers
# ----------------------------

def _get_meal_index(meal: str):
    options = ["Breakfast", "Lunch", "Dinner", "After Ceremony"]
    return options.index(meal) if meal in options else 0





=== menus.py ===
from recipes import save_menu_to_firestore


=== mobile_components.py ===
import streamlit as st
from typing import List, Dict, Any, Optional, Callable
import json
from datetime import datetime

# -----------------------------
# Mobile Navigation Components
# -----------------------------

def render_mobile_header(title: str = "Mountain Medicine", show_menu: bool = True) -> None:
    """Render mobile-optimized header with hamburger menu"""
    header_html = f"""
    <div class="mobile-header">
        <div class="mobile-header-content">
            <div class="header-left">
                {f'<button class="mobile-menu-toggle" onclick="toggleMobileMenu()">‚ò∞</button>' if show_menu else ''}
                <h1 class="mobile-title">{title}</h1>
            </div>
            <div class="header-right">
                <button class="notification-button" onclick="toggleNotifications()">
                    <span class="notification-icon">üîî</span>
                    <span class="nav-badge" id="notification-count" style="display: none;">0</span>
                </button>
            </div>
        </div>
    </div>
    """
    st.markdown(header_html, unsafe_allow_html=True)

def render_bottom_navigation(active_tab: str = "dashboard") -> str:
    """Render mobile bottom navigation bar"""
    nav_items = [
        {"id": "dashboard", "icon": "üè†", "label": "Home", "path": "dashboard"},
        {"id": "events", "icon": "üìÖ", "label": "Events", "path": "events"},
        {"id": "recipes", "icon": "üìñ", "label": "Recipes", "path": "recipes"},
        {"id": "chat", "icon": "üí¨", "label": "Chat", "path": "assistant"},
        {"id": "more", "icon": "‚ãØ", "label": "More", "path": "more"}
    ]
    
    nav_html = '<div class="bottom-nav">'
    for item in nav_items:
        active_class = "active" if item["id"] == active_tab else ""
        nav_html += f"""
        <div class="bottom-nav-item {active_class}" data-path="{item['path']}" onclick="navigateToTab('{item['path']}')">
            <span class="bottom-nav-icon">{item['icon']}</span>
            <span class="bottom-nav-label">{item['label']}</span>
        </div>
        """
    nav_html += '</div>'
    
    st.markdown(nav_html, unsafe_allow_html=True)
    
    # JavaScript for navigation
    nav_js = """
    <script>
    function navigateToTab(path) {
        // Update Streamlit session state
        window.parent.postMessage({
            type: 'streamlit:setComponentValue',
            key: 'mobile_nav',
            value: path
        }, '*');
    }
    </script>
    """
    st.markdown(nav_js, unsafe_allow_html=True)
    
    # Handle navigation in Python
    if "mobile_nav" in st.session_state:
        return st.session_state.mobile_nav
    return active_tab

# -----------------------------
# Mobile Card Components
# -----------------------------

def mobile_card(
    title: str,
    content: str = "",
    icon: str = None,
    actions: List[Dict[str, Any]] = None,
    expandable: bool = False,
    key: str = None
) -> None:
    """Render a mobile-optimized card with touch interactions"""
    card_id = key or f"card_{hash(title)}"
    
    card_html = f"""
    <div class="mobile-card" id="{card_id}" data-expandable="{str(expandable).lower()}">
        <div class="card-header">
            {f'<span class="card-icon">{icon}</span>' if icon else ''}
            <h3 class="card-title">{title}</h3>
            {f'<span class="expand-icon">‚ñº</span>' if expandable else ''}
        </div>
        <div class="card-content">
            {content}
        </div>
    """
    
    if actions:
        card_html += '<div class="card-actions">'
        for action in actions:
            card_html += f"""
            <button class="card-action-button" onclick="{action.get('onclick', '')}">
                {action.get('icon', '')} {action.get('label', '')}
            </button>
            """
        card_html += '</div>'
    
    card_html += '</div>'
    
    st.markdown(card_html, unsafe_allow_html=True)

# -----------------------------
# Mobile List Components
# -----------------------------

def swipeable_list(
    items: List[Dict[str, Any]],
    on_swipe_left: Optional[Callable] = None,
    on_swipe_right: Optional[Callable] = None,
    key: str = "swipeable_list"
) -> None:
    """Render a list with swipeable items"""
    list_html = f'<div class="swipeable-list" id="{key}">'
    
    for i, item in enumerate(items):
        item_id = f"{key}_item_{i}"
        list_html += f"""
        <div class="swipeable-item" data-id="{item.get('id', i)}">
            <div class="item-content">
                <div class="item-icon">{item.get('icon', 'üìÑ')}</div>
                <div class="item-details">
                    <h4 class="item-title">{item.get('title', 'Untitled')}</h4>
                    <p class="item-subtitle">{item.get('subtitle', '')}</p>
                </div>
                <div class="item-meta">{item.get('meta', '')}</div>
            </div>
            <div class="swipe-actions">
                <button class="swipe-action edit" onclick="handleSwipeAction('edit', '{item.get('id', i)}')">
                    Edit
                </button>
                <button class="swipe-action delete" onclick="handleSwipeAction('delete', '{item.get('id', i)}')">
                    Delete
                </button>
            </div>
        </div>
        """
    
    list_html += '</div>'
    
    st.markdown(list_html, unsafe_allow_html=True)

def virtual_scroll_list(
    items: List[Dict[str, Any]],
    item_height: int = 80,
    container_height: int = 400,
    key: str = "virtual_list"
) -> None:
    """Render a virtual scrolling list for performance"""
    container_html = f"""
    <div class="virtual-scroll-container" 
         id="{key}" 
         style="height: {container_height}px; overflow-y: auto;">
        <div class="virtual-scroll-content" style="height: {len(items) * item_height}px;">
    """
    
    # Only render visible items initially
    visible_count = (container_height // item_height) + 2
    
    for i, item in enumerate(items[:visible_count]):
        container_html += f"""
        <div class="virtual-item" style="height: {item_height}px; transform: translateY({i * item_height}px);">
            {item.get('content', '')}
        </div>
        """
    
    container_html += '</div></div>'
    
    # Add JS for virtual scrolling
    js_code = f"""
    <script>
    const container = document.getElementById('{key}');
    const items = {json.dumps(items)};
    const itemHeight = {item_height};
    
    container.addEventListener('scroll', () => {{
        const scrollTop = container.scrollTop;
        const startIndex = Math.floor(scrollTop / itemHeight);
        const endIndex = startIndex + Math.ceil(container.clientHeight / itemHeight) + 1;
        
        // Update visible items
        updateVisibleItems(startIndex, endIndex);
    }});
    </script>
    """
    
    st.markdown(container_html + js_code, unsafe_allow_html=True)

# -----------------------------
# Mobile Form Components
# -----------------------------

def mobile_form(form_id: str = "mobile_form") -> None:
    """Create a mobile-optimized form context"""
    form_html = f"""
    <form class="mobile-form" id="{form_id}" onsubmit="handleFormSubmit(event, '{form_id}')">
    </form>
    """
    st.markdown(form_html, unsafe_allow_html=True)

def mobile_input(
    label: str,
    value: str = "",
    type: str = "text",
    placeholder: str = "",
    required: bool = False,
    voice_enabled: bool = True,
    key: str = None
) -> str:
    """Render a mobile-optimized input field"""
    input_id = key or f"input_{hash(label)}"
    
    # Build voice button separately to avoid backslash in f-string
    voice_button = ""
    if voice_enabled and type == "text":
        voice_button = f'<button type="button" class="voice-input-btn" onclick="startVoiceInput(\'{input_id}\')">üé§</button>'
    
    input_html = f"""
    <div class="mobile-input-group">
        <label for="{input_id}" class="mobile-label">{label}</label>
        <div class="input-wrapper">
            <input 
                type="{type}"
                id="{input_id}"
                name="{input_id}"
                class="mobile-input"
                value="{value}"
                placeholder="{placeholder}"
                {'required' if required else ''}
                autocomplete="on"
            />
            {voice_button}
        </div>
    </div>
    """
    
    st.markdown(input_html, unsafe_allow_html=True)
    
    # Return current value from session state
    return st.session_state.get(input_id, value)

def mobile_select(
    label: str,
    options: List[str],
    value: str = None,
    required: bool = False,
    key: str = None
) -> str:
    """Render a mobile-optimized select dropdown"""
    select_id = key or f"select_{hash(label)}"
    
    select_html = f"""
    <div class="mobile-select-group">
        <label for="{select_id}" class="mobile-label">{label}</label>
        <div class="mobile-select">
            <select 
                id="{select_id}"
                name="{select_id}"
                class="mobile-select-input"
                {'required' if required else ''}
            >
    """
    
    for option in options:
        selected = 'selected' if option == value else ''
        select_html += f'<option value="{option}" {selected}>{option}</option>'

    select_html += """
            </select>
        </div>
    </div>
    """

    select_js = f"""
    <script>
    const sel_{select_id} = document.getElementById('{select_id}');
    if (sel_{select_id}) {{
        sel_{select_id}.addEventListener('change', (e) => {{
            window.parent.postMessage({{
                type: 'streamlit:setComponentValue',
                key: '{select_id}',
                value: e.target.value
            }}, '*');
        }});
    }}
    </script>
    """

    st.markdown(select_html + select_js, unsafe_allow_html=True)

    return st.session_state.get(select_id, value or options[0] if options else "")

def mobile_button(
    label: str,
    type: str = "primary",
    icon: str = None,
    full_width: bool = True,
    onclick: str = None,
    key: str = None
) -> bool:
    """Render a mobile-optimized button"""
    button_id = key or f"btn_{hash(label)}"
    button_classes = f"touch-button {type} {'full-width' if full_width else ''}"
    
    # Build onclick handler separately
    onclick_handler = onclick or f"handleButtonClick('{button_id}')"
    
    # Build icon span separately
    icon_span = f'<span class="button-icon">{icon}</span>' if icon else ''
    
    button_html = f"""
    <button 
        type="button"
        id="{button_id}"
        class="{button_classes}"
        onclick="{onclick_handler}"
    >
        {icon_span}
        <span class="button-label">{label}</span>
    </button>
    """
    
    st.markdown(button_html, unsafe_allow_html=True)
    
    # Check if button was clicked
    return st.session_state.get(f"{button_id}_clicked", False)

# -----------------------------
# Mobile Data Display
# -----------------------------

def mobile_table(
    data: List[Dict[str, Any]],
    columns: List[Dict[str, str]],
    key: str = "mobile_table"
) -> None:
    """Render a mobile-optimized data table"""
    table_html = f'<div class="mobile-table" id="{key}">'
    
    for i, row in enumerate(data):
        table_html += f'<div class="mobile-table-row" data-index="{i}">'
        
        for col in columns:
            field = col.get('field')
            label = col.get('label', field)
            value = row.get(field, '')
            
            table_html += f"""
            <div class="mobile-table-cell">
                <div class="mobile-table-label">{label}</div>
                <div class="mobile-table-value">{value}</div>
            </div>
            """
        
        table_html += '</div>'
    
    table_html += '</div>'
    
    st.markdown(table_html, unsafe_allow_html=True)

def mobile_metric(
    label: str,
    value: Any,
    delta: Any = None,
    delta_color: str = "normal",
    icon: str = None
) -> None:
    """Render a mobile-optimized metric display"""
    metric_html = f"""
    <div class="mobile-metric">
        {f'<div class="metric-icon">{icon}</div>' if icon else ''}
        <div class="metric-content">
            <div class="metric-label">{label}</div>
            <div class="metric-value">{value}</div>
            {f'<div class="metric-delta {delta_color}">{delta}</div>' if delta else ''}
        </div>
    </div>
    """
    
    st.markdown(metric_html, unsafe_allow_html=True)

# -----------------------------
# Mobile Loading States
# -----------------------------

def mobile_skeleton(type: str = "card", count: int = 1) -> None:
    """Render skeleton loading states"""
    skeleton_html = ""
    
    for _ in range(count):
        if type == "card":
            skeleton_html += """
            <div class="skeleton skeleton-card">
                <div class="skeleton-header"></div>
                <div class="skeleton-text"></div>
                <div class="skeleton-text" style="width: 80%;"></div>
            </div>
            """
        elif type == "list":
            skeleton_html += """
            <div class="skeleton skeleton-list-item">
                <div class="skeleton-avatar"></div>
                <div class="skeleton-content">
                    <div class="skeleton-text"></div>
                    <div class="skeleton-text" style="width: 60%;"></div>
                </div>
            </div>
            """
    
    st.markdown(skeleton_html, unsafe_allow_html=True)

def mobile_spinner(text: str = "Loading...") -> None:
    """Render a mobile-optimized spinner"""
    spinner_html = f"""
    <div class="mobile-spinner-container">
        <div class="mobile-spinner"></div>
        <div class="spinner-text">{text}</div>
    </div>
    """
    
    st.markdown(spinner_html, unsafe_allow_html=True)

# -----------------------------
# Mobile Modal & Sheets
# -----------------------------

def mobile_bottom_sheet(
    content: str,
    title: str = "",
    show: bool = False,
    key: str = "bottom_sheet"
) -> None:
    """Render a mobile bottom sheet modal"""
    sheet_html = f"""
    <div class="mobile-modal-overlay {'active' if show else ''}" id="{key}_overlay" onclick="closeBottomSheet('{key}')">
        <div class="mobile-modal" id="{key}" onclick="event.stopPropagation()">
            <div class="modal-handle"></div>
            {f'<h3 class="modal-title">{title}</h3>' if title else ''}
            <div class="modal-content">
                {content}
            </div>
        </div>
    </div>
    """
    
    st.markdown(sheet_html, unsafe_allow_html=True)

def mobile_action_sheet(
    actions: List[Dict[str, Any]],
    show: bool = False,
    key: str = "action_sheet"
) -> Optional[str]:
    """Render a mobile action sheet"""
    sheet_html = f"""
    <div class="action-sheet-overlay {'active' if show else ''}" id="{key}_overlay">
        <div class="action-sheet" id="{key}">
    """
    
    for action in actions:
        sheet_html += f"""
        <button class="action-sheet-item {action.get('type', '')}" 
                onclick="handleActionSheet('{key}', '{action.get('id', '')}')">
            {f'<span class="action-icon">{action.get("icon", "")}</span>' if action.get('icon') else ''}
            <span class="action-label">{action.get('label', '')}</span>
        </button>
        """
    
    sheet_html += f"""
        <button class="action-sheet-item cancel" onclick="closeActionSheet('{key}')">
            Cancel
        </button>
    </div></div>
    """
    
    st.markdown(sheet_html, unsafe_allow_html=True)
    
    # Return selected action
    return st.session_state.get(f"{key}_selected")

# -----------------------------
# Mobile Search Component
# -----------------------------

def mobile_search_bar(
    placeholder: str = "Search...",
    value: str = "",
    suggestions: List[str] = None,
    key: str = "search"
) -> str:
    """Render a mobile-optimized search bar"""
    search_html = f"""
    <div class="mobile-search-container">
        <div class="search-input-wrapper">
            <span class="search-icon">üîç</span>
            <input 
                type="search"
                id="{key}"
                class="mobile-search-input"
                placeholder="{placeholder}"
                value="{value}"
                autocomplete="off"
                oninput="handleSearch(this.value, '{key}')"
            />
            <button class="search-clear" onclick="clearSearch('{key}')" style="{'display: block' if value else 'display: none'}">
                ‚úï
            </button>
        </div>
    """
    
    if suggestions:
        search_html += f'<div class="search-suggestions" id="{key}_suggestions">'
        for suggestion in suggestions[:5]:  # Limit to 5 suggestions
            search_html += f"""
            <div class="search-suggestion" onclick="selectSuggestion('{key}', '{suggestion}')">
                {suggestion}
            </div>
            """
        search_html += '</div>'
    
    search_html += '</div>'
    
    st.markdown(search_html, unsafe_allow_html=True)
    
    return st.session_state.get(key, value)

# -----------------------------
# Mobile Tab Component
# -----------------------------

def mobile_tabs(
    tabs: List[str],
    active_tab: int = 0,
    key: str = "tabs"
) -> int:
    """Render mobile-optimized tabs"""
    tabs_html = f'<div class="mobile-tabs" id="{key}">'
    
    for i, tab in enumerate(tabs):
        active_class = "active" if i == active_tab else ""
        tabs_html += f"""
        <button class="mobile-tab {active_class}" 
                onclick="selectTab('{key}', {i})">
            {tab}
        </button>
        """
    
    tabs_html += '</div>'
    
    st.markdown(tabs_html, unsafe_allow_html=True)
    
    return st.session_state.get(f"{key}_selected", active_tab)

# -----------------------------
# Mobile Floating Action Button
# -----------------------------

def mobile_fab(
    icon: str = "+",
    actions: List[Dict[str, Any]] = None,
    key: str = "fab"
) -> Optional[str]:
    """Render a floating action button with optional speed dial"""
    fab_html = f"""
    <div class="fab-container" id="{key}_container">
        <button class="fab" id="{key}" onclick="toggleFAB('{key}')">
            <span class="fab-icon">{icon}</span>
        </button>
    """
    
    if actions:
        fab_html += f'<div class="fab-actions" id="{key}_actions">'
        for i, action in enumerate(actions):
            fab_html += f"""
            <button class="fab-action" 
                    onclick="handleFABAction('{key}', '{action.get('id', i)}')"
                    style="--delay: {i * 0.05}s">
                <span class="fab-action-icon">{action.get('icon', '')}</span>
                <span class="fab-action-label">{action.get('label', '')}</span>
            </button>
            """
        fab_html += '</div>'
    
    fab_html += '</div>'
    
    st.markdown(fab_html, unsafe_allow_html=True)
    
    return st.session_state.get(f"{key}_action")

# -----------------------------
# Mobile Progress Components
# -----------------------------

def mobile_progress_bar(
    value: float,
    max_value: float = 100,
    label: str = "",
    color: str = "primary",
    key: str = "progress"
) -> None:
    """Render a mobile-optimized progress bar"""
    percentage = (value / max_value) * 100 if max_value > 0 else 0
    
    progress_html = f"""
    <div class="mobile-progress-container">
        {f'<div class="progress-label">{label}</div>' if label else ''}
        <div class="progress-bar-wrapper">
            <div class="progress-bar {color}" style="width: {percentage}%"></div>
        </div>
        <div class="progress-text">{value}/{max_value}</div>
    </div>
    """
    
    st.markdown(progress_html, unsafe_allow_html=True)

def mobile_circular_progress(
    value: float,
    max_value: float = 100,
    size: int = 80,
    label: str = "",
    key: str = "circular_progress"
) -> None:
    """Render a circular progress indicator"""
    percentage = (value / max_value) * 100 if max_value > 0 else 0
    circumference = 2 * 3.14159 * 35  # radius = 35
    offset = circumference - (percentage / 100) * circumference
    
    progress_html = f"""
    <div class="circular-progress" style="width: {size}px; height: {size}px;">
        <svg width="{size}" height="{size}">
            <circle cx="{size/2}" cy="{size/2}" r="35" stroke="#e0e0e0" stroke-width="8" fill="none"/>
            <circle cx="{size/2}" cy="{size/2}" r="35" 
                    stroke="var(--primary-purple)" 
                    stroke-width="8" 
                    fill="none"
                    stroke-dasharray="{circumference}"
                    stroke-dashoffset="{offset}"
                    transform="rotate(-90 {size/2} {size/2})"
                    style="transition: stroke-dashoffset 0.3s ease;"/>
        </svg>
        <div class="circular-progress-text">
            <span class="progress-value">{int(percentage)}%</span>
            {f'<span class="progress-label">{label}</span>' if label else ''}
        </div>
    </div>
    """
    
    st.markdown(progress_html, unsafe_allow_html=True)

# -----------------------------
# Mobile Toast Notifications
# -----------------------------

def mobile_toast(
    message: str,
    type: str = "info",
    duration: int = 3000,
    action: Dict[str, Any] = None
) -> None:
    """Show a mobile toast notification"""
    toast_id = f"toast_{hash(message)}_{datetime.now().timestamp()}"
    
    toast_html = f"""
    <div class="mobile-toast {type}" id="{toast_id}">
        <div class="toast-content">
            <span class="toast-message">{message}</span>
            {f'<button class="toast-action" onclick="{action.get("onclick", "")}">{action.get("label", "")}</button>' if action else ''}
        </div>
    </div>
    
    <script>
    setTimeout(() => {{
        const toast = document.getElementById('{toast_id}');
        if (toast) {{
            toast.classList.add('show');
            setTimeout(() => {{
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }}, {duration});
        }}
    }}, 100);
    </script>
    """
    
    st.markdown(toast_html, unsafe_allow_html=True)

# -----------------------------
# Mobile Utility Functions
# -----------------------------

from pathlib import Path

def inject_mobile_styles() -> None:
    """Inject all mobile-specific CSS"""
    css_path = Path(__file__).resolve().parent / "mobile_style.css"
    try:
        with open(css_path, "r") as f:
            mobile_css = f.read()
        st.markdown(f"<style>{mobile_css}</style>", unsafe_allow_html=True)
    except FileNotFoundError:
        st.warning("Mobile CSS file not found. Using fallback styles.")
        # Fallback minimal CSS
        fallback_css = """
        <style>
        .mobile-card { padding: 1rem; margin: 0.5rem 0; border: 1px solid #ddd; border-radius: 8px; }
        .touch-button { padding: 0.75rem 1.5rem; background: #6C4AB6; color: white; border: none; border-radius: 8px; cursor: pointer; }
        .mobile-input { width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; }
        </style>
        """
        st.markdown(fallback_css, unsafe_allow_html=True)

def inject_mobile_scripts() -> None:
    """Inject all mobile-specific JavaScript"""
    try:
        with open("mobile_interactions.js", "r") as f:
            mobile_js = f.read()
        st.markdown(f"<script>{mobile_js}</script>", unsafe_allow_html=True)
    except FileNotFoundError:
        st.warning("Mobile JavaScript file not found.")

def detect_mobile() -> bool:
    """Detect if user is on mobile device"""
    # This is a simplified detection - you might want to use more sophisticated methods
    user_agent = st.session_state.get("user_agent", "")
    mobile_keywords = ["Mobile", "Android", "iPhone", "iPad", "iPod", "BlackBerry", "IEMobile"]
    
    return any(keyword in user_agent for keyword in mobile_keywords)

def get_viewport_size() -> Dict[str, int]:
    """Get current viewport size"""
    # This would need JavaScript integration to get actual values
    return {
        "width": st.session_state.get("viewport_width", 375),
        "height": st.session_state.get("viewport_height", 667)
    }

def mobile_safe_columns(
    spec: List[int],
    gap: str = "medium"
) -> List:
    """Create columns that stack on mobile"""
    if detect_mobile():
        # Return single column on mobile
        return [st.container() for _ in spec]
    else:
        # Return regular columns on desktop
        return st.columns(spec, gap=gap)

# -----------------------------
# Mobile State Management
# -----------------------------

def save_mobile_state(key: str, value: Any) -> None:
    """Save state that persists across mobile app sessions"""
    st.session_state[key] = value
    
    # Also save to localStorage for PWA
    js_code = f"""
    <script>
    localStorage.setItem('{key}', JSON.stringify({json.dumps(value)});
    </script>
    """
    st.markdown(js_code, unsafe_allow_html=True)

def load_mobile_state(key: str, default: Any = None) -> Any:
    """Load persisted mobile state"""
    # First check session state
    if key in st.session_state:
        return st.session_state[key]
    
    # Then check localStorage
    js_code = f"""
    <script>
    const value = localStorage.getItem('{key}');
    if (value) {{
        window.parent.postMessage({{
            type: 'streamlit:setComponentValue',
            key: '{key}',
            value: JSON.parse(value)
        }}, '*');
    }}
    </script>
    """
    st.markdown(js_code, unsafe_allow_html=True)
    
    return st.session_state.get(key, default)

# -----------------------------
# Mobile Performance Monitoring
# -----------------------------

def track_mobile_performance(metric: str, value: float) -> None:
    """Track mobile performance metrics"""
    if "mobile_metrics" not in st.session_state:
        st.session_state.mobile_metrics = {}
    
    st.session_state.mobile_metrics[metric] = value
    
    # Send to analytics if available
    js_code = f"""
    <script>
    if (window.gtag) {{
        gtag('event', 'mobile_performance', {{
            metric: '{metric}',
            value: {value}
        }});
    }}
    </script>
    """
    st.markdown(js_code, unsafe_allow_html=True)

=== mobile_helpers.py ===
import streamlit as st
from mobile_components import mobile_safe_columns
from mobile_layout import mobile_layout

def safe_columns(spec, gap="small"):
    """Create columns that work on both desktop and mobile"""
    if st.session_state.get("mobile_mode", False):
        return mobile_safe_columns(spec, gap)
    else:
        return st.columns(spec, gap=gap)  # Removed the key parameter

def safe_dataframe(data, use_container_width=True, **kwargs):
    """Wrapper that automatically converts tables to cards on mobile"""
    if st.session_state.get("mobile_mode", False):
        mobile_layout.optimize_table_for_mobile(
            data if isinstance(data, list) else data.to_dict('records'),
            list(data.columns) if hasattr(data, 'columns') else list(data[0].keys())
        )
    else:
        st.dataframe(data, use_container_width=use_container_width, **kwargs)  # ‚úÖ FIXED: Direct st.dataframe call
        
def safe_file_uploader(label, **kwargs):
    """Wrapper that handles mobile file upload with camera"""
    if st.session_state.get("mobile_mode", False):
        return mobile_layout.handle_mobile_file_upload()
    else:
        return st.file_uploader(label, **kwargs)  # ‚úÖ FIXED: Direct st.file_uploader call


=== mobile_layout.py ===
import streamlit as st
from pathlib import Path
from typing import List, Dict, Any, Optional

# -----------------------------
# üì• Mobile File Uploader
# -----------------------------
def mobile_file_uploader(label: str, type: Optional[List[str]] = None) -> Optional[bytes]:
    uploaded_file = st.file_uploader(label, type=type)
    if uploaded_file:
        return uploaded_file.read()
    return None


# -----------------------------
# üìä Mobile Table Renderer
# -----------------------------
def mobile_table(data: List[Dict[str, Any]], columns: List[str]) -> None:
    for row in data:
        st.markdown("---")
        for col in columns:
            st.markdown(f"**{col}:** {row.get(col, '')}")


# -----------------------------
# üß± Mobile Columns Wrapper
# -----------------------------
def mobile_safe_columns(n: int):
    if n <= 1:
        return [st]
    return st.columns(n)


# -----------------------------
# üî£ Mobile Select Dropdown
# -----------------------------
def mobile_select(label: str, options: List[str], index: int = 0) -> str:
    return st.selectbox(label, options, index=index)


# -----------------------------
# üî§ Mobile Text Input
# -----------------------------
def mobile_input(label: str, value: str = "", placeholder: str = "", password: bool = False) -> str:
    if password:
        return st.text_input(label, value=value, placeholder=placeholder, type="password")
    return st.text_input(label, value=value, placeholder=placeholder)


# -----------------------------
# üîò Mobile Button
# -----------------------------
def mobile_button(label: str, key: Optional[str] = None) -> bool:
    return st.button(label, key=key)


# -----------------------------
# üßæ Mobile Card Renderer
# -----------------------------
def mobile_card(title: str, content: str = "", icon: Optional[str] = None):
    st.markdown("""
    <div style='border:1px solid #ccc; padding:12px; border-radius:10px; background:#fafafa;'>
    """, unsafe_allow_html=True)
    if icon:
        st.markdown(f"## {icon} {title}")
    else:
        st.markdown(f"### {title}")
    st.markdown(content)
    st.markdown("</div>", unsafe_allow_html=True)


# -----------------------------
# üìã Navigation Renderer
# -----------------------------
def render_mobile_navigation():
    nav_items = ["Dashboard", "Events", "Recipes", "Chat", "Profile"]
    selected = st.selectbox("üì± Mobile Nav", nav_items, key="mobile_nav")
    st.session_state.mobile_tab = selected
    return selected


# -----------------------------
# The MobileLayout class that app.py expects
# -----------------------------
class MobileLayout:
    def __init__(self):
        self._is_mobile = None
    
    @property
    def is_mobile(self):
        """Detect if user is on mobile device"""
        if self._is_mobile is None:
            # Simple detection - could be enhanced
            try:
                # Check if viewport is mobile-sized
                self._is_mobile = st.session_state.get("mobile_mode", False)
            except:
                self._is_mobile = False
        return self._is_mobile
    
    def apply_mobile_theme(self):
        """Apply mobile-specific CSS and optimizations"""
        css_file = Path(__file__).resolve().parent / "mobile_style.css"
        try:
            with open(css_file, "r") as f:
                mobile_css = f.read()
            st.markdown(f"<style>{mobile_css}</style>", unsafe_allow_html=True)
        except FileNotFoundError:
            # Fallback minimal CSS
            mobile_css = """
            <style>
            .main .block-container {
                padding: 0 1rem 1rem !important;
                max-width: 100% !important;
            }

            @media (max-width: 768px) {
                .stColumns {
                    flex-direction: column !important;
                }
                .stButton > button {
                    width: 100% !important;
                    min-height: 48px !important;
                }
            }
            </style>
            """
            st.markdown(mobile_css, unsafe_allow_html=True)
    
    def render_mobile_navigation(self):
        """Wrapper around the existing render_mobile_navigation function"""
        return render_mobile_navigation()
    
    def render_mobile_dashboard(self, user, event):
        """Render mobile-optimized dashboard"""
        st.title("üìä Dashboard")
        
        if event:
            mobile_card("üìÖ Active Event", f"**{event.get('name', 'Unnamed')}**", icon="üìÖ")
            
            col1, col2 = st.columns(2)
            with col1:
                st.metric("üë• Guests", event.get("guest_count", 0))
            with col2:
                st.metric("üßë‚Äçüç≥ Staff", event.get("staff_count", 0))
            
            st.markdown("### ‚úÖ Quick Tasks")
            st.checkbox("Setup complete")
            st.checkbox("Inventory checked")
        else:
            st.info("No active event selected.")


# Create the instance that app.py expects
mobile_layout = MobileLayout()


=== mobile_style.css ===
/* Complete Style Redesign - Mobile First, Clean & Modern */

/* -----------------------------
   CSS Variables & Base
----------------------------- */
:root {
    --primary-purple: #6C4AB6;
    --light-purple: #B8A4D4;
    --accent-purple: #563a9d;
    --dark-purple: #4a3280;
    --border-radius: 8px;
    --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
    --shadow-md: 0 4px 12px rgba(0,0,0,0.15);
    --shadow-lg: 0 8px 24px rgba(0,0,0,0.2);
    --transition: all 0.2s ease;
    
    /* Mobile-specific variables */
    --mobile-padding: 1rem;
    --touch-target-size: 44px;
}

* {
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
}

body, html {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background-color: #ffffff;
    color: #000000;
    scroll-behavior: smooth;
    margin: 0;
    padding: 0;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* -----------------------------
   MOBILE-FIRST BASE STYLES
----------------------------- */
.main .block-container {
    padding: 0 var(--mobile-padding) 1rem !important;
    max-width: 100% !important;
    margin-top: 0 !important;
}

/* -----------------------------
   TOUCH-FRIENDLY BUTTONS
----------------------------- */
button, .stButton > button {
    background-color: var(--primary-purple) !important;
    color: white !important;
    border: none !important;
    border-radius: var(--border-radius) !important;
    padding: 0.75rem 1.5rem !important;
    font-weight: 500 !important;
    transition: var(--transition) !important;
    cursor: pointer !important;
    min-height: var(--touch-target-size) !important;
    min-width: var(--touch-target-size) !important;
    font-size: 1rem !important;
    touch-action: manipulation !important;
    -webkit-user-select: none !important;
    user-select: none !important;
}

button:hover, .stButton > button:hover {
    background-color: var(--accent-purple) !important;
    transform: translateY(-1px) !important;
    box-shadow: var(--shadow-sm) !important;
}

button:active, .stButton > button:active {
    transform: translateY(0) !important;
    box-shadow: none !important;
}

/* -----------------------------
   MOBILE NAVIGATION
----------------------------- */
.nav-container {
    margin: 1rem 0 !important;
    padding: 0 !important;
    overflow-x: auto !important;
    -webkit-overflow-scrolling: touch !important;
}

.nav-tabs {
    display: flex !important;
    gap: 0.5rem !important;
    padding-bottom: 0.5rem !important;
    min-width: max-content !important;
}

.stRadio > div {
    display: flex !important;
    gap: 0 !important;
    overflow: hidden !important;
    background: var(--primary-purple, #6C4AB6) !important;
    border-radius: var(--border-radius) !important;
}

.stRadio > div > label {
    flex: 1 1 auto !important;
    background: transparent !important;
    color: #ffffff !important;
    opacity: 0.85 !important;
    border: none !important;
    border-right: 1px solid rgba(255, 255, 255, 0.4) !important;
    border-radius: 0 !important;
    padding: 0.75rem 1.25rem !important;
    font-weight: 500 !important;
    font-size: 0.9rem !important;
    cursor: pointer !important;
    transition: var(--transition) !important;
    min-height: var(--touch-target-size) !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    white-space: nowrap !important;
    list-style: none !important;
}
.stRadio > div > label:last-child {
    border-right: none !important;
}
.stRadio > div > label[aria-checked="true"] {
    background: var(--accent-purple, #563a9d) !important;
    color: #ffffff !important;
    opacity: 1 !important;
}
.stRadio > div > label[aria-checked="true"] * {
    color: #ffffff !important;
}

/* -----------------------------
   MOBILE CHAT INTERFACE
----------------------------- */
.ai-chat-window {
    position: fixed !important;
    bottom: 0 !important;
    left: 0 !important;
    right: 0 !important;
    width: 100% !important;
    height: 80vh !important;
    max-height: 600px !important;
    background: white !important;
    border-radius: 12px 12px 0 0 !important;
    box-shadow: var(--shadow-lg) !important;
    display: flex !important;
    flex-direction: column !important;
    overflow: hidden !important;
    z-index: 999 !important;
    transition: transform 0.3s ease !important;
}

.chat-header {
    background: var(--primary-purple) !important;
    color: white !important;
    padding: 1rem !important;
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    position: sticky !important;
    top: 0 !important;
    z-index: 10 !important;
}

.chat-body {
    flex: 1 !important;
    padding: 1rem !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch !important;
    background: #f8f9fa !important;
}

.chat-message {
    margin-bottom: 1rem !important;
    padding: 0.75rem !important;
    border-radius: 8px !important;
    max-width: 85% !important;
    word-wrap: break-word !important;
    animation: fadeIn 0.3s ease !important;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Chat input area */
.stTextInput input {
    border: 2px solid #e0e0e0 !important;
    border-radius: var(--border-radius) !important;
    padding: 0.75rem !important;
    font-size: 1rem !important;
    transition: var(--transition) !important;
}

.stTextInput input:focus {
    border-color: var(--primary-purple) !important;
    box-shadow: 0 0 0 3px rgba(108, 74, 182, 0.1) !important;
    outline: none !important;
}

/* -----------------------------
   MOBILE CARDS & CONTAINERS
----------------------------- */
.card {
    background: white !important;
    border-radius: 12px !important;
    padding: 1rem !important;
    box-shadow: var(--shadow-sm) !important;
    margin-bottom: 1rem !important;
    border: 1px solid #f0f0f0 !important;
}

/* Touch-friendly expanders */
.streamlit-expanderHeader {
    background: #f8f9fa !important;
    border-radius: var(--border-radius) !important;
    padding: 1rem !important;
    min-height: var(--touch-target-size) !important;
    cursor: pointer !important;
    -webkit-tap-highlight-color: rgba(108, 74, 182, 0.1) !important;
}

.streamlit-expanderHeader:active {
    background: #edeafa !important;
}

/* -----------------------------
   MOBILE FORMS
----------------------------- */
.stForm {
    padding: 1rem !important;
    background: #f8f9fa !important;
    border-radius: var(--border-radius) !important;
    margin-bottom: 1rem !important;
}

/* Touch-friendly select boxes */
.stSelectbox > div > div {
    min-height: var(--touch-target-size) !important;
    border: 2px solid #e0e0e0 !important;
    border-radius: var(--border-radius) !important;
    padding: 0.75rem !important;
    font-size: 1rem !important;
    color: #000000 !important;
}

/* Ensure select inputs and selected values use black text */
.stSelectbox div[data-baseweb="select"] input,
.stSelectbox div[data-baseweb="select"] span,
.stSelectbox div[data-baseweb="select"] div {
    color: #000 !important;
}

.stSelectbox div[data-baseweb="select"] input::placeholder {
    color: #6c757d !important;
}

/* Touch-friendly checkboxes */
.stCheckbox label {
    padding: 0.75rem 0 !important;
    cursor: pointer !important;
    display: flex !important;
    align-items: center !important;
    min-height: var(--touch-target-size) !important;
}

.stCheckbox input[type="checkbox"] {
    width: 24px !important;
    height: 24px !important;
    margin-right: 0.75rem !important;
}


/* -----------------------------
   MOBILE EVENT INDICATOR
----------------------------- */
.event-mode-simple-indicator {
    position: relative !important;
    margin: 0.5rem 0 1rem !important;
    background: var(--primary-purple) !important;
    color: white !important;
    padding: 0.75rem 1rem !important;
    border-radius: var(--border-radius) !important;
    font-size: 0.85rem !important;
    font-weight: 500 !important;
    text-align: center !important;
    box-shadow: var(--shadow-sm) !important;
}

/* -----------------------------
   MOBILE FLOATING CHAT BUTTON
----------------------------- */
.stButton:has([data-testid*="floating_chat_toggle"]) {
    position: fixed !important;
    bottom: 1.5rem !important;
    right: 1.5rem !important;
    z-index: 1000 !important;
    width: 60px !important;
    height: 60px !important;
}

.stButton:has([data-testid*="floating_chat_toggle"]) button {
    width: 60px !important;
    height: 60px !important;
    border-radius: 50% !important;
    font-size: 24px !important;
    padding: 0 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    box-shadow: 0 4px 12px rgba(108, 74, 182, 0.3) !important;
}

/* -----------------------------
   MOBILE-SPECIFIC UTILITIES
----------------------------- */
/* Swipeable lists */
.swipeable-list {
    overflow-x: auto !important;
    -webkit-overflow-scrolling: touch !important;
    scroll-snap-type: x mandatory !important;
}

.swipeable-list > * {
    scroll-snap-align: start !important;
}

/* Touch-friendly spacing */
.stColumns {
    gap: var(--mobile-padding) !important;
}

/* Responsive tables */
.dataframe {
    overflow-x: auto !important;
    -webkit-overflow-scrolling: touch !important;
    font-size: 0.875rem !important;
}

/* -----------------------------
   TABLET STYLES (768px+)
----------------------------- */
@media (min-width: 768px) {
    .main .block-container {
        padding: 1rem 2rem !important;
    }
    
    .ai-chat-window {
        position: fixed !important;
        bottom: 100px !important;
        right: 2rem !important;
        left: auto !important;
        width: 400px !important;
        height: 500px !important;
        border-radius: 12px !important;
    }
    
    .event-mode-simple-indicator {
        position: fixed !important;
        top: 1rem !important;
        right: 1rem !important;
        margin: 0 !important;
    }
    
    .nav-tabs {
        flex-wrap: wrap !important;
        overflow-x: visible !important;
    }
}

/* -----------------------------
   DESKTOP STYLES (1024px+)
----------------------------- */
@media (min-width: 1024px) {
    .main .block-container {
        padding: 2rem 4rem !important;
        max-width: 1200px !important;
        margin: 0 auto !important;
    }
    
    button, .stButton > button {
        padding: 0.5rem 1rem !important;
        font-size: 0.9rem !important;
    }
}

/* -----------------------------
   PERFORMANCE OPTIMIZATIONS
----------------------------- */
/* Reduce motion for users who prefer it */
@media (prefers-reduced-motion: reduce) {
    * {
        animation: none !important;
        transition: none !important;
    }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
    /* Add dark mode styles here if needed */
}

/* High contrast mode */
@media (prefers-contrast: high) {
    button, .stButton > button {
        border: 2px solid currentColor !important;
    }
}

/* -----------------------------
   OFFLINE INDICATOR
----------------------------- */
.offline-indicator {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    background: #ff6b6b !important;
    color: white !important;
    padding: 0.5rem !important;
    text-align: center !important;
    font-size: 0.875rem !important;
    z-index: 9999 !important;
    transform: translateY(-100%) !important;
    transition: transform 0.3s ease !important;
}

.offline-indicator.show {
    transform: translateY(0) !important;
}

/* -----------------------------
   LOADING STATES
----------------------------- */
.stSpinner {
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    min-height: 100px !important;
}

/* Custom loading animation */
@keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 1; }
    100% { opacity: 0.6; }
}

.loading {
    animation: pulse 1.5s ease-in-out infinite !important;
}


=== mobile_table.py ===
# mobile_table.py content


=== notifications.py ===
# notifications.py

import streamlit as st
from typing import List

# Don't create the client at import time - use a function instead
def get_db():
    """Get the Firestore database client"""
    try:
        return firestore.client()
    except Exception:
        # Firebase not initialized yet
        return None

# ----------------------------
# üîî Fetch User Notifications
# ----------------------------

def get_user_notifications(user_id: str) -> List[dict]:
    """Returns up to 10 recent notifications for a given user ID."""
    db = get_db()
    if not db:
        return []
        
    try:
        docs = db.collection("notifications") \
            .where("user_id", "==", user_id) \
            .order_by("timestamp", direction=firestore.Query.DESCENDING) \
            .limit(10) \
            .stream()
        return [doc.to_dict() | {"id": doc.id} for doc in docs]
    except Exception as e:
        st.error(f"‚ö†Ô∏è Failed to load notifications: {e}")
        return []

def get_suggestion_count() -> int:
    """Returns the count of pending suggestions."""
    db = get_db()
    if not db:
        return 0
        
    try:
        docs = db.collection("suggestions").where("status", "==", "pending").stream()
        return sum(1 for _ in docs)
    except Exception as e:
        st.error(f"‚ö†Ô∏è Could not count suggestions: {e}")
        return 0

# ----------------------------
# üß≠ Sidebar Notifications
# ----------------------------

def notifications_sidebar(user: dict) -> None:
    """Displays suggestion badge and recent notifications in sidebar."""
    if not user:
        return

    suggestion_count = get_suggestion_count()
    if suggestion_count > 0:
        st.sidebar.markdown(f"üî¥ **{suggestion_count} suggestion(s) pending**")

    with st.sidebar.expander("üîî Recent Notifications", expanded=False):
        notes = get_user_notifications(user["id"])
        if not notes:
            st.write("No notifications.")
        for n in notes:
            st.markdown(f"‚Ä¢ {n.get('message', 'No content')}")

# ----------------------------
# üöÄ Add Notification
# ----------------------------

def send_notification(message: str, user_id: str = None, role: str = None) -> None:
    """
    Sends a notification to a specific user or broadcast to all users of a role.

    Args:
        message: Message content
        user_id: Optional direct recipient
        role: Optional role filter (e.g., "admin")
    """
    db = get_db()
    if not db:
        st.error("‚ùå Database not available for notifications")
        return
        
    try:
        if user_id:
            db.collection("notifications").add({
                "user_id": user_id,
                "message": message,
                "timestamp": firestore.SERVER_TIMESTAMP
            })
        elif role:
            users = db.collection("users").where("role", "==", role).stream()
            for doc in users:
                db.collection("notifications").add({
                    "user_id": doc.id,
                    "message": message,
                    "timestamp": firestore.SERVER_TIMESTAMP
                })
    except Exception as e:
        st.error(f"‚ùå Could not send notification: {e}")


=== packages.txt ===
tesseract-ocr


=== packing.py ===
import streamlit as st
from firebase_admin import firestore
from utils import generate_id, get_scoped_query, is_event_scoped, get_event_scope_message, get_active_event_id, delete_button
from datetime import datetime

db = firestore.client()

# ----------------------------
# üì¶ Packing & Loading UI
# ----------------------------

def packing_ui():
    st.title("üì¶ Packing & Loading")
    
    # Show current scope
    st.info(get_event_scope_message())
    
    # Check if we're in event mode
    if not is_event_scoped():
        # Show all events' packing lists
        _show_all_events_packing()
    else:
        # Show specific event's packing list
        event_id = get_active_event_id()
        event = _get_event_info(event_id)
        if event:
            st.subheader(f"Packing for: {event.get('name', 'Unknown Event')}")
            _render_event_packing(event_id)
        else:
            st.error("Active event not found")

def _show_all_events_packing():
    """Show packing lists for all events"""
    # Get all non-deleted events
    try:
        events = db.collection("events").where("deleted", "==", False).order_by("start_date").stream()
        event_list = [doc.to_dict() | {"id": doc.id} for doc in events]
    except:
        event_list = []
    
    if not event_list:
        st.info("No events found. Create an event first!")
        return
    
    # Filter to show only upcoming or active events
    st.markdown("### Select an Event to View Packing List")
    
    # Event selector
    event_options = ["Select an event..."]
    event_mapping = {}
    
    for event in event_list:
        if event.get('status') != 'complete':  # Don't show completed events
            option = f"{event.get('name', 'Unnamed')} - {event.get('start_date', 'No date')}"
            event_options.append(option)
            event_mapping[option] = event['id']
    
    selected = st.selectbox("Choose Event", event_options)
    
    if selected != "Select an event...":
        event_id = event_mapping[selected]
        st.markdown("---")
        _render_event_packing(event_id)

def _render_event_packing(event_id):
    """Render packing lists for a specific event"""
    # Create tabs for different packing categories
    tab1, tab2, tab3, tab4 = st.tabs(["‚úÖ Tasks", "üîß Equipment", "üõí Groceries", "üìä Summary"])
    
    with tab1:
        _render_task_list(event_id)
    
    with tab2:
        _render_equipment_list(event_id)
    
    with tab3:
        _render_grocery_list(event_id)
    
    with tab4:
        _render_packing_summary(event_id)

# ----------------------------
# ‚úÖ Task Checklist
# ----------------------------

def _render_task_list(event_id):
    st.subheader("üìù Tasks")
    
    tasks_ref = db.collection("events").document(event_id).collection("tasks")
    tasks = [doc.to_dict() for doc in tasks_ref.stream()]
    
    # Group tasks by priority
    high_priority = [t for t in tasks if t.get('priority') == 'High']
    medium_priority = [t for t in tasks if t.get('priority') == 'Medium']
    low_priority = [t for t in tasks if t.get('priority') == 'Low']
    no_priority = [t for t in tasks if not t.get('priority')]
    
    # Display by priority
    if high_priority:
        st.markdown("#### üî¥ High Priority")
        for task in high_priority:
            _render_task_item(task, tasks_ref)
    
    if medium_priority:
        st.markdown("#### üü° Medium Priority")
        for task in medium_priority:
            _render_task_item(task, tasks_ref)
    
    if low_priority:
        st.markdown("#### üü¢ Low Priority")
        for task in low_priority:
            _render_task_item(task, tasks_ref)
    
    if no_priority:
        st.markdown("#### ‚ö™ Other Tasks")
        for task in no_priority:
            _render_task_item(task, tasks_ref)
    
    # Add new task
    st.markdown("---")
    with st.expander("‚ûï Add New Task"):
        with st.form(f"new_task_{event_id}"):
            col1, col2 = st.columns([3, 1])
            with col1:
                new_task = st.text_input("Task Description")
            with col2:
                priority = st.selectbox("Priority", ["High", "Medium", "Low"])
            
            if st.form_submit_button("Add Task"):
                if new_task:
                    tid = generate_id("task")
                    tasks_ref.document(tid).set({
                        "id": tid,
                        "label": new_task,
                        "priority": priority,
                        "done": False,
                        "created_at": datetime.utcnow()
                    })
                    st.success("Task added!")
                    st.rerun()

def _render_task_item(task, tasks_ref):
    """Render a single task item"""
    col1, col2 = st.columns([5, 1])
    
    with col1:
        checked = st.checkbox(
            task.get("label", "Unknown task"),
            value=task.get("done", False),
            key=f"task_{task['id']}"
        )
        if checked != task.get("done"):
            tasks_ref.document(task["id"]).update({"done": checked})
    
    with col2:
        if delete_button("üóëÔ∏è", key=f"del_task_{task['id']}"):
            tasks_ref.document(task["id"]).delete()
            st.rerun()

# ----------------------------
# üß∞ Equipment
# ----------------------------

def _render_equipment_list(event_id):
    st.subheader("üîß Equipment")
    
    items_ref = db.collection("events").document(event_id).collection("equipment")
    items = [doc.to_dict() for doc in items_ref.stream()]
    
    # Group by category
    categories = {}
    for item in items:
        cat = item.get('category', 'Other')
        if cat not in categories:
            categories[cat] = []
        categories[cat].append(item)
    
    # Display by category
    for category, cat_items in categories.items():
        st.markdown(f"#### {category}")
        for eq in cat_items:
            col1, col2, col3, col4 = st.columns([3, 1, 1, 1])
            
            with col1:
                st.write(f"‚Ä¢ {eq.get('name', 'Unknown')}")
            with col2:
                st.write(f"Qty: {eq.get('quantity', 1)}")
            with col3:
                packed = st.checkbox(
                    "Packed",
                    value=eq.get('packed', False),
                    key=f"eq_packed_{eq['id']}"
                )
                if packed != eq.get('packed'):
                    items_ref.document(eq['id']).update({"packed": packed})
            with col4:
                if delete_button("üóëÔ∏è", key=f"del_eq_{eq['id']}"):
                    items_ref.document(eq['id']).delete()
                    st.rerun()
    
    # Add new equipment
    st.markdown("---")
    with st.expander("‚ûï Add New Equipment"):
        with st.form(f"new_equipment_{event_id}"):
            col1, col2, col3 = st.columns([3, 1, 1])
            with col1:
                new_eq = st.text_input("Equipment Name")
            with col2:
                quantity = st.number_input("Quantity", min_value=1, value=1)
            with col3:
                category = st.selectbox("Category", ["Cooking", "Serving", "Storage", "Transport", "Safety", "Other"])
            
            if st.form_submit_button("Add Equipment"):
                if new_eq:
                    eid = generate_id("eq")
                    items_ref.document(eid).set({
                        "id": eid,
                        "name": new_eq,
                        "quantity": quantity,
                        "category": category,
                        "packed": False,
                        "created_at": datetime.utcnow()
                    })
                    st.success("Equipment added!")
                    st.rerun()

# ----------------------------
# ü•ï Grocery List
# ----------------------------

def _render_grocery_list(event_id):
    st.subheader("üõí Groceries")
    
    # Use shopping_items collection instead of groceries for consistency
    groc_ref = db.collection("events").document(event_id).collection("shopping_items")
    items = [doc.to_dict() for doc in groc_ref.stream()]
    
    # Group by category
    categories = {}
    for item in items:
        cat = item.get('category', 'Other')
        if cat not in categories:
            categories[cat] = []
        categories[cat].append(item)
    
    # Display by category
    for category, cat_items in categories.items():
        st.markdown(f"#### {category}")
        for g in cat_items:
            col1, col2, col3, col4 = st.columns([3, 1, 1, 1])
            
            with col1:
                st.write(f"‚Ä¢ {g.get('name', 'Unknown')}")
            with col2:
                qty_text = f"{g.get('quantity', '')} {g.get('unit', '')}".strip()
                st.write(qty_text if qty_text else "-")
            with col3:
                checked = st.checkbox(
                    "Got it",
                    value=g.get('purchased', False),
                    key=f"groc_{g['id']}"
                )
                if checked != g.get('purchased'):
                    groc_ref.document(g['id']).update({"purchased": checked})
            with col4:
                if delete_button("üóëÔ∏è", key=f"del_groc_{g['id']}"):
                    groc_ref.document(g['id']).delete()
                    st.rerun()
    
    # Add new grocery item
    st.markdown("---")
    with st.expander("‚ûï Add New Grocery Item"):
        with st.form(f"new_grocery_{event_id}"):
            col1, col2, col3 = st.columns([3, 1, 1])
            with col1:
                new_groc = st.text_input("Item Name")
            with col2:
                quantity = st.text_input("Quantity")
            with col3:
                unit = st.selectbox("Unit", ["", "lbs", "kg", "oz", "cups", "pieces", "dozen", "cases"])
            
            category = st.selectbox("Category", ["Produce", "Protein", "Dairy", "Dry Goods", "Beverages", "Supplies", "Other"])
            
            if st.form_submit_button("Add Item"):
                if new_groc:
                    gid = generate_id("shop")
                    groc_ref.document(gid).set({
                        "id": gid,
                        "name": new_groc,
                        "quantity": quantity,
                        "unit": unit,
                        "category": category,
                        "purchased": False,
                        "created_at": datetime.utcnow()
                    })
                    st.success("Item added!")
                    st.rerun()

# ----------------------------
# üìä Packing Summary
# ----------------------------

def _render_packing_summary(event_id):
    st.subheader("üìä Packing Summary")
    
    # Get all data
    tasks_ref = db.collection("events").document(event_id).collection("tasks")
    equipment_ref = db.collection("events").document(event_id).collection("equipment")
    shopping_ref = db.collection("events").document(event_id).collection("shopping_items")
    
    tasks = [doc.to_dict() for doc in tasks_ref.stream()]
    equipment = [doc.to_dict() for doc in equipment_ref.stream()]
    shopping = [doc.to_dict() for doc in shopping_ref.stream()]
    
    # Calculate completion percentages
    tasks_done = len([t for t in tasks if t.get('done')])
    tasks_total = len(tasks)
    tasks_pct = (tasks_done / tasks_total * 100) if tasks_total > 0 else 0
    
    equipment_packed = len([e for e in equipment if e.get('packed')])
    equipment_total = len(equipment)
    equipment_pct = (equipment_packed / equipment_total * 100) if equipment_total > 0 else 0
    
    shopping_done = len([s for s in shopping if s.get('purchased')])
    shopping_total = len(shopping)
    shopping_pct = (shopping_done / shopping_total * 100) if shopping_total > 0 else 0
    
    # Display metrics
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric("Tasks Complete", f"{tasks_done}/{tasks_total}", f"{tasks_pct:.0f}%")
        if tasks_pct < 100 and tasks_total > 0:
            st.progress(tasks_pct / 100)
    
    with col2:
        st.metric("Equipment Packed", f"{equipment_packed}/{equipment_total}", f"{equipment_pct:.0f}%")
        if equipment_pct < 100 and equipment_total > 0:
            st.progress(equipment_pct / 100)
    
    with col3:
        st.metric("Shopping Done", f"{shopping_done}/{shopping_total}", f"{shopping_pct:.0f}%")
        if shopping_pct < 100 and shopping_total > 0:
            st.progress(shopping_pct / 100)
    
    # Overall readiness
    overall_pct = (tasks_pct + equipment_pct + shopping_pct) / 3
    
    st.markdown("---")
    st.markdown("### Overall Readiness")
    st.progress(overall_pct / 100)
    
    if overall_pct == 100:
        st.success("üéâ Everything is ready! You're all set for the event.")
    elif overall_pct >= 75:
        st.info("üì¶ Almost there! Just a few more items to complete.")
    elif overall_pct >= 50:
        st.warning("‚ö° Halfway done. Keep up the momentum!")
    else:
        st.warning("üöß Still lots to do. Focus on high-priority items first.")
    
    # Export checklist button
    if st.button("üìÑ Export Packing Checklist"):
        _export_packing_checklist(event_id, tasks, equipment, shopping)

def _export_packing_checklist(event_id, tasks, equipment, shopping):
    """Generate a printable packing checklist"""
    # This would generate a PDF or text file
    st.info("Export functionality coming soon!")

# ----------------------------
# üîß Helper Functions
# ----------------------------

def _get_event_info(event_id):
    """Get event information"""
    try:
        doc = db.collection("events").document(event_id).get()
        if doc.exists:
            return doc.to_dict()
    except:
        pass
    return None


=== pdf_export.py ===
# pdf_export.py

import streamlit as st
from fpdf import FPDF
from firebase_init import get_db
from datetime import datetime
from utils import format_date
import os
from auth import require_login

db = get_db()

# ----------------------------
# üìÑ Generate Event Summary PDF
# ----------------------------

def generate_event_summary_pdf(event_id: str) -> None:
    """Generates a post-event summary PDF for the given event."""
    event = get_db().collection("events").document(event_id).get().to_dict()
    if not event:
        st.error("Event not found.")
        return

    summary = event.get("post_event_summary")
    if not summary:
        st.error("No post-event summary available.")
        return

    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    pdf.set_title(f"Event Summary: {event.get('name')}")

    def add_section(title: str, body: str) -> None:
        pdf.set_font("Arial", 'B', 14)
        pdf.cell(200, 10, txt=title, ln=1)
        pdf.set_font("Arial", size=12)
        pdf.multi_cell(0, 10, txt=body or "N/A")
        pdf.ln(5)

    # Title
    pdf.set_font("Arial", 'B', 16)
    pdf.cell(200, 10, txt=f"üìã Event Summary: {event.get('name')}", ln=1, align='L')
    pdf.set_font("Arial", size=12)
    pdf.cell(200, 10, txt=f"Date: {format_date(event.get('date'))} | Location: {event.get('location')}", ln=1)
    pdf.ln(5)

    # Sections
    pop_data = summary.get("menu_popularity", {})
    if pop_data:
        pop_text = "\n".join([f"{k}: {v}/5" for k, v in pop_data.items()])
        add_section("Menu Popularity", pop_text)

    add_section("Leftovers / Overages", summary.get("leftovers_notes", ""))
    add_section("Timing Issues", summary.get("timing_issues", ""))
    add_section("Improvements", summary.get("improvements", ""))
    add_section("Forgotten / Missing Items", summary.get("forgotten_items", ""))

    pdf.ln(10)
    pdf.set_font("Arial", 'I', 10)
    pdf.cell(200, 10, txt=f"Generated by Mountain Medicine ‚Äî {datetime.utcnow().isoformat()} UTC", ln=1)

    filename = f"event_summary_{event_id}.pdf"
    filepath = os.path.join("/tmp", filename)
    pdf.output(filepath)

    with open(filepath, "rb") as f:
        st.download_button("üì• Download PDF", f, file_name=filename)

    os.remove(filepath)

# ----------------------------
# üìÑ Full-Page UI for app.py
# ----------------------------

def pdf_export_ui(user=None):
    st.title("üìÑ Export Post-Event Summary")

    event_id = st.text_input("Enter Event ID")
    if event_id and st.button("Generate PDF"):
        generate_event_summary_pdf(event_id)


=== post_event.py ===
# post_event.py

import streamlit as st
from firebase_init import get_db
from auth import require_role
from utils import format_date, get_scoped_query, is_event_scoped, get_event_scope_message, get_active_event_id
from datetime import datetime
from google.cloud.firestore_v1.base_query import FieldFilter

db = get_db()

# ----------------------------
# üìã Post-Event Interview
# ----------------------------

@require_role("manager")
def post_event_ui(user: dict) -> None:
    """Displays the post-event survey with proper event scoping."""
    st.title("üìã Post-Event Interview")
    
    # Show current scope
    st.info(get_event_scope_message())
    
    # Get completed events
    if is_event_scoped():
        # Check if the active event is complete
        active_event_id = get_active_event_id()
        event_doc = get_db().collection("events").document(active_event_id).get()
        
        if not event_doc.exists:
            st.error("Active event not found")
            return
            
        event_data = event_doc.to_dict()
        
        if event_data.get("status") != "complete":
            st.warning("Post-event feedback is only available for completed events. Please complete the event first.")
            return
        
        # Show feedback form for the active event
        _render_post_event_form(active_event_id, event_data, user)
    
    else:
        # Show list of completed events to review
        _show_completed_events_list(user)

def _show_completed_events_list(user: dict) -> None:
    """Show list of completed events that need post-event review"""
    st.subheader("Select a Completed Event to Review")
    
    # Get all completed events
    try:
        completed_events = get_db().collection("events").where(filter=FieldFilter("status", "==", "complete")).where(filter=FieldFilter("deleted", "==", False)).stream()
        events_list = [doc.to_dict() | {"id": doc.id} for doc in completed_events]
    except:
        events_list = []
    
    if not events_list:
        st.info("No completed events found. Complete an event first to provide post-event feedback.")
        return
    
    # Separate events with and without feedback
    events_with_feedback = []
    events_without_feedback = []
    
    for event in events_list:
        if event.get("post_event_summary"):
            events_with_feedback.append(event)
        else:
            events_without_feedback.append(event)
    
    # Show events needing feedback first
    if events_without_feedback:
        st.markdown("### üî¥ Events Needing Feedback")
        for event in events_without_feedback:
            with st.expander(f"{event.get('name', 'Unnamed')} - {format_date(event.get('end_date'))}"):
                st.write(f"**Location:** {event.get('location', 'Unknown')}")
                st.write(f"**Guests:** {event.get('guest_count', 0)}")
                
                if st.button(f"Provide Feedback", key=f"feedback_{event['id']}"):
                    st.session_state["post_event_selected"] = event['id']
    
    # Show events with existing feedback
    if events_with_feedback:
        st.markdown("### ‚úÖ Events with Feedback")
        for event in events_with_feedback:
            with st.expander(f"{event.get('name', 'Unnamed')} - {format_date(event.get('end_date'))}"):
                st.write(f"**Location:** {event.get('location', 'Unknown')}")
                st.write(f"**Guests:** {event.get('guest_count', 0)}")
                
                summary = event.get('post_event_summary', {})
                st.write(f"**Feedback provided by:** {summary.get('completed_by', 'Unknown')}")
                st.write(f"**Date:** {format_date(summary.get('completed_at'))}")
                
                col1, col2 = st.columns(2)
                with col1:
                    if st.button(f"View/Edit Feedback", key=f"edit_{event['id']}"):
                        st.session_state["post_event_selected"] = event['id']
                
                with col2:
                    if st.button(f"üìÑ Download PDF", key=f"pdf_{event['id']}"):
                        from pdf_export import generate_event_summary_pdf
                        generate_event_summary_pdf(event['id'])
    
    # Check if an event was selected
    if "post_event_selected" in st.session_state:
        selected_id = st.session_state["post_event_selected"]
        selected_doc = get_db().collection("events").document(selected_id).get()
        
        if selected_doc.exists:
            st.markdown("---")
            _render_post_event_form(selected_id, selected_doc.to_dict(), user)

def _render_post_event_form(event_id: str, event_data: dict, user: dict) -> None:
    """Render the post-event feedback form"""
    st.markdown(f"## Feedback for: {event_data.get('name', 'Unnamed Event')}")
    st.caption(f"Event Date: {format_date(event_data.get('end_date'))} | Location: {event_data.get('location', 'Unknown')}")
    
    # Get existing summary if any
    existing_summary = event_data.get("post_event_summary", {})
    
    # Create form
    with st.form("post_event_form"):
        # Menu Popularity Ratings
        st.markdown("### üçΩÔ∏è Menu Popularity")
        st.caption("Rate each menu item from 1 (poor) to 5 (excellent)")
        
        menus = get_db().collection("menus").where("event_id", "==", event_id).stream()
        menu_popularity = {}
        
        for menu in menus:
            m = menu.to_dict()
            existing_rating = existing_summary.get("menu_popularity", {}).get(m["id"], 3)
            rating = st.slider(
                f"{m.get('name', 'Unnamed Item')} ({m.get('category', 'Unknown')})",
                1, 5, existing_rating,
                key=f"rating_{m['id']}"
            )
            menu_popularity[m["id"]] = rating
        
        # Feedback Sections
        st.markdown("### ü•° Leftovers or Overages")
        leftovers_notes = st.text_area(
            "Notes on leftover food, overages, or waste:",
            value=existing_summary.get("leftovers_notes", ""),
            help="What items had too much? What ran out? Estimate quantities if possible."
        )
        
        st.markdown("### ‚è±Ô∏è Timing Issues")
        timing_issues = st.text_area(
            "Notes about prep or service timing:",
            value=existing_summary.get("timing_issues", ""),
            help="What took longer than expected? What could be prepped earlier?"
        )
        
        st.markdown("### üõ†Ô∏è Issues & Improvements")
        improvements = st.text_area(
            "Problems encountered and ideas for improvement:",
            value=existing_summary.get("improvements", ""),
            help="Equipment issues, workflow problems, or process improvements"
        )
        
        st.markdown("### üßæ Forgotten or Missing Items")
        forgotten_items = st.text_area(
            "Items that were forgotten or should be added next time:",
            value=existing_summary.get("forgotten_items", ""),
            help="What did you wish you had? What was missing from lists?"
        )
        
        st.markdown("### üí∞ Financial Summary")
        col1, col2 = st.columns(2)
        with col1:
            total_cost = st.number_input(
                "Total Event Cost ($)",
                min_value=0.0,
                value=float(existing_summary.get("total_cost", 0.0)),
                step=10.0
            )
        with col2:
            cost_per_person = total_cost / event_data.get("guest_count", 1) if event_data.get("guest_count", 0) > 0 else 0
            st.metric("Cost Per Person", f"${cost_per_person:.2f}")
        
        st.markdown("### ‚≠ê Overall Rating")
        overall_rating = st.select_slider(
            "How would you rate the overall event execution?",
            options=["Poor", "Fair", "Good", "Very Good", "Excellent"],
            value=existing_summary.get("overall_rating", "Good")
        )
        
        # Additional notes
        st.markdown("### üìù Additional Notes")
        additional_notes = st.text_area(
            "Any other observations or notes:",
            value=existing_summary.get("additional_notes", ""),
            help="Weather issues, guest feedback, special moments, etc."
        )
        
        # Submit button
        submitted = st.form_submit_button("üíæ Save Post-Event Summary", type="primary")
        
        if submitted:
            try:
                # Prepare summary data
                summary_data = {
                    "menu_popularity": menu_popularity,
                    "leftovers_notes": leftovers_notes,
                    "timing_issues": timing_issues,
                    "improvements": improvements,
                    "forgotten_items": forgotten_items,
                    "total_cost": total_cost,
                    "overall_rating": overall_rating,
                    "additional_notes": additional_notes,
                    "completed_by": user["id"],
                    "completed_at": datetime.utcnow(),
                }
                
                # Update event document
                get_db().collection("events").document(event_id).update({
                    "post_event_summary": summary_data
                })
                
                st.success("‚úÖ Post-event summary saved successfully!")
                
                # Generate PDF
                col1, col2 = st.columns(2)
                with col1:
                    if st.button("üìÑ Generate PDF Summary"):
                        from pdf_export import generate_event_summary_pdf
                        generate_event_summary_pdf(event_id)
                
                with col2:
                    if st.button("üîÑ Continue to Another Event"):
                        if "post_event_selected" in st.session_state:
                            del st.session_state["post_event_selected"]
                
            except Exception as e:
                st.error(f"‚ùå Failed to save post-event summary: {e}")

# ----------------------------
# üìä Post-Event Analytics
# ----------------------------

def show_post_event_analytics():
    """Show analytics across all post-event summaries"""
    st.subheader("üìä Post-Event Analytics")
    
    # Get all events with post-event summaries
    try:
        events_with_feedback = []
        all_events = get_db().collection("events").where("deleted", "==", False).stream()
        
        for event_doc in all_events:
            event_data = event_doc.to_dict()
            if event_data.get("post_event_summary"):
                events_with_feedback.append(event_data)
        
        if not events_with_feedback:
            st.info("No post-event feedback available yet.")
            return
        
        # Calculate metrics
        total_events = len(events_with_feedback)
        
        # Average costs
        total_costs = [e.get("post_event_summary", {}).get("total_cost", 0) for e in events_with_feedback]
        avg_cost = sum(total_costs) / len(total_costs) if total_costs else 0
        
        # Overall ratings distribution
        ratings = [e.get("post_event_summary", {}).get("overall_rating", "Good") for e in events_with_feedback]
        rating_counts = {}
        for rating in ratings:
            rating_counts[rating] = rating_counts.get(rating, 0) + 1
        
        # Display metrics
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Events Reviewed", total_events)
        
        with col2:
            st.metric("Average Event Cost", f"${avg_cost:,.2f}")
        
        with col3:
            most_common_rating = max(rating_counts.items(), key=lambda x: x[1])[0] if rating_counts else "N/A"
            st.metric("Most Common Rating", most_common_rating)
        
        # Show rating distribution
        if rating_counts:
            st.markdown("#### Rating Distribution")
            for rating in ["Poor", "Fair", "Good", "Very Good", "Excellent"]:
                count = rating_counts.get(rating, 0)
                percentage = (count / total_events) * 100 if total_events > 0 else 0
                st.write(f"**{rating}:** {count} events ({percentage:.1f}%)")
        
        # Common issues
        st.markdown("#### Common Issues Mentioned")
        all_issues = []
        for event in events_with_feedback:
            summary = event.get("post_event_summary", {})
            if summary.get("improvements"):
                all_issues.append(summary["improvements"])
            if summary.get("timing_issues"):
                all_issues.append(summary["timing_issues"])
        
        if all_issues:
            # This could be enhanced with text analysis
            st.info(f"Found {len(all_issues)} improvement notes across all events")
        
    except Exception as e:
        st.error(f"Could not load analytics: {e}")


=== profile.py ===
import streamlit as st
from auth import load_user_session, get_user_id, get_user_role
from firebase_admin import firestore

db = firestore.client()
COLLECTION_USERS = "users"
COLLECTION_EVENTS = "events"
COLLECTION_RECIPES = "recipes"

# ----------------------------
# üë§ Profile Page
# ----------------------------

def profile_page():
    user = load_user_session()
    if not user:
        st.warning("Please log in to view your profile.")
        return

    user_id = get_user_id(user)
    role = get_user_role(user)

    st.title("üë§ Your Profile")

    # Load user doc
    user_doc = db.collection(COLLECTION_USERS).document(user_id).get()
    profile = user_doc.to_dict() if user_doc.exists else {}

    # Sidebar
    with st.sidebar:
        st.image("https://www.gravatar.com/avatar?d=identicon", width=100)  # Optional: support real profile images
        st.markdown(f"**{profile.get('name', 'Unknown')}**")
        st.caption(f"{profile.get('email', '')}")
        st.caption(f"Role: `{role}`")

    # Editable Bio Section
    st.subheader("üìù Bio")
    bio = st.text_area("Tell us a bit about yourself", value=profile.get("bio", ""))
    if st.button("Update Bio"):
        db.collection(COLLECTION_USERS).document(user_id).update({"bio": bio})
        st.success("‚úÖ Bio updated.")

    # Participation Analytics
    st.subheader("üìä Your Activity")

    # Events
    created = db.collection(COLLECTION_EVENTS).where("created_by", "==", user_id).stream()
    created_events = [doc.to_dict() for doc in created]

    participated = db.collection(COLLECTION_EVENTS).where("participants", "array_contains", user_id).stream()
    participated_events = [doc.to_dict() for doc in participated]

    recipes = db.collection(COLLECTION_RECIPES).where("author_id", "==", user_id).stream()
    recipe_count = len(list(recipes))

    st.metric("Events Hosted", len(created_events))
    st.metric("Events Participated", len(participated_events))
    st.metric("Recipes Contributed", recipe_count)
    st.metric("Estimated Hours Worked", len(participated_events) * 4)  # placeholder logic

    st.markdown("---")
    st.info("More profile features coming soon, including profile pictures, preferences, and badges.")


=== public/404.html ===
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Page Not Found</title>

    <style media="screen">
      body { background: #ECEFF1; color: rgba(0,0,0,0.87); font-family: Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; }
      #message { background: white; max-width: 360px; margin: 100px auto 16px; padding: 32px 24px 16px; border-radius: 3px; }
      #message h3 { color: #888; font-weight: normal; font-size: 16px; margin: 16px 0 12px; }
      #message h2 { color: #ffa100; font-weight: bold; font-size: 16px; margin: 0 0 8px; }
      #message h1 { font-size: 22px; font-weight: 300; color: rgba(0,0,0,0.6); margin: 0 0 16px;}
      #message p { line-height: 140%; margin: 16px 0 24px; font-size: 14px; }
      #message a { display: block; text-align: center; background: #039be5; text-transform: uppercase; text-decoration: none; color: white; padding: 16px; border-radius: 4px; }
      #message, #message a { box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); }
      #load { color: rgba(0,0,0,0.4); text-align: center; font-size: 13px; }
      @media (max-width: 600px) {
        body, #message { margin-top: 0; background: white; box-shadow: none; }
        body { border-top: 16px solid #ffa100; }
      }
    </style>
  </head>
  <body>
    <div id="message">
      <h2>404</h2>
      <h1>Page Not Found</h1>
      <p>The specified file was not found on this website. Please check the URL for mistakes and try again.</p>
      <h3>Why am I seeing this?</h3>
      <p>This page was generated by the Firebase Command-Line Interface. To modify it, edit the <code>404.html</code> file in your project's configured <code>public</code> directory.</p>
    </div>
  </body>
</html>


=== public/index.html ===
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mountain Medicine - Login</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --purple: #6C4AB6;
      --light-purple: #B8A4D4;
      --bg: #f9f9fb;
      --text: #222;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', sans-serif;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .login-box {
      margin: auto;
      background: white;
      border-radius: 16px;
      padding: 2rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      max-width: 360px;
      width: 90%;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .logo img {
      max-width: 300px;
      height: auto;
      display: block;
      margin-bottom: 1rem;
    }

    p {
      margin: 0 0 1rem;
      color: #555;
      font-size: 1rem;
    }

    .login-button {
      background: var(--purple);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      margin-top: 1rem;
      width: 100%;
    }

    .login-button:hover {
      background: var(--light-purple);
    }

    footer {
      font-size: 0.8rem;
      color: #999;
      margin-top: 2rem;
      text-align: center;
      width: 100%;
    }
  </style>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithRedirect, getRedirectResult } from "https://www.gstatic.com/firebasejs/10.11.0/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBSpwzSf8hXxb4rBk-u8JPyX7Ha4kGoS8o",
      authDomain: "mountainmedicine-6e572.web.app",
      projectId: "mountainmedicine-6e572",
      storageBucket: "mountainmedicine-6e572.appspot.com",
      messagingSenderId: "1081705872512",
      appId: "1:1081705872512:web:0ddf126c4737e47fd9ba65",
      measurementId: "G-NCMCE3BBPL"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const provider = new GoogleAuthProvider();

    function showWait() {
      document.getElementById('loginBtn').style.display = 'none';
      const rememberLabel = document.getElementById('rememberMe')?.parentElement;
      if (rememberLabel) rememberLabel.style.display = 'none';
      document.getElementById('pleaseWait').style.display = 'block';
    }

    if (localStorage.getItem('mm_login_pending') === 'true') {
      showWait();
    }

    function detectDeviceType() {
      const ua = navigator.userAgent.toLowerCase();
      return /iphone|ipad|android/.test(ua) ? "mobile" : "desktop";
    }

    getRedirectResult(auth)
      .then((result) => {
        if (result && result.user) {
          return result.user.getIdToken();
        }
      })
      .then((token) => {
        if (!token) return;
        const deviceType = detectDeviceType();
        const remember = localStorage.getItem("mm_remember") === "true";
        localStorage.setItem("mm_token", token);
        localStorage.setItem("mm_device", deviceType);
        if (remember) {
          const expiry = Date.now() + 30 * 24 * 60 * 60 * 1000;
          localStorage.setItem("mm_token_expiry", String(expiry));
        } else {
          localStorage.removeItem("mm_token_expiry");
        }
        localStorage.setItem("mm_token_handled", "true");
        localStorage.removeItem('mm_login_pending');
        window.location.href = `https://mountainmedicine.streamlit.app/?token=${token}&device=${deviceType}`;
      })
      .catch(() => {
        localStorage.removeItem('mm_login_pending');
      });

    window.login = function () {
      const remember = document.getElementById('rememberMe').checked;
      localStorage.setItem('mm_remember', remember ? 'true' : 'false');
      localStorage.setItem('mm_login_pending', 'true');
      showWait();
      signInWithRedirect(auth, provider);
    }
  </script>
</head>
<body>
  <div class="login-box">
    <div class="logo">
      <img src="/mountain_logo.png" alt="Mountain Medicine Logo" />
    </div>
    <p>Bringing humanity closer through man's original primal ceremony.</p>
    <label style="margin-bottom:0.5rem;display:flex;align-items:center;gap:4px;">
      <input type="checkbox" id="rememberMe" /> Remember me for 30 days
    </label>
    <button class="login-button" id="loginBtn" onclick="login()">üîê Login with Google</button>
    <div id="pleaseWait" style="display:none;margin-top:1rem;font-weight:600;">Please wait‚Ä¶</div>
    <footer>&copy; 2025 Mountain Medicine</footer>
  </div>
  <a href="/public-recipes.html" style="position: fixed; bottom: 8px; right: 8px; font-size: 0.75rem; color: #666; text-decoration: none;">View Recipes</a>
</body>
</html>


=== public/public-recipes.html ===
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Public Recipes | Mountain Medicine</title>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore-compat.js"></script>
  <style>
    body {
      background: #f5f3fa;
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      padding: 0;
      color: #222;
    }
    header {
      text-align: center;
      padding: 2rem 1rem 1rem;
    }
    header h1 {
      margin-bottom: 0.25rem;
    }
    .controls {
      text-align: center;
      margin-bottom: 1rem;
    }
    .controls input {
      padding: 0.5rem;
      width: 60%;
      max-width: 300px;
      margin-right: 0.5rem;
    }
    .controls select {
      padding: 0.5rem;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 1rem;
    }
    .recipe-card {
      background: white;
      padding: 1rem 1.5rem;
      margin-bottom: 1rem;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    .recipe-card details {
      cursor: pointer;
    }
    .recipe-card h3 {
      margin: 0 0 0.5rem;
      display: inline;
    }
    .recipe-card p {
      margin: 0.25rem 0;
    }
    .version {
      background:#fafafa;
      padding:0.5rem;
      border-radius:8px;
      margin-bottom:0.5rem;
    }
    footer {
      text-align: center;
      padding: 1rem;
      font-size: 0.8rem;
      color: #888;
    }
  </style>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyBSpwzSf8hXxb4rBk-u8JPyX7Ha4kGoS8o",
      authDomain: "mountainmedicine-6e572.firebaseapp.com",
      projectId: "mountainmedicine-6e572",
      storageBucket: "mountainmedicine-6e572.appspot.com",
      messagingSenderId: "1081705872512",
      appId: "1:1081705872512:web:0ddf126c4737e47fd9ba65",
      measurementId: "G-NCMCE3BBPL"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    let recipes = [];

    async function loadRecipes() {
      const snap = await db.collection('recipes').get();
      recipes = snap.docs.map(d => ({ id: d.id, ...d.data() }));
      renderRecipes();
    }

    function renderRecipes() {
      const container = document.getElementById('recipes');
      container.innerHTML = '';
      const search = document.getElementById('search').value.toLowerCase();
      const sort = document.getElementById('sort').value;

      let list = recipes.filter(r => {
        const text = `${r.name || ''} ${r.ingredients || ''} ${(r.allergens||[]).join(',')}`.toLowerCase();
        return text.includes(search);
      });

      if (sort === 'name') {
        list.sort((a,b) => (a.name||'').localeCompare(b.name||''));
      } else if (sort === 'name_desc') {
        list.sort((a,b) => (b.name||'').localeCompare(a.name||''));
      } else if (sort === 'newest') {
        list.sort((a,b) => (b.updated_at?.seconds||b.created_at?.seconds||0) - (a.updated_at?.seconds||a.created_at?.seconds||0));
      } else if (sort === 'oldest') {
        list.sort((a,b) => (a.updated_at?.seconds||a.created_at?.seconds||0) - (b.updated_at?.seconds||b.created_at?.seconds||0));
      }

      list.forEach(r => {
        const card = document.createElement('div');
        card.className = 'recipe-card';
        const allergenText = Array.isArray(r.allergens) && r.allergens.length ? `<p><strong>Allergens:</strong> ${r.allergens.join(', ')}</p>` : '';
        card.innerHTML = `
          <details>
            <summary><h3>${r.name || 'Untitled Recipe'}</h3></summary>
            <p><strong>Ingredients:</strong> ${r.ingredients || 'N/A'}</p>
            <p><strong>Instructions:</strong> ${r.instructions || 'N/A'}</p>
            ${allergenText}
            <div class="versions" id="ver-${r.id}"><em>Loading history...</em></div>
          </details>`;
        container.appendChild(card);
        const det = card.querySelector('details');
        det.addEventListener('toggle', async () => {
          if(det.open && !det.dataset.loaded){
            const versDiv = card.querySelector('.versions');
            const vsnap = await db.collection('recipes').doc(r.id).collection('versions').orderBy('timestamp','desc').get();
            versDiv.innerHTML = vsnap.empty ? '<p>No version history.</p>' : '';
            vsnap.forEach(vd => {
              const v = vd.data();
              const date = v.timestamp?.toDate().toLocaleString() || '';
              const d = document.createElement('div');
              d.className = 'version';
              d.innerHTML = `<strong>${date}</strong> - ${v.edited_by || ''}<br><pre>${v.instructions || ''}</pre>`;
              versDiv.appendChild(d);
            });
            det.dataset.loaded = 'true';
          }
        });
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
      document.getElementById('search').addEventListener('input', renderRecipes);
      document.getElementById('sort').addEventListener('change', renderRecipes);
      loadRecipes();
    });
  </script>
</head>
<body>
  <header>
    <h1>ü•£ Public Recipes</h1>
    <p>Browse delicious recipes shared by Mountain Medicine</p>
    <div class="controls">
      <input type="text" id="search" placeholder="Search recipes..." />
      <select id="sort">
        <option value="name">Name A-Z</option>
        <option value="name_desc">Name Z-A</option>
        <option value="newest">Newest</option>
        <option value="oldest">Oldest</option>
      </select>
    </div>
  </header>
  <div class="container" id="recipes">
    <p>Loading recipes...</p>
  </div>
  <footer>&copy; 2025 Mountain Medicine</footer>
</body>
</html>


=== public/redirect.html ===
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Redirecting...</title>
  <script>
    window.onload = function() {
      const params = new URLSearchParams(window.location.search);
      const token = params.get("token");
      const device = params.get("device") || "desktop";
      if (token) {
        const dest = `https://mountainmedicine.streamlit.app/?token=${token}&device=${device}`;
        window.location.replace(dest);
      } else {
        document.body.innerHTML = "<h1>Error: No token found</h1>";
      }
    };
  </script>
</head>
<body>
  <p>Redirecting to secure app...</p>
</body>
</html>


=== receipt_manager.py ===
import streamlit as st
from firebase_init import get_db
from auth import get_user_id
from utils import generate_id
from datetime import datetime

db = get_db()

# ----------------------------
# üßæ Receipt Upload & Linking
# ----------------------------

def receipt_upload_ui(user):
    if not user:
        st.warning("Please log in to manage receipts.")
        return

    st.title("üßæ Upload Receipt")

    uploaded = st.file_uploader("Upload a receipt (PDF, image, etc.)", type=["pdf", "jpg", "jpeg", "png"])

    ai_parse = st.checkbox("üß† Let AI assist with extraction")

    link_to_event = st.text_input("Link to Event ID (optional)")
    link_to_list = st.text_input("Link to Shopping List ID (optional)")
    link_to_equipment = st.text_input("Link to Equipment ID (optional)")

    if uploaded:
        rid = generate_id("rcpt")
        filename = uploaded.name
        content = uploaded.read()

        data = {
            "id": rid,
            "filename": filename,
            "uploaded_by": get_user_id(user),
            "linked_event": link_to_event or None,
            "linked_list": link_to_list or None,
            "linked_equipment": link_to_equipment or None,
            "ai_parsed": ai_parse,
            "parsed_data": {},  # placeholder
            "created_at": firestore.SERVER_TIMESTAMP
        }

        get_db().collection("receipts").document(rid).set(data)
        st.success("‚úÖ Receipt uploaded.")

        if ai_parse:
            st.info("üß† AI parsing simulated: item totals, vendor, date extracted. Manual review still required.")


=== receipts.py ===
import streamlit as st
from firebase_init import get_db, storage
from auth import require_login
from utils import generate_id, get_scoped_query, is_event_scoped, get_event_scope_message, get_active_event_id, delete_button
from datetime import datetime
from PIL import Image
import tempfile
import base64
import io
import json
import re
from google.cloud.firestore_v1.base_query import FieldFilter
from firebase_init import get_db

from mobile_helpers import safe_columns, safe_file_uploader
from mobile_layout import render_mobile_navigation

db = get_db()

# ----------------------------
# üßæ Receipt Upload & Parsing
# ----------------------------

def receipt_upload_ui(user: dict) -> None:
    st.title("üßæ Receipts")

    if st.session_state.get("mobile_mode"):
        render_mobile_navigation()

    st.info(get_event_scope_message())

    tab1, tab2 = st.tabs(["üì§ Upload Receipt", "üìã View Receipts"])

    with tab1:
        _upload_receipt_section(user)

    with tab2:
        _view_receipts_section(user)

# ----------------------------
# ü§ñ AI Receipt Parsing Logic
# ----------------------------

def _parse_receipt_with_ai(file_path: str) -> dict:
    try:
        from openai import OpenAI
        api_key = st.secrets.get("openai", {}).get("api_key", "")
        if not api_key:
            st.warning("‚ö†Ô∏è OpenAI API key not configured. Using manual entry.")
            return _parse_receipt_fallback()

        client = OpenAI(api_key=api_key)
    except Exception as e:
        st.warning(f"‚ö†Ô∏è OpenAI not available: {str(e)}. Using manual entry.")
        return _parse_receipt_fallback()

    try:
        with open(file_path, "rb") as image_file:
            image_data = image_file.read()

        base64_image = base64.b64encode(image_data).decode('utf-8')

        prompt = """Analyze this receipt image and extract the following information in JSON format:
        {
            "vendor": "store/vendor name",
            "date": "purchase date as YYYY-MM-DD",
            "total": "total amount as string without currency symbol",
            "items": [
                {
                    "name": "item name",
                    "quantity": "quantity and unit",
                    "price": "price as string without currency symbol"
                }
            ]
        }
        """

        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{base64_image}", "detail": "high"}}
                    ]
                }
            ],
            max_tokens=1000,
            temperature=0.1
        )

        result_text = response.choices[0].message.content.strip()
        json_match = re.search(r'\{.*\}', result_text, re.DOTALL)
        result_data = json.loads(json_match.group()) if json_match else json.loads(result_text)

        parsed_data = {
            "vendor": result_data.get("vendor", "Unknown Vendor"),
            "date": _parse_date(result_data.get("date", "")),
            "total": result_data.get("total", "0.00"),
            "items": []
        }

        for item in result_data.get("items", []):
            if item.get("name"):
                parsed_data["items"].append({
                    "name": item.get("name", "Unknown Item"),
                    "quantity": item.get("quantity", "1"),
                    "price": item.get("price", "0.00")
                })

        if not parsed_data["items"]:
            parsed_data["items"] = [{"name": "Items on receipt", "quantity": "Various", "price": parsed_data["total"]}]

        st.success(f"‚úÖ Successfully parsed {len(parsed_data['items'])} items from receipt!")
        return parsed_data

    except Exception as e:
        st.warning(f"‚ö†Ô∏è AI parsing encountered an error: {str(e)}. Please enter details manually.")
        return _parse_receipt_fallback()

def _parse_receipt_fallback():
    return {
        "vendor": "",
        "date": datetime.today(),
        "total": "",
        "items": [{"name": "", "quantity": "", "price": ""}]
    }

def _parse_date(date_string: str) -> datetime:
    if not date_string:
        return datetime.today()

    formats = [
        "%Y-%m-%d", "%m/%d/%Y", "%d/%m/%Y",
        "%m-%d-%Y", "%d-%m-%Y", "%Y/%m/%d",
        "%m/%d/%y", "%d/%m/%y"
    ]

    for fmt in formats:
        try:
            return datetime.strptime(date_string, fmt)
        except:
            continue

    return datetime.today()

def show_receipt_analytics():
    try:
        query = get_scoped_query("receipts")
        receipts = [doc.to_dict() for doc in query.stream()]

        if not receipts:
            st.info("No receipts to analyze")
            return

        st.markdown("### Receipt Analytics")
        col1, col2, col3, col4 = safe_columns(4)

        with col1:
            st.metric("Total Receipts", len(receipts))
        with col2:
            total_amount = sum(float(r.get('total', '0').replace('$', '').replace(',', '')) for r in receipts if r.get('total'))
            st.metric("Total Spent", f"${total_amount:,.2f}")
        with col3:
            vendors = set(r.get('vendor') for r in receipts if r.get('vendor'))
            st.metric("Unique Vendors", len(vendors))
        with col4:
            avg_amount = total_amount / len(receipts) if receipts else 0
            st.metric("Average Receipt", f"${avg_amount:.2f}")

        ai_parsed = len([r for r in receipts if r.get('ai_parsed')])
        if ai_parsed > 0:
            st.markdown("#### AI Parsing Statistics")
            col1, col2 = safe_columns(2)
            with col1:
                st.metric("AI Parsed", f"{ai_parsed}/{len(receipts)}")
            with col2:
                high_confidence = len([r for r in receipts if r.get('parse_confidence') == 'high'])
                st.metric("High Confidence", f"{high_confidence}/{ai_parsed}")

        if vendors:
            st.markdown("#### Top Vendors")
            vendor_totals = {}
            for receipt in receipts:
                vendor = receipt.get('vendor', 'Unknown')
                amount = float(receipt.get('total', '0').replace('$', '').replace(',', ''))
                vendor_totals[vendor] = vendor_totals.get(vendor, 0) + amount

            for vendor, total in sorted(vendor_totals.items(), key=lambda x: x[1], reverse=True)[:5]:
                st.write(f"**{vendor}:** ${total:,.2f}")

    except Exception as e:
        st.error(f"Could not load analytics: {e}")

def _display_receipts(receipts: list) -> None:
    total_amount = sum(
        float(r.get('total', '0').replace('$', '').replace(',', ''))
        for r in receipts if r.get('total')
    )

    col1, col2, col3 = safe_columns(3)
    with col1:
        st.metric("Total Receipts", len(receipts))
    with col2:
        st.metric("Total Spent", f"${total_amount:,.2f}")
    with col3:
        avg = total_amount / len(receipts) if receipts else 0
        st.metric("Average", f"${avg:.2f}")

    st.markdown("---")

    for receipt in receipts:
        with st.expander(f"üßæ {receipt.get('vendor', 'Unknown')} - {receipt.get('date', 'Unknown date')} - ${receipt.get('total', '0.00')}"):
            col1, col2 = safe_columns(2)

            with col1:
                st.markdown(f"**Vendor:** {receipt.get('vendor', 'Unknown')}")
                st.markdown(f"**Date:** {receipt.get('date', 'Unknown')}")
                st.markdown(f"**Total:** ${receipt.get('total', '0.00')}")
                st.markdown(f"**Uploaded by:** {receipt.get('uploaded_by', 'Unknown')}")

                if receipt.get('ai_parsed'):
                    confidence = receipt.get('parse_confidence', 'unknown')
                    emoji = "üü¢" if confidence == "high" else "üü°"
                    st.markdown(f"**AI Parsed:** {emoji} {confidence} confidence")

            with col2:
                if receipt.get('url'):
                    st.link_button(
                        "üì• Download Original",
                        receipt['url'],
                        key=f"download_{receipt['id']}"
                    )

                if not is_event_scoped() and receipt.get('event_id'):
                    st.markdown(f"**Event ID:** {receipt.get('event_id')}")
                if receipt.get('shopping_list_id'):
                    st.markdown(f"**Shopping List:** {receipt.get('shopping_list_id')}")
                if receipt.get('equipment_id'):
                    st.markdown(f"**Equipment List:** {receipt.get('equipment_id')}")

            items = receipt.get('items', [])
            if items:
                st.markdown("#### Items")
                for item in items:
                    col1, col2, col3 = safe_columns([3, 1, 1])
                    with col1:
                        st.write(f"‚Ä¢ {item.get('name', 'Unknown')}")
                    with col2:
                        st.write(item.get('quantity', ''))
                    with col3:
                        st.write(f"${item.get('price', '0.00')}")

            if receipt.get('notes'):
                st.markdown("#### Notes")
                st.write(receipt['notes'])

            if delete_button("üóëÔ∏è Delete Receipt", key=f"del_{receipt['id']}"):
                try:
                    get_db().collection("receipts").document(receipt['id']).delete()
                    st.success("Receipt deleted")
                except Exception as e:
                    st.error(f"Failed to delete: {e}")

def _upload_receipt_section(user: dict) -> None:
    st.subheader("Upload New Receipt")
    st.caption("AI-powered receipt parser extracts vendor, items, and totals automatically.")

    uploaded = safe_file_uploader(
        "Upload receipt (PDF or image)", 
        type=["pdf", "jpg", "jpeg", "png"]
    )

    if uploaded:
        col1, col2 = safe_columns(2)

        with col1:
            if uploaded.type.startswith('image'):
                image = Image.open(uploaded)
                # Preview the uploaded receipt image with a standard width
                st.image(image, caption="Receipt Preview", width=400)

        with col2:
            st.info("üì∏ Receipt uploaded! Click below to analyze it.")

            if st.button("üß† Parse Receipt with AI", type="primary"):
                with st.spinner("üîç Analyzing receipt..."):
                    file_id = generate_id("receipt")
                    file_name = uploaded.name
                    file_ext = file_name.split(".")[-1].lower()

                    with tempfile.NamedTemporaryFile(delete=False, suffix="." + file_ext) as tmp:
                        tmp.write(uploaded.getvalue())
                        tmp_path = tmp.name

                    parsed_data = _parse_receipt_with_ai(tmp_path)

                    st.session_state['parsed_receipt'] = {
                        'file_id': file_id,
                        'file_name': file_name,
                        'tmp_path': tmp_path,
                        'parsed_data': parsed_data,
                        'uploaded_file': uploaded
                    }

                    st.success("‚úÖ Receipt parsed! Review and edit below.")

    if 'parsed_receipt' in st.session_state:
        parsed = st.session_state['parsed_receipt']['parsed_data']

        st.markdown("### üìù Parsed Receipt Data")
        st.caption("Review and edit the extracted information before saving")

        with st.form("receipt_edit_form"):
            col1, col2 = safe_columns(2)

            with col1:
                vendor = st.text_input("Vendor", value=parsed.get("vendor", ""))
                date = st.date_input("Purchase Date", value=parsed.get("date", datetime.today()))

            with col2:
                total = st.text_input("Total Amount", value=parsed.get("total", ""))

                if is_event_scoped():
                    event_id = get_active_event_id()
                    st.info(f"Will be linked to current event")
                else:
                    event_id = st.text_input("Link to Event ID (optional)")

            st.markdown("#### Items")
            items = parsed.get("items", [])
            edited_items = []

            for i, item in enumerate(items):
                col1, col2, col3 = safe_columns([3, 1, 1])

                with col1:
                    name = st.text_input(f"Item {i+1}", value=item.get("name", ""), key=f"name_{i}")
                with col2:
                    qty = st.text_input("Qty", value=item.get("quantity", ""), key=f"qty_{i}")
                with col3:
                    price = st.text_input("Price", value=item.get("price", ""), key=f"price_{i}")

                if name:
                    edited_items.append({"name": name, "quantity": qty, "price": price})

            st.markdown("##### Add Item")
            new_col1, new_col2, new_col3 = safe_columns([3, 1, 1])

            with new_col1:
                new_name = st.text_input("New Item", key="new_item_name")
            with new_col2:
                new_qty = st.text_input("Qty", key="new_item_qty")
            with new_col3:
                new_price = st.text_input("Price", key="new_item_price")

            if new_name:
                edited_items.append({"name": new_name, "quantity": new_qty, "price": new_price})

            st.markdown("#### Additional Information")
            shopping_list_id = st.text_input("Link to Shopping List ID (optional)")
            equipment_id = st.text_input("Link to Equipment ID (optional)")
            notes = st.text_area("Notes (optional)")

            col1, col2 = safe_columns(2)
            with col1:
                save_button = st.form_submit_button("üíæ Save Receipt", type="primary")

            with col2:
                if st.form_submit_button("üîÑ Re-parse"):
                    with st.spinner("Re-analyzing..."):
                        new_parsed = _parse_receipt_with_ai(st.session_state['parsed_receipt']['tmp_path'])
                        st.session_state['parsed_receipt']['parsed_data'] = new_parsed

            if save_button:
                try:
                    receipt_data = st.session_state['parsed_receipt']
                    bucket = storage.bucket()
                    blob_path = f"receipts/{receipt_data['file_id']}/{receipt_data['file_name']}"
                    blob = bucket.blob(blob_path)

                    with open(receipt_data['tmp_path'], 'rb') as f:
                        blob.upload_from_file(f)

                    blob.make_public()
                    file_url = blob.public_url

                    firestore_data = {
                        "id": receipt_data['file_id'],
                        "filename": receipt_data['file_name'],
                        "url": file_url,
                        "uploaded_by": user["id"],
                        "uploaded_at": datetime.utcnow(),
                        "vendor": vendor,
                        "date": date.strftime("%Y-%m-%d"),
                        "total": total,
                        "items": edited_items,
                        "event_id": event_id or None,
                        "shopping_list_id": shopping_list_id or None,
                        "equipment_id": equipment_id or None,
                        "notes": notes,
                        "ai_parsed": True,
                        "parse_confidence": "high" if vendor and total else "low"
                    }

                    get_db().collection("receipts").document(receipt_data['file_id']).set(firestore_data)

                    import os
                    os.unlink(receipt_data['tmp_path'])
                    del st.session_state['parsed_receipt']

                    st.success("‚úÖ Receipt saved successfully!")
                    st.balloons()

                except Exception as e:
                    st.error(f"‚ùå Failed to save receipt: {e}")

def _view_receipts_section(user: dict) -> None:
    st.subheader("Uploaded Receipts")

    try:
        query = get_scoped_query("receipts")
        query = query.order_by("uploaded_at", direction=firestore.Query.DESCENDING)
        receipts = [doc.to_dict() for doc in query.stream()]
    except Exception as e:
        st.error(f"Failed to load receipts: {e}")
        receipts = []

    if not receipts:
        if is_event_scoped():
            st.info("No receipts found for this event.")
        else:
            st.info("No receipts found.")
        return

    if not is_event_scoped():
        receipts_by_event = {}
        for receipt in receipts:
            event_id = receipt.get("event_id", "No Event")
            if event_id not in receipts_by_event:
                receipts_by_event[event_id] = []
            receipts_by_event[event_id].append(receipt)

        for event_id, event_receipts in receipts_by_event.items():
            if event_id != "No Event":
                try:
                    event_doc = get_db().collection("events").document(event_id).get()
                    event_name = event_doc.to_dict().get("name", "Unknown Event") if event_doc.exists else "Unknown Event"
                    st.markdown(f"### üé™ {event_name}")
                except:
                    st.markdown(f"### üé™ Event ID: {event_id}")
            else:
                st.markdown("### üìã Unassigned Receipts")

            _display_receipts(event_receipts)
    else:
        st.markdown(f"### Event Receipts ({len(receipts)} total)")
        _display_receipts(receipts)


=== recipe_viewer.py ===
import streamlit as st
from utils import value_to_text


def normalize_quantity(value):
    if not value or str(value).lower() in ["", "null", "none"]:
        return "to taste"
    return str(value).strip()


def normalize_unit(value):
    if not value or str(value).lower() in ["", "null", "none"]:
        return ""
    return str(value).strip()




def render_recipe_preview(parsed_data):
    """Display a simple read-only preview of a parsed recipe."""
    recipe = parsed_data.get("recipes", {})
    if isinstance(recipe, list):
        recipe = recipe[0] if recipe else {}

    st.subheader("üß™ Auto-Detected Recipe Preview")

    st.text_input("Recipe Name", value=recipe.get("name") or recipe.get("title", ""))

    st.text_area("Ingredients", value=value_to_text(recipe.get("ingredients")))

    st.text_area("Instructions", value=value_to_text(recipe.get("instructions")))
    st.text_area("Notes", value=value_to_text(recipe.get("notes")))



=== recipes.py ===
import streamlit as st
from firebase_init import get_db, get_bucket
from firebase_admin import firestore
from datetime import datetime
from utils import format_date, get_active_event_id, value_to_text, generate_id, delete_button
from auth import get_user
from ingredients import (
    parse_recipe_ingredients,
    update_recipe_with_parsed_ingredients,
    get_event_ingredient_list,
    search_ingredients,
    search_recipes_by_ingredient,
)
from allergies import render_allergy_warning

db = get_db()
bucket = get_bucket()


def find_recipe_by_name(name: str):
    """Return existing recipe with the same name if any."""
    try:
        query = (
            db.collection("recipes")
            .where("name", "==", name.strip())
            .limit(1)
            .stream()
        )
        for doc in query:
            return doc.to_dict() | {"id": doc.id}
    except Exception as e:
        print(f"Duplicate lookup failed: {e}")
    return None


def render_ingredient_columns(items):
    if not isinstance(items, list):
        items = [i.strip() for i in str(items).splitlines() if i.strip()]
    cols = st.columns(2)
    for idx, item in enumerate(items):
        col = cols[idx % 2]
        col.markdown(f"- {item}")

# ----------------------------
# üîÑ Parse and Store Recipe From File
# ----------------------------

def parse_and_store_recipe_from_file(file_text: str, uploaded_by: str) -> str | None:
    import uuid

    lines = file_text.strip().splitlines()
    name = lines[0].strip() if lines else "Unnamed Recipe"

    try:
        ingredients_start = next(i for i, line in enumerate(lines) if "ingredient" in line.lower())
    except StopIteration:
        ingredients_start = 1

    try:
        instructions_start = next(i for i, line in enumerate(lines) if "instruction" in line.lower())
    except StopIteration:
        instructions_start = len(lines) // 2

    ingredients = "\n".join(lines[ingredients_start:instructions_start]).strip()
    instructions = "\n".join(lines[instructions_start:]).strip()
    ingredients = value_to_text(ingredients)
    instructions = value_to_text(instructions)

    recipe_data = {
        "id": str(uuid.uuid4()),
        "name": name,
        "ingredients": ingredients,
        "instructions": instructions,
        "notes": "",
        "special_version": "",
        "created_at": datetime.utcnow(),
        "author_id": uploaded_by,
        "author_name": uploaded_by,
        "ingredients_parsed": False,
    }

    try:
        ref = db.collection("recipes").document(recipe_data["id"])
        ref.set(recipe_data)
        return recipe_data["id"]
    except Exception as e:
        print("Error saving recipe:", e)
        return None


# ----------------------------
# üß™ Firestore Save Utilities
# ----------------------------

def save_recipe_to_firestore(recipe_data, user_id=None, file_id=None):
    recipe_id = str(uuid.uuid4())
    doc = {
        "id": recipe_id,
        "name": recipe_data.get("title") or recipe_data.get("name", "Untitled"),
        "ingredients": value_to_text(recipe_data.get("ingredients", [])),
        "instructions": value_to_text(recipe_data.get("instructions", [])),
        "special_version": recipe_data.get("special_version", ""),
        "image_url": recipe_data.get("image_url"),
        "tags": recipe_data.get("tags", []),
        "created_by": user_id,
        "source_file_id": file_id,
    }
    db.collection("recipes").document(recipe_id).set(doc)
    return recipe_id

def save_event_to_firestore(event_data, user_id=None, file_id=None):
    event_id = str(uuid.uuid4())
    doc = {
        "id": event_id,
        "name": event_data.get("title", "Untitled Event"),
        "date": event_data.get("date"),
        "location": event_data.get("location"),
        "notes": event_data.get("notes", ""),
        "tags": event_data.get("tags", []),
        "created_by": user_id,
        "source_file_id": file_id,
    }
    db.collection("events").document(event_id).set(doc)
    return event_id

def save_menu_to_firestore(menu_data, user_id=None, file_id=None):
    menu_id = str(uuid.uuid4())
    doc = {
        "id": menu_id,
        "title": menu_data.get("title", "Untitled Menu"),
        "meals": menu_data.get("meals", []),
        "tags": menu_data.get("tags", []),
        "created_by": user_id,
        "source_file_id": file_id,
    }
    db.collection("menus").document(menu_id).set(doc)
    return menu_id

def save_ingredient_to_firestore(ingredient_data, user_id=None, file_id=None):
    ing_id = str(uuid.uuid4())
    doc = {
        "id": ing_id,
        "name": ingredient_data.get("name", "Unnamed Ingredient"),
        "unit": ingredient_data.get("unit", ""),
        "category": ingredient_data.get("category", ""),
        "notes": ingredient_data.get("notes", ""),
        "tags": ingredient_data.get("tags", []),
        "created_by": user_id,
        "source_file_id": file_id,
    }
    db.collection("ingredients").document(ing_id).set(doc)
    return ing_id


# ----------------------------
# üåê Add Recipe via Link UI
# ----------------------------

def add_recipe_via_link_ui():
    """Allow users to paste a link and create a recipe."""
    dup_state = st.session_state.get("dup_link_recipe")
    if dup_state:
        st.warning("A recipe with this name already exists.")
        option = st.selectbox(
            "Choose how to proceed:",
            ["Add Version", "Save under Different Name", "Cancel"],
            key="dup_link_choice",
        )
        new_name = None
        if option == "Save under Different Name":
            new_name = st.text_input(
                "New Recipe Name",
                value=dup_state["data"].get("name"),
                key="dup_link_newname",
            )
        if st.button("Continue", key="dup_link_continue"):
            user_id = dup_state.get("user_id")
            if option == "Add Version":
                doc_ref = db.collection("recipes").document(dup_state["existing_id"])
                doc_ref.collection("versions").document(generate_id("ver")).set(
                    dup_state["data"] | {
                        "timestamp": datetime.utcnow(),
                        "edited_by": user_id,
                    }
                )
                st.success("‚úÖ Added as new version")
            elif option == "Save under Different Name":
                dup_state["data"]["name"] = new_name or dup_state["data"].get("name")
                save_recipe_to_firestore(dup_state["data"], user_id=user_id)
                st.success("‚úÖ Recipe saved")
            st.session_state.pop("dup_link_recipe")
            st.session_state.pop("parsed_link_recipe", None)
            st.rerun()
        if st.button("Cancel", key="dup_link_cancel"):
            st.session_state.pop("dup_link_recipe")
            st.rerun()
        return

    with st.expander("Add Recipe via Link", expanded=False):
        st.markdown(
            "<div class='card' style='max-width:600px;margin:0 auto'>",
            unsafe_allow_html=True,
        )

        url = st.text_input(
            "Recipe URL",
            placeholder="Just paste a link to an online recipe",
            key="recipe_link_input",
            label_visibility="collapsed",
        )
        parse_clicked = st.button("Get Recipe", key="parse_link_btn")

        if parse_clicked and url:
            with st.spinner("Parsing recipe..."):
                from ai_parsing_engine import parse_recipe_from_url

                data = parse_recipe_from_url(url)
                st.session_state["parsed_link_recipe"] = data

        data = st.session_state.get("parsed_link_recipe")

        if data:
            title = st.text_input(
                "Title",
                value=data.get("name") or data.get("title", ""),
                key="link_recipe_title",
            )
            special_version = st.text_input("Special Version", key="link_special_version")
            ingredients_value = value_to_text(data.get("ingredients"))
            instructions_value = value_to_text(data.get("instructions"))
            ingredients = st.text_area("Ingredients", value=ingredients_value, key="link_ingredients")
            if data.get("ingredients"):
                render_ingredient_columns(data.get("ingredients"))
            instructions = st.text_area("Instructions", value=instructions_value, key="link_instructions")

            parsed_image_url = data.get("image_url")
            image_file = st.file_uploader(
                "Recipe Photo",
                type=["png", "jpg", "jpeg"],
                key="link_image_upload",
            )
            if image_file:
                # Display a preview of the uploaded image with a standard width
                st.image(image_file, width=400)
            elif parsed_image_url:
                # Show the image parsed from the URL if no file uploaded
                st.image(parsed_image_url, width=400)

            if st.button("Save Recipe", key="save_link_recipe"):
                user = get_user()
                image_url = None
                if image_file:
                    import uuid

                    blob = bucket.blob(f"recipes/{uuid.uuid4()}_{image_file.name}")
                    blob.upload_from_file(image_file)
                    blob.make_public()
                    image_url = blob.public_url
                elif parsed_image_url:
                    image_url = parsed_image_url

                recipe_doc = {
                    "name": title,
                    "ingredients": ingredients,
                    "instructions": instructions,
                    "special_version": special_version,
                    "image_url": image_url,
                    "created_at": datetime.utcnow(),
                    "author_name": user.get("name") if user else "unknown",
                }
                existing = find_recipe_by_name(recipe_doc["name"])
                if existing:
                    st.session_state["dup_link_recipe"] = {
                        "existing_id": existing["id"],
                        "data": recipe_doc,
                        "user_id": user.get("id") if user else None,
                    }
                    st.rerun()
                else:
                    db.collection("recipes").document().set(recipe_doc)
                    st.success("Recipe saved!")
                    st.session_state.pop("parsed_link_recipe", None)
                    st.session_state["recipe_link_input"] = ""
                    st.session_state["link_recipe_title"] = ""
                    st.session_state["link_special_version"] = ""
                    st.session_state["link_ingredients"] = ""
                    st.session_state["link_instructions"] = ""
                    st.session_state["link_image_upload"] = None
                    st.rerun()

        st.markdown("</div>", unsafe_allow_html=True)


# ----------------------------
# ‚úçÔ∏è Add Recipe Manually UI
# ----------------------------

def add_recipe_manual_ui():
    """Create a recipe manually."""

    # Clear form fields on rerun if requested
    if st.session_state.get("clear_manual_recipe_form"):
        for key in [
            "manual_recipe_name",
            "manual_special_version",
            "manual_ingredients",
            "manual_instructions",
            "manual_notes",
            "manual_tags",
        ]:
            st.session_state[key] = ""
        st.session_state["clear_manual_recipe_form"] = False

    with st.expander("Add Recipe Manually", expanded=False):
        st.markdown(
            "<div class='card' style='max-width:600px;margin:0 auto'>",
            unsafe_allow_html=True,
        )

        with st.form("manual_recipe_form"):
            name = st.text_input("Recipe Name", key="manual_recipe_name")
            special_version = st.text_input("Special Version", key="manual_special_version")
            ingredients = st.text_area("Ingredients", key="manual_ingredients")
            instructions = st.text_area("Instructions", key="manual_instructions")
            notes = st.text_area("Notes", key="manual_notes")
            tags = st.text_input("Tags (comma-separated)", key="manual_tags")
            submitted = st.form_submit_button("Save Recipe")

        st.markdown("</div>", unsafe_allow_html=True)

    if submitted:
        import uuid

        user = get_user()
        recipe_id = str(uuid.uuid4())
        data = {
            "id": recipe_id,
            "name": name,
            "ingredients": ingredients,
            "instructions": instructions,
            "special_version": special_version,
            "notes": notes,
            "tags": [t.strip() for t in tags.split(",") if t.strip()],
            "created_at": datetime.utcnow(),
            "author_id": user.get("id") if user else None,
            "author_name": user.get("name") if user else "unknown",
            "ingredients_parsed": False,
        }

        try:
            db.collection("recipes").document(recipe_id).set(data)
            parsed = parse_recipe_ingredients(ingredients)
            if parsed:
                update_recipe_with_parsed_ingredients(recipe_id, parsed)
            st.success("‚úÖ Recipe saved!")
            # flag to clear form fields on the next run
            st.session_state["clear_manual_recipe_form"] = True
            st.rerun()
        except Exception as e:
            st.error(f"Failed to save recipe: {e}")


def _render_recipe_card(recipe: dict, *, is_version: bool = False):
    """Render a collapsible recipe card showing only the name by default.

    When ``is_version`` is ``True`` the recipe represents a saved version and
    will be displayed indented with the ``special_version`` text as its title.
    """
    parent_id = recipe.get("parent_id") if is_version else recipe.get("id")
    doc_ref = db.collection("recipes").document(parent_id)

    version_label = ""
    if not is_version:
        try:
            version_count = len(list(doc_ref.collection("versions").stream()))
        except Exception:
            version_count = 0
        version_label = f"v1.{version_count}"

    header = recipe.get("special_version") if is_version else recipe.get("name", "Unnamed")
    if is_version:
        header = header or "Unnamed"

    container = st.container()
    if is_version:
        container.markdown('<div class="version-expander">', unsafe_allow_html=True)
    with container:
        with st.expander(header):
            if recipe.get("image_url"):
                # Center the image and standardize its display size
                col_center = st.columns([1, 6, 1])[1]
                with col_center:
                    st.image(recipe["image_url"], width=400)
            st.markdown("#### Ingredients")
            render_ingredient_columns(recipe.get("ingredients"))
            st.markdown("#### Instructions")
            st.markdown(value_to_text(recipe.get("instructions", "")))
            if recipe.get("notes"):
                st.markdown("#### Notes")
                st.markdown(recipe.get("notes"))
            if version_label:
                st.caption(version_label)

            col_edit, col_add, col_del = st.columns(3)
            if col_edit.button("Edit", key=f"edit_{recipe['id']}"):
                st.session_state["editing_recipe_id"] = recipe["id"]
                st.rerun()
            if col_add.button("Add Version", key=f"addver_{recipe['id']}"):
                st.session_state[f"add_ver_{recipe['id']}"] = True
            if delete_button("Delete", key=f"del_{recipe['id']}"):
                if is_version:
                    doc_ref.collection("versions").document(recipe["id"]).delete()
                else:
                    db.collection("recipes").document(recipe["id"]).delete()
                st.rerun()

        if st.session_state.get(f"add_ver_{recipe['id']}"):
            with st.form(f"ver_form_{recipe['id']}"):
                name = st.text_input("Title", value=recipe.get("name", ""), key=f"ver_name_{recipe['id']}")
                special_version = st.text_input("Special Version", value=recipe.get("special_version", ""), key=f"ver_sp_{recipe['id']}")
                ingredients = st.text_area(
                    "Ingredients",
                    value=value_to_text(recipe.get("ingredients")),
                    key=f"ver_ing_{recipe['id']}"
                )
                instructions = st.text_area(
                    "Instructions",
                    value=value_to_text(recipe.get("instructions")),
                    key=f"ver_inst_{recipe['id']}"
                )
                notes = st.text_area(
                    "Notes",
                    value=value_to_text(recipe.get("notes")),
                    key=f"ver_notes_{recipe['id']}"
                )
                tags = st.text_input("Tags (comma-separated)", value=", ".join(recipe.get("tags", [])), key=f"ver_tags_{recipe['id']}")
                col_c, col_s = st.columns(2)
                save = col_s.form_submit_button("Save")
                cancel = col_c.form_submit_button("Cancel")

            if save:
                user = get_user()
                version_entry = {
                    "name": name,
                    "ingredients": ingredients,
                    "instructions": instructions,
                    "notes": notes,
                    "special_version": special_version,
                    "tags": [t.strip() for t in tags.split(',') if t.strip()],
                    "timestamp": datetime.utcnow(),
                    "edited_by": user.get("id") if user else None,
                }
                doc_ref.collection("versions").document(generate_id("ver")).set(version_entry)
                st.session_state.pop(f"add_ver_{recipe['id']}", None)
                st.rerun()
            elif cancel:
                st.session_state.pop(f"add_ver_{recipe['id']}", None)

    if is_version:
        container.markdown('</div>', unsafe_allow_html=True)


# ----------------------------
# üìñ Recipes Tab (Public)
# ----------------------------

def recipes_page():
    """Simple recipe browsing page."""
    st.title("üìö Recipes")

    add_recipe_via_link_ui()
    add_recipe_manual_ui()

    # If a recipe has been selected for editing, open editor directly
    editing_id = st.session_state.pop("editing_recipe_id", None)
    if editing_id:
        from recipes_editor import recipe_editor_ui
        recipe_editor_ui(editing_id)
        return

    search_term = st.text_input("Search recipes", key="recipe_search")

    try:
        recipes = [
            doc.to_dict() | {"id": doc.id}
            for doc in db.collection("recipes")
            .order_by("created_at", direction=firestore.Query.DESCENDING)
            .stream()
        ]
    except Exception as e:
        st.error(f"Failed to load recipes: {e}")
        return

    if not recipes:
        st.info("No recipes found.")
        return

    if search_term:
        term = search_term.lower()
        recipes = [r for r in recipes if term in r.get("name", "").lower()]

    for recipe in recipes:
        _render_recipe_card(recipe)

        # Display saved versions indented under the base recipe
        try:
            ver_docs = (
                db.collection("recipes")
                .document(recipe["id"])
                .collection("versions")
                .order_by("timestamp", direction=firestore.Query.ASCENDING)
                .stream()
            )
        except Exception:
            ver_docs = []

        for v in ver_docs:
            vdata = v.to_dict() or {}
            vdata.update({"id": v.id, "parent_id": recipe["id"]})
            if "name" not in vdata:
                vdata["name"] = recipe.get("name")
            _render_recipe_card(vdata, is_version=True)



=== recipes_editor.py ===
import streamlit as st
from firebase_init import db
from firebase_admin import firestore
from datetime import datetime
from utils import get_active_event_id, generate_id, value_to_text
from auth import get_user_id
from ingredients import parse_recipe_ingredients, update_recipe_with_parsed_ingredients
from allergies import render_allergy_warning
from recipes import save_recipe_to_firestore
from tag_utils import suggest_recipe_tags


def render_ingredient_columns(items):
    if not isinstance(items, list):
        items = [i.strip() for i in str(items).splitlines() if i.strip()]
    cols = st.columns(2)
    for idx, item in enumerate(items):
        col = cols[idx % 2]
        col.markdown(f"- {item}")



# ----------------------------
# üìñ Recipe Editor UI
# ----------------------------

def recipe_editor_ui(recipe_id=None, prefill_data=None):
    st.title("üìñ Recipe Editor")

    user_id = get_user_id()
    event_id = get_active_event_id()

    doc_ref = None
    recipe = None
    if recipe_id:
        doc_ref = db.collection("recipes").document(recipe_id)
        doc = doc_ref.get()
        if not doc.exists:
            st.error("Recipe not found.")
            return
        recipe = doc.to_dict()
    elif prefill_data:
        recipe = prefill_data
        st.info("üí° This form is pre-filled from parsed data.")
    else:
        st.warning("No recipe to show.")
        return

    if recipe.get("image_url"):
        # Display the recipe image with a consistent size
        st.image(recipe["image_url"], width=400, caption="üì∑ Recipe Image")

    display_name = recipe.get("name") or recipe.get("title", "Unnamed Recipe")
    st.subheader(f"Editing: {display_name}")

    with st.form("edit_recipe_form"):
        name = st.text_input(
            "Recipe Name",
            value=recipe.get("name") or recipe.get("title", ""),
        )
        special_version = st.text_input("Special Version", value=recipe.get("special_version", ""))
        
        ingredients = st.text_area("Ingredients", value=value_to_text(recipe.get("ingredients")))
        if prefill_data and recipe.get("ingredients"):
            render_ingredient_columns(recipe.get("ingredients"))
        instructions = st.text_area("Instructions", value=value_to_text(recipe.get("instructions")))
        notes = st.text_area("Notes", value=value_to_text(recipe.get("notes")))
      
        tags = st.text_input("Tags (comma-separated)", value=", ".join(recipe.get("tags", [])))
        edit_note = st.text_input("üìù Edit Note (for version history)", value="", key="edit_note")

        if st.button("üß† Suggest Tags with AI"):
            st.info("üß† AI tag suggestion coming soon...")

        if recipe.get("ingredients_parsed"):
            render_allergy_warning(recipe)

        if st.checkbox("Show Parsed Ingredients", value=False):
            parsed = recipe.get("parsed_ingredients", [])
            if parsed:
                st.markdown("### üåø Parsed Ingredients")
                for ing in parsed:
                    st.write(f"- {ing.get('quantity', '?')} {ing.get('unit', '')} {ing.get('name', '')}")
            else:
                st.info("No parsed ingredients available.")

        st.markdown("### üß¨ Variants (Sub-Recipes for Allergies/Diets)")
        variants = recipe.get("variants", [])
        for idx, variant in enumerate(variants):
            with st.expander(f"Variant #{idx + 1}: {variant.get('label', 'Untitled Variant')}"):
                st.markdown(f"**Modified Instructions:**\n{variant.get('instructions', '-')}")
                st.markdown(f"**Allergen Notes:** {variant.get('notes', '-')}")

        new_variant_label = st.text_input("‚ûï New Variant Label", key="new_variant_label")
        new_variant_notes = st.text_area("Allergen Notes", key="new_variant_notes")
        new_variant_instructions = st.text_area("Modified Instructions", key="new_variant_instructions")

        add_variant = st.form_submit_button("Add Variant")
        if add_variant and new_variant_label and doc_ref:
            variant = {
                "label": new_variant_label,
                "notes": new_variant_notes,
                "instructions": new_variant_instructions,
                "created_at": datetime.utcnow(),
                "created_by": user_id
            }
            doc_ref.update({"variants": firestore.ArrayUnion([variant])})
            st.success("Variant added.")

        submitted = st.form_submit_button("üóï Save Changes")
        if submitted:
            tag_list = [t.strip() for t in tags.split(",") if t.strip()]
            if special_version:
                suggested = suggest_recipe_tags(name, ingredients, instructions, special_version)
                for t in suggested:
                    if t not in tag_list:
                        tag_list.append(t)
            st.session_state["pending_recipe_save"] = {
                "doc_id": recipe_id if doc_ref else None,
                "data": {
                    "name": name,
                    "ingredients": ingredients,
                    "instructions": instructions,
                    "special_version": special_version,
                    "notes": notes,
                    "tags": tag_list,
                    "edit_note": edit_note,
                },
            }
            st.session_state["confirm_tags"] = ", ".join(tag_list)
            st.rerun()

    if doc_ref:
        st.markdown("---")
        st.markdown("### üïì Version History")
        versions = doc_ref.collection("versions").order_by(
            "timestamp", direction=firestore.Query.DESCENDING
        ).stream()
        for v in versions:
            vdata = v.to_dict()
            timestamp = vdata.get("timestamp")
            label = timestamp.strftime("%Y-%m-%d %H:%M") if timestamp else "Unknown"
            with st.expander(f"üïì {label} - {vdata.get('edited_by')}"):
                st.write("**Name:**", vdata.get("name"))
                st.write("**Instructions:")
                st.code(vdata.get("instructions", ""))
                st.write("**Notes:**", vdata.get("notes", ""))
                if vdata.get("special_version"):
                    st.info(f"Special Version: {vdata.get('special_version')}")
                if vdata.get("edit_note"):
                    st.info(f"üìù Edit Note: {vdata.get('edit_note')}")
                st.caption(f"Tags: {', '.join(vdata.get('tags', []))}")

    pending = st.session_state.get("pending_recipe_save")
    if pending:
        st.markdown("---")
        st.markdown("### Confirm Tags")
        tags_val = st.text_input("Tags", value=st.session_state.get("confirm_tags", ""), key="confirm_tags_final")
        col_ok, col_cancel = st.columns(2)
        if col_ok.button("‚úÖ Confirm Save"):
            data = pending["data"]
            data["tags"] = [t.strip() for t in tags_val.split(',') if t.strip()]
            doc_id = pending.get("doc_id")
            if doc_id:
                doc_ref = db.collection("recipes").document(doc_id)
                doc_ref.collection("versions").document(generate_id("ver")).set(data | {
                    "timestamp": datetime.utcnow(),
                    "edited_by": user_id,
                })
                doc_ref.update(data | {
                    "updated_at": datetime.utcnow(),
                    "updated_by": user_id,
                })
                update_recipe_with_parsed_ingredients(doc_id, data["ingredients"])
            else:
                new_id = save_recipe_to_firestore(data, user_id=user_id)
                if new_id:
                    update_recipe_with_parsed_ingredients(new_id, data["ingredients"])
            st.session_state.pop("pending_recipe_save")
            st.session_state.pop("confirm_tags", None)
            st.success("‚úÖ Recipe saved!")
            st.rerun()
        if col_cancel.button("Cancel", key="cancel_save_tags"):
            st.session_state.pop("pending_recipe_save")
            st.session_state.pop("confirm_tags", None)
            st.rerun()
        return



=== requirements.txt ===
streamlit>=1.39.0
firebase-admin>=6.4.0
fpdf2>=2.7.0
openai>=1.3.0
networkx>=3.0
pyvis>=0.3.0
Pillow>=10.0.0
python-magic-bin==0.4.14; platform_system=="Windows"

# Additional dependencies for enhanced functionality
pandas>=2.0.0
numpy>=1.24.0
python-dateutil>=2.8.0
pytesseract>=0.3.10
PyMuPDF>=1.22.0
pdf2image>=1.16.3
beautifulsoup4>=4.13.0
python-docx>=0.8.11


=== roles.py ===
# roles.py - Updated for Firebase Authentication

import streamlit as st
from firebase_admin import firestore
from auth import require_role, get_current_user, get_user_role as auth_get_user_role
from utils import delete_button

db = firestore.client()
COLLECTION = "users"

# ----------------------------
# üîç Fetch Roles (Updated for Firebase)
# ----------------------------

def get_all_users() -> list[dict]:
    """Returns all user documents from Firestore."""
    try:
        # Sync Firebase users first
        from auth import sync_firebase_users
        sync_firebase_users()
        
        docs = db.collection(COLLECTION).stream()
        return [doc.to_dict() | {"id": doc.id} for doc in docs]
    except Exception as e:
        st.error(f"Failed to get users: {e}")
        return []

def get_user_role(user_id: str) -> str:
    """Returns a user's role by ID, defaulting to 'viewer'."""
    doc = db.collection(COLLECTION).document(user_id).get()
    if doc.exists:
        return doc.to_dict().get("role", "viewer")
    
    # Try to get from Firebase if not in Firestore
    try:
        from firebase_admin import auth as firebase_auth
        firebase_user = firebase_auth.get_user(user_id)
        # Create user record in Firestore
        role = "admin" if firebase_user.email in ["mistermcfarland@gmail.com"] else "viewer"
        user_data = {
            "id": user_id,
            "email": firebase_user.email, 
            "name": firebase_user.display_name or firebase_user.email.split('@')[0],
            "role": role,
            "created_at": datetime.utcnow(),
            "active": True,
            "email_verified": firebase_user.email_verified
        }
        db.collection(COLLECTION).document(user_id).set(user_data)
        return role
    except:
        return "viewer"

# ----------------------------
# üîÑ Update Role (Firebase Enhanced)
# ----------------------------

def update_user_role(user_id: str, role: str) -> None:
    """Updates a user's role in Firestore and logs the change."""
    try:
        # Update role in Firestore
        db.collection(COLLECTION).document(user_id).update({
            "role": role,
            "role_updated_at": datetime.utcnow()
        })
        
        # Log the role change
        current_user = get_current_user()
        db.collection("logs").add({
            "action": "role_update",
            "target_user_id": user_id,
            "new_role": role,
            "updated_by": current_user.get("id") if current_user else "system",
            "timestamp": datetime.utcnow()
        })
        
        st.success(f"‚úÖ Role updated to **{role}**")
        
        # Send notification
        from notifications import send_notification
        user_doc = db.collection(COLLECTION).document(user_id).get()
        if user_doc.exists:
            user_name = user_doc.to_dict().get("name", "Unknown")
            send_notification(
                f"Role updated for {user_name}: {role}",
                role="admin"
            )
            
    except Exception as e:
        st.error(f"Failed to update role: {e}")

# ----------------------------
# ‚öôÔ∏è Admin UI (Firebase Enhanced)
# ----------------------------

def role_admin_ui() -> None:
    """Displays the role management panel (admin-only) with Firebase integration."""
    st.subheader("üë• User Role Management")

    current_user = get_current_user()
    if not current_user or auth_get_user_role(current_user) != "admin":
        st.warning("Only admins can view or change user roles.")
        return

    # Get all users
    users = get_all_users()
    
    if not users:
        st.info("No users found. Users will appear here after they register.")
        return
    
    # Statistics
    role_stats = {}
    for user in users:
        role = user.get("role", "viewer")
        role_stats[role] = role_stats.get(role, 0) + 1
    
    st.markdown("### üìä Role Statistics")
    cols = st.columns(len(role_stats))
    for i, (role, count) in enumerate(role_stats.items()):
        with cols[i]:
            st.metric(role.title(), count)
    
    st.markdown("---")
    st.markdown(f"### üë• Manage User Roles ({len(users)} users)")
    
    # Current admin ID to prevent self-demotion
    current_admin_id = current_user.get("id")
    
    for user in users:
        with st.expander(f"{user.get('name', 'Unnamed')} ({user.get('email', 'No email')})"):
            col1, col2 = st.columns([2, 1])
            
            with col1:
                # User info
                st.markdown(f"**Email:** {user.get('email', 'Unknown')}")
                st.markdown(f"**User ID:** `{user.get('id', 'Unknown')}`")
                
                # Firebase-specific info
                if user.get('email_verified'):
                    st.markdown("**Email Status:** ‚úÖ Verified")
                else:
                    st.markdown("**Email Status:** ‚ö†Ô∏è Unverified")
                
                if user.get('created_at'):
                    from utils import format_date
                    st.markdown(f"**Joined:** {format_date(user.get('created_at'))}")
            
            with col2:
                current_role = user.get("role", "viewer")
                st.markdown(f"**Current Role:** `{current_role}`")
                
                # Role selection
                can_change_role = True
                warning_msg = None
                
                # Prevent admin from changing own role
                if user.get('id') == current_admin_id:
                    can_change_role = False
                    warning_msg = "Cannot change your own role"
                
                # Prevent demoting last admin
                elif current_role == "admin":
                    other_admins = [u for u in users if u.get("role") == "admin" and u.get("id") != user.get("id")]
                    if not other_admins:
                        can_change_role = False
                        warning_msg = "Cannot demote the last admin"
                
                if warning_msg:
                    st.warning(warning_msg)
                
                if can_change_role:
                    new_role = st.selectbox(
                        "Assign Role",
                        ["viewer", "user", "manager", "admin"],
                        index=["viewer", "user", "manager", "admin"].index(current_role),
                        key=f"role_{user['id']}"
                    )
                    
                    if new_role != current_role:
                        if st.button("üíæ Save Role", key=f"save_{user['id']}", type="primary"):
                            update_user_role(user["id"], new_role)
                            st.rerun()
                else:
                    st.info(f"Role: **{current_role}** (protected)")
            
            # Additional actions
            st.markdown("---")
            col1, col2, col3 = st.columns(3)
            
            with col1:
                # Email verification action
                if not user.get('email_verified', False):
                    if st.button("üìß Send Verification", key=f"verify_{user['id']}"):
                        try:
                            from firebase_admin import auth as firebase_auth
                            verification_link = firebase_auth.generate_email_verification_link(user.get('email'))
                            st.success("‚úÖ Verification email queued!")
                            st.info("Email verification system integration needed")
                        except Exception as e:
                            st.error(f"Failed to send verification: {e}")
            
            with col2:
                # View activity
                if st.button("üìä View Activity", key=f"activity_{user['id']}"):
                    show_user_activity_summary(user)
            
            with col3:
                # Delete user (if not admin or current user)
                if (current_role != "admin" and 
                    user.get('id') != current_admin_id):
                    
                    if delete_button("üóëÔ∏è Delete User", key=f"delete_{user['id']}", type="secondary"):
                        try:
                            from auth import delete_firebase_user
                            if delete_firebase_user(user['id']):
                                st.success("‚úÖ User deleted successfully")
                                st.rerun()
                        except Exception as e:
                            st.error(f"Failed to delete user: {e}")

def show_user_activity_summary(user: dict):
    """Show a brief activity summary for a user"""
    user_id = user.get("id")
    
    with st.container():
        st.markdown(f"#### üìä Activity Summary for {user.get('name', 'Unknown')}")
        
        try:
            # Get user's events
            events_created = list(db.collection("events").where("created_by", "==", user_id).stream())
            
            # Get user's files
            files_uploaded = list(db.collection("files").where("uploaded_by", "==", user_id).stream())
            
            # Get user's active sessions
            active_sessions = list(db.collection("active_sessions")
                                 .where("user_id", "==", user_id)
                                 .where("active", "==", True).stream())
            
            # Display metrics
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("Events Created", len(events_created))
            with col2:
                st.metric("Files Uploaded", len(files_uploaded))
            with col3:
                st.metric("Active Sessions", len(active_sessions))
            
            # Show recent events
            if events_created:
                st.markdown("**Recent Events:**")
                for event_doc in events_created[-3:]:  # Show last 3
                    event_data = event_doc.to_dict()
                    st.write(f"‚Ä¢ {event_data.get('name', 'Unnamed')} ({event_data.get('status', 'unknown')})")
            
            # Show last login from Firebase
            try:
                from firebase_admin import auth as firebase_auth
                firebase_user = firebase_auth.get_user(user_id)
                if firebase_user.user_metadata.last_sign_in_timestamp:
                    from datetime import datetime
                    from utils import format_date
                    last_signin = datetime.fromtimestamp(firebase_user.user_metadata.last_sign_in_timestamp / 1000)
                    st.write(f"**Last Sign In:** {format_date(last_signin)}")
            except:
                pass
            
        except Exception as e:
            st.error(f"Could not load activity summary: {e}")

# ----------------------------
# üöÄ Initialization (Firebase Enhanced)
# ----------------------------

def initialize_role_system():
    """Initialize the role management system with Firebase"""
    try:
        # Ensure admin user exists
        from firebase_admin import auth as firebase_auth
        from datetime import datetime
        
        admin_email = "mistermcfarland@gmail.com"
        
        try:
            # Check if admin exists in Firebase
            admin_user = firebase_auth.get_user_by_email(admin_email)
            
            # Ensure admin has correct role in Firestore
            admin_doc = db.collection(COLLECTION).document(admin_user.uid).get()
            if not admin_doc.exists or admin_doc.to_dict().get("role") != "admin":
                admin_data = {
                    "id": admin_user.uid,
                    "email": admin_email,
                    "name": admin_user.display_name or "Admin",
                    "role": "admin",
                    "created_at": datetime.utcnow(),
                    "active": True,
                    "email_verified": admin_user.email_verified
                }
                db.collection(COLLECTION).document(admin_user.uid).set(admin_data, merge=True)
                
        except firebase_auth.UserNotFoundError:
            st.warning(f"Admin user {admin_email} not found in Firebase. Please register this email.")
        
        return True
        
    except Exception as e:
        st.error(f"Failed to initialize role system: {e}")
        return False

# ----------------------------
# üîÑ Legacy Compatibility
# ----------------------------

def role_admin_ui_legacy():
    """Legacy function name - use role_admin_ui instead"""
    return role_admin_ui()


=== shopping_lists.py ===
import streamlit as st
from firebase_init import get_db
from datetime import datetime
from utils import generate_id

db = get_db()

# ----------------------------
# üõí Shopping List Management
# ----------------------------

def create_shopping_list(list_data: dict, user_id: str | None = None) -> str | None:
    """Create a shopping list document"""
    try:
        list_id = generate_id("shoplist")
        doc = {
            "id": list_id,
            "name": list_data.get("name", "Untitled Shopping List"),
            "items": list_data.get("items", []),
            "tags": list_data.get("tags", []),
            "created_by": user_id,
            "created_at": datetime.utcnow(),
            "deleted": False,
            "source_file": list_data.get("source_file"),
            "parsed_data": list_data.get("parsed_data", {}),
        }
        db.collection("shopping_lists").document(list_id).set(doc)
        return list_id
    except Exception as e:
        st.error(f"‚ùå Failed to create shopping list: {e}")
        return None

def update_shopping_list(list_id: str, updates: dict) -> bool:
    """Update an existing shopping list"""
    try:
        updates["updated_at"] = datetime.utcnow()
        db.collection("shopping_lists").document(list_id).update(updates)
        return True
    except Exception as e:
        st.error(f"‚ùå Failed to update shopping list: {e}")
        return False

def delete_shopping_list(list_id: str) -> bool:
    """Soft delete a shopping list"""
    try:
        db.collection("shopping_lists").document(list_id).update({
            "deleted": True,
            "deleted_at": datetime.utcnow(),
        })
        return True
    except Exception as e:
        st.error(f"‚ùå Failed to delete shopping list: {e}")
        return False

def get_shopping_list(list_id: str) -> dict | None:
    """Fetch a single shopping list"""
    doc = db.collection("shopping_lists").document(list_id).get()
    return doc.to_dict() if doc.exists else None

def list_shopping_lists() -> list:
    """List all shopping lists"""
    docs = db.collection("shopping_lists").where("deleted", "==", False).stream()
    return [d.to_dict() | {"id": d.id} for d in docs]


=== style.css ===
/* Complete Style Redesign - Mobile First, Clean & Modern */

/* -----------------------------
   CSS Variables & Base
----------------------------- */
:root {
    --primary-purple: #6C4AB6;
    --light-purple: #B8A4D4;
    --accent-purple: #563a9d;
    --dark-purple: #4a3280;
    --border-radius: 8px;
    --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
    --shadow-md: 0 4px 12px rgba(0,0,0,0.15);
    --shadow-lg: 0 8px 24px rgba(0,0,0,0.2);
    --transition: all 0.2s ease;
    
    /* Mobile-specific variables */
    --mobile-padding: 1rem;
    --touch-target-size: 44px;
}

* {
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
}

body, html {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background-color: #ffffff;
    color: #000000;
    scroll-behavior: smooth;
    margin: 0;
    padding: 0;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* -----------------------------
   MOBILE-FIRST BASE STYLES
----------------------------- */
.main .block-container {
    padding: 0 var(--mobile-padding) 1rem !important;
    max-width: 100% !important;
    margin-top: 0 !important;
}

/* -----------------------------
   TOUCH-FRIENDLY BUTTONS
----------------------------- */
button, .stButton > button {
    background-color: var(--primary-purple) !important;
    color: white !important;
    border: none !important;
    border-radius: var(--border-radius) !important;
    padding: 0.75rem 1.5rem !important;
    font-weight: 500 !important;
    transition: var(--transition) !important;
    cursor: pointer !important;
    min-height: var(--touch-target-size) !important;
    min-width: var(--touch-target-size) !important;
    font-size: 1rem !important;
    touch-action: manipulation !important;
    -webkit-user-select: none !important;
    user-select: none !important;
}

button:hover, .stButton > button:hover {
    background-color: var(--accent-purple) !important;
    transform: translateY(-1px) !important;
    box-shadow: var(--shadow-sm) !important;
}

button:active, .stButton > button:active {
    transform: translateY(0) !important;
    box-shadow: none !important;
}

/* -----------------------------
   MOBILE NAVIGATION
----------------------------- */
.nav-container {
    margin: 1rem 0 !important;
    padding: 0 !important;
    overflow-x: auto !important;
    -webkit-overflow-scrolling: touch !important;
}

.nav-tabs {
    display: flex !important;
    gap: 0.5rem !important;
    padding-bottom: 0.5rem !important;
    min-width: max-content !important;
}


.stRadio > div {
    display: flex !important;
    gap: 0 !important;
    overflow: hidden !important;
    background: var(--primary-purple, #6C4AB6) !important;
    border-radius: var(--border-radius) !important;
}

.stRadio > div > label {
    flex: 1 1 auto !important;
    background: transparent !important;
    color: #ffffff !important;
    opacity: 0.85 !important;
    border: none !important;
    border-right: 1px solid rgba(255, 255, 255, 0.4) !important;
    border-radius: 0 !important;
    padding: 0.75rem 1.25rem !important;
    font-weight: 500 !important;
    font-size: 0.9rem !important;
    cursor: pointer !important;
    transition: var(--transition) !important;
    min-height: var(--touch-target-size) !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    white-space: nowrap !important;
    list-style: none !important;
}
.stRadio > div > label:last-child {
    border-right: none !important;
}
.stRadio > div > label[aria-checked="true"] {
    background: var(--accent-purple, #563a9d) !important;
    color: #ffffff !important;
    opacity: 1 !important;
}
.stRadio > div > label[aria-checked="true"] * {
    color: #ffffff !important;
}
.stRadio input[type="radio"] {
    display: none !important;
}

.stRadio ul {
    list-style: none !important;
    padding-left: 0 !important;
    margin: 0 !important;
}

/* -----------------------------
   MOBILE CHAT INTERFACE
----------------------------- */
.ai-chat-window {
    position: fixed !important;
    bottom: 0 !important;
    left: 0 !important;
    right: 0 !important;
    width: 100% !important;
    height: 80vh !important;
    max-height: 600px !important;
    background: white !important;
    border-radius: 12px 12px 0 0 !important;
    box-shadow: var(--shadow-lg) !important;
    display: flex !important;
    flex-direction: column !important;
    overflow: hidden !important;
    z-index: 999 !important;
    transition: transform 0.3s ease !important;
}

.chat-header {
    background: var(--primary-purple) !important;
    color: white !important;
    padding: 1rem !important;
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    position: sticky !important;
    top: 0 !important;
    z-index: 10 !important;
}

.chat-body {
    flex: 1 !important;
    padding: 1rem !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch !important;
    background: #f8f9fa !important;
}

.chat-message {
    margin-bottom: 1rem !important;
    padding: 0.75rem !important;
    border-radius: 8px !important;
    max-width: 85% !important;
    word-wrap: break-word !important;
    animation: fadeIn 0.3s ease !important;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Chat input area */
.stTextInput input {
    border: 2px solid #e0e0e0 !important;
    border-radius: var(--border-radius) !important;
    padding: 0.75rem !important;
    font-size: 1rem !important;
    transition: var(--transition) !important;
}

.stTextInput input:focus {
    border-color: var(--primary-purple) !important;
    box-shadow: 0 0 0 3px rgba(108, 74, 182, 0.1) !important;
    outline: none !important;
}

/* -----------------------------
   MOBILE CARDS & CONTAINERS
----------------------------- */
.card {
    background: white !important;
    border-radius: 12px !important;
    padding: 1rem !important;
    box-shadow: var(--shadow-sm) !important;
    margin-bottom: 1rem !important;
    border: 1px solid #f0f0f0 !important;
}

/* Touch-friendly expanders */
.streamlit-expanderHeader {
    background: #f8f9fa !important;
    border-radius: var(--border-radius) !important;
    padding: 1rem !important;
    min-height: var(--touch-target-size) !important;
    cursor: pointer !important;
    -webkit-tap-highlight-color: rgba(108, 74, 182, 0.1) !important;
}

.streamlit-expanderHeader:active {
    background: #edeafa !important;
}

/* Style for recipe version expanders */
.version-expander {
    margin-left: calc(var(--touch-target-size) / 2);
}

.version-expander .streamlit-expanderHeader {
    min-height: calc(var(--touch-target-size) / 2) !important;
}

/* -----------------------------
   MOBILE FORMS
----------------------------- */
.stForm {
    padding: 1rem !important;
    background: #f8f9fa !important;
    border-radius: var(--border-radius) !important;
    margin-bottom: 1rem !important;
}

/* Touch-friendly select boxes */
.stSelectbox > div > div {
    min-height: var(--touch-target-size) !important;
    border: 2px solid #e0e0e0 !important;
    border-radius: var(--border-radius) !important;
    padding: 0.75rem !important;
    font-size: 1rem !important;
    color: #000000 !important;
}

/* Ensure select inputs and selected values use black text */
.stSelectbox div[data-baseweb="select"] input,
.stSelectbox div[data-baseweb="select"] span,
.stSelectbox div[data-baseweb="select"] div {
    color: #000 !important;
}

.stSelectbox div[data-baseweb="select"] input::placeholder {
    color: #6c757d !important;
}


/* Touch-friendly checkboxes */
.stCheckbox label {
    padding: 0.75rem 0 !important;
    cursor: pointer !important;
    display: flex !important;
    align-items: center !important;
    min-height: var(--touch-target-size) !important;
}

.stCheckbox input[type="checkbox"] {
    width: 24px !important;
    height: 24px !important;
    margin-right: 0.75rem !important;
}


/* -----------------------------
   MOBILE EVENT INDICATOR
----------------------------- */
.event-mode-simple-indicator {
    position: relative !important;
    margin: 0.5rem 0 1rem !important;
    background: var(--primary-purple) !important;
    color: white !important;
    padding: 0.75rem 1rem !important;
    border-radius: var(--border-radius) !important;
    font-size: 0.85rem !important;
    font-weight: 500 !important;
    text-align: center !important;
    box-shadow: var(--shadow-sm) !important;
}

/* -----------------------------
   MOBILE FLOATING CHAT BUTTON
----------------------------- */
.stButton:has([data-testid*="floating_chat_toggle"]) {
    position: fixed !important;
    bottom: 1.5rem !important;
    right: 1.5rem !important;
    z-index: 1000 !important;
    width: 60px !important;
    height: 60px !important;
}

.stButton:has([data-testid*="floating_chat_toggle"]) button {
    width: 60px !important;
    height: 60px !important;
    border-radius: 50% !important;
    font-size: 24px !important;
    padding: 0 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    box-shadow: 0 4px 12px rgba(108, 74, 182, 0.3) !important;
}

/* -----------------------------
   MOBILE-SPECIFIC UTILITIES
----------------------------- */
/* Swipeable lists */
.swipeable-list {
    overflow-x: auto !important;
    -webkit-overflow-scrolling: touch !important;
    scroll-snap-type: x mandatory !important;
}

.swipeable-list > * {
    scroll-snap-align: start !important;
}

/* Touch-friendly spacing */
.stColumns {
    gap: var(--mobile-padding) !important;
}

/* Responsive tables */
.dataframe {
    overflow-x: auto !important;
    -webkit-overflow-scrolling: touch !important;
    font-size: 0.875rem !important;
}

/* -----------------------------
   TABLET STYLES (768px+)
----------------------------- */
@media (min-width: 768px) {
    .main .block-container {
        padding: 1rem 2rem !important;
    }
    
    .ai-chat-window {
        position: fixed !important;
        bottom: 100px !important;
        right: 2rem !important;
        left: auto !important;
        width: 400px !important;
        height: 500px !important;
        border-radius: 12px !important;
    }
    
    .event-mode-simple-indicator {
        position: fixed !important;
        top: 1rem !important;
        right: 1rem !important;
        margin: 0 !important;
    }
    
    .nav-tabs {
        flex-wrap: wrap !important;
        overflow-x: visible !important;
    }
}

/* -----------------------------
   DESKTOP STYLES (1024px+)
----------------------------- */
@media (min-width: 1024px) {
    .main .block-container {
        padding: 2rem 4rem !important;
        max-width: 1200px !important;
        margin: 0 auto !important;
    }
    
    button, .stButton > button {
        padding: 0.5rem 1rem !important;
        font-size: 0.9rem !important;
    }
}

/* -----------------------------
   PERFORMANCE OPTIMIZATIONS
----------------------------- */
/* Reduce motion for users who prefer it */
@media (prefers-reduced-motion: reduce) {
    * {
        animation: none !important;
        transition: none !important;
    }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
    /* Add dark mode styles here if needed */
}

/* High contrast mode */
@media (prefers-contrast: high) {
    button, .stButton > button {
        border: 2px solid currentColor !important;
    }
}

/* -----------------------------
   OFFLINE INDICATOR
----------------------------- */
.offline-indicator {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    background: #ff6b6b !important;
    color: white !important;
    padding: 0.5rem !important;
    text-align: center !important;
    font-size: 0.875rem !important;
    z-index: 9999 !important;
    transform: translateY(-100%) !important;
    transition: transform 0.3s ease !important;
}

.offline-indicator.show {
    transform: translateY(0) !important;
}

/* -----------------------------
   LOADING STATES
----------------------------- */
.stSpinner {
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    min-height: 100px !important;
}

/* Custom loading animation */
@keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 1; }
    100% { opacity: 0.6; }
}

.loading {
    animation: pulse 1.5s ease-in-out infinite !important;
}

/* -----------------------------
   Tab Styling Overrides
----------------------------- */
.stTabs [data-baseweb="tab"] button {
    background: var(--primary-purple) !important;
    color: rgba(255, 255, 255, 0.7) !important;
    border-radius: var(--border-radius) var(--border-radius) 0 0 !important;
    padding: 0.5rem 1rem !important;
    margin-right: 0.25rem !important;
}

.stTabs [data-baseweb="tab"][aria-selected="true"] button {
    background: var(--dark-purple) !important;
    color: #fff !important;
}

.stTabs [data-baseweb="tab-highlight"] {
    display: none !important;
}

/* Event list buttons */
button[id^="upcoming_"], button[id^="view_"] {
    font-size: 1.3rem !important;
    color: #fff !important;
    white-space: normal !important;
    line-height: 1.2 !important;
}

/* Divider for delete column */
.event-delete-col {
    border-left: 1px solid rgba(255, 255, 255, 0.3);
    padding-left: 0.5rem;
}


=== suggestions.py ===
# suggestions.py

import streamlit as st
from firebase_admin import firestore
from datetime import datetime
from auth import get_user_id
from utils import generate_id

db = firestore.client()
COLLECTION = "suggestions"

# ----------------------------
# üì• Create Suggestion (from AI or user)
# ----------------------------

def create_suggestion(
    document_type: str,
    document_id: str,
    field: str,
    current_value: str,
    suggested_value: str,
    user: dict,
    edited_by: str = "user",
    context_mode: str = None,
    source_references: list = None,
) -> None:
    suggestion_id = generate_id("sugg")
    suggestion_data = {
        "id": suggestion_id,
        "document_type": document_type,
        "document_id": document_id,
        "field": field,
        "current_value": current_value,
        "suggested_value": suggested_value,
        "user_id": user["id"],
        "user_name": user.get("name", "Unknown"),
        "status": "pending",
        "created_at": firestore.SERVER_TIMESTAMP,
        "event_id": user.get("active_event_id"),
        "edited_by": edited_by,
        "context_mode": context_mode,
        "source_references": source_references or [],
    }

    db.collection(COLLECTION).document(suggestion_id).set(suggestion_data)
    st.success("‚úÖ Suggestion submitted for admin review.")

# ----------------------------
# üìù Input Component (for locked fields)
# ----------------------------

def suggestion_input(field_name: str, current_value: str, document_type: str, document_id: str, user: dict, context_mode: str = None) -> str:
    st.write(f"üîí *{field_name} is locked (Event Mode)*")
    suggestion = st.text_input(f"üí° Suggest new {field_name}", value=current_value, key=f"suggest_{field_name}")
    if suggestion != current_value and st.button("Submit Suggestion", key=f"suggest_btn_{field_name}"):
        create_suggestion(
            document_type=document_type,
            document_id=document_id,
            field=field_name,
            current_value=current_value,
            suggested_value=suggestion,
            user=user,
            edited_by="user",
            context_mode=context_mode
        )
    return current_value

# ----------------------------
# ‚úÖ Approval & Rejection
# ----------------------------

def approve_suggestion(suggestion_id: str) -> None:
    db.collection(COLLECTION).document(suggestion_id).update({
        "status": "approved",
        "approved_at": firestore.SERVER_TIMESTAMP
    })

def reject_suggestion(suggestion_id: str) -> None:
    db.collection(COLLECTION).document(suggestion_id).update({
        "status": "rejected",
        "rejected_at": firestore.SERVER_TIMESTAMP
    })

# ----------------------------
# üîç Fetching Suggestions
# ----------------------------

def get_pending_suggestions() -> list[dict]:
    docs = db.collection(COLLECTION).where("status", "==", "pending").order_by("created_at", direction=firestore.Query.DESCENDING).stream()
    return [doc.to_dict() for doc in docs]

def get_suggestion_count() -> int:
    return len(get_pending_suggestions())

# ----------------------------
# üß† AI Helper for Suggestion Drafting
# ----------------------------

def ai_submit_suggestion(
    document_type: str,
    document_id: str,
    field: str,
    current_value: str,
    suggested_value: str,
    user: dict,
    context_mode: str,
    sources: list = None,
) -> None:
    """Used by AI assistant ‚Äî saves as pending suggestion."""
    create_suggestion(
        document_type=document_type,
        document_id=document_id,
        field=field,
        current_value=current_value,
        suggested_value=suggested_value,
        user=user,
        edited_by="ai_assistant",
        context_mode=context_mode,
        source_references=sources or []
    )


=== tag_explorer.py ===
import streamlit as st
import networkx as nx
from pyvis.network import Network
from firebase_admin import firestore
from utils import session_get

# ------------------------------
# üîç UI Entry Point
# ------------------------------
def tag_explorer_ui():
    st.title("üîñ Explore Tags")

    tag_query = st.text_input("Search for a tag:")
    if not tag_query:
        st.info("Enter a tag to explore usage across the app.")
        return

    try:
        tag_data = _get_tag_usage(tag_query.strip().lower())
        if not any(tag_data.values()):
            st.warning("No usage found for this tag.")
            return
        _render_constellation(tag_query, tag_data)
    except Exception as e:
        st.error(f"An error occurred while loading tag data: {e}")


# ------------------------------
# üìä Tag Usage Collector
# ------------------------------
def _get_tag_usage(tag: str) -> dict:
    db = firestore.client()
    tag_data = {
        "events": [],
        "recipes": [],
        "files": [],
        "shopping_lists": [],
        "equipment_lists": [],
        "receipts": []
    }

    collections = {
        "events": "events",
        "recipes": "recipes",
        "files": "files",
        "shopping_lists": "shopping_lists",
        "equipment_lists": "equipment_lists",
        "receipts": "receipts"
    }

    for key, collection in collections.items():
        try:
            docs = db.collection(collection).where("tags", "array_contains", tag).stream()
            tag_data[key] = [doc.to_dict() | {"id": doc.id} for doc in docs]
        except Exception:
            tag_data[key] = []  # Silently skip if collection missing or malformed

    return tag_data


# ------------------------------
# üï∏Ô∏è Tag Constellation Graph
# ------------------------------
def _render_constellation(tag: str, tag_data: dict):
    G = nx.Graph()
    main_node = tag
    G.add_node(main_node, size=25, title=f"Tag: {tag}")

    category_labels = {
        "events": "Event",
        "recipes": "Recipe",
        "files": "File",
        "shopping_lists": "Shopping List",
        "equipment_lists": "Equipment",
        "receipts": "Receipt"
    }

    for category, items in tag_data.items():
        label = category_labels.get(category, category.title())
        for entry in items:
            name = entry.get("name") or entry.get("title") or entry.get("id")
            tooltip = f"{label}: {name}"
            G.add_node(name, title=tooltip, size=15)
            G.add_edge(main_node, name)

    # Add usage summary node
    usage_summary = "<br>".join([
        f"{category_labels[k]}s: {len(v)}"
        for k, v in tag_data.items() if v
    ])
    G.nodes[main_node]['title'] += "<br><br>" + usage_summary

    net = Network(height="600px", width="100%", notebook=False)
    net.from_nx(G)
    net.repulsion(node_distance=220, spring_length=220)

    net.save_graph("tag_graph.html")
    with open("tag_graph.html", "r", encoding="utf-8") as f:
        html = f.read()
        st.components.v1.html(html, height=620, scrolling=False)


=== tag_utils.py ===
import streamlit as st
try:
    from openai import OpenAI
    client = OpenAI(api_key=st.secrets["openai"]["api_key"])
except Exception:
    client = None


def suggest_recipe_tags(name: str, ingredients: str, instructions: str, special_version: str = "") -> list[str]:
    """Use OpenAI to suggest tags for a recipe."""
    if not client:
        return []
    prompt = (
        "Suggest concise tags for the following recipe. "
        "Include cuisine, meal type, and any diet or allergy indicators if applicable. "
        f"Title: {name}\nSpecial Version: {special_version}\nIngredients: {ingredients}\nInstructions: {instructions[:500]}"
    )
    try:
        res = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.2,
        )
        text = res.choices[0].message.content
        tags = [t.strip().title() for t in text.split(',') if t.strip()]
        return tags
    except Exception as e:
        st.warning(f"Tag suggestion failed: {e}")
        return []


=== ui_components.py ===
# ui_components.py - Fixed version without big event banner

import streamlit as st
from utils import format_date
from event_mode import get_active_event

# ----------------------------
# üì¢ Event Mode Banner - REMOVED
# ----------------------------
def inject_layout_fixes():
    """Inject CSS to fix layout issues and remove white space"""
    layout_css = """
    <style>
    /* Remove all top padding and margins */
    .main .block-container {
        padding-top: 0 !important;
        padding-bottom: 1rem !important;
        max-width: 100% !important;
    }
    
    /* Remove streamlit header space */
    .stApp > header {
        display: none !important;
    }
    
    /* Tighten element spacing */
    .element-container {
        margin-bottom: 0 !important;
    }
    
    /* Remove title margins */
    h1, h2, h3 {
        margin-top: 0 !important;
        margin-bottom: 0.5rem !important;
    }
    
    /* Fix navigation spacing */
    .stRadio > div {
        gap: 0.25rem !important;
        margin: 0.5rem 0 !important;
    }
    
    /* Remove empty buttons */
    .stButton button:empty {
        display: none !important;
    }
    
    /* Hide streamlit menu and footer */
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    
    /* Remove padding from top */
    .appview-container {
        padding-top: 0 !important;
    }
    
    /* Fix floating chat position */
    .stButton:has([data-testid*="floating_chat_toggle"]) {
        position: fixed !important;
        bottom: 1.5rem !important;
        right: 1.5rem !important;
        z-index: 1000 !important;
        width: 50px !important;
        height: 50px !important;
    }
    </style>
    """
    st.markdown(layout_css, unsafe_allow_html=True)

def show_event_mode_banner() -> None:
    """This function is now empty - no more big banner"""
    # Functionality has been moved to the compact indicator in layout.py
    pass

# ----------------------------
# üß∞ Event Toolbar Stub
# ----------------------------

def render_event_toolbar(*args, **kwargs) -> None:
    """Stub for rendering event toolbar"""
    # Generate unique key based on context
    context_id = kwargs.get('context', 'default')
    toolbar_key = f"toolbar_{context_id}_{hash(str(args))}"
    
    st.markdown(f"<!-- Event toolbar placeholder: {toolbar_key} -->", unsafe_allow_html=True)

# ----------------------------
# üéØ Context-Aware Event Controls
# ----------------------------

def render_event_controls(event_id: str, context: str = "default") -> None:
    """Render event controls with context-specific unique keys"""
    if not event_id:
        return
    
    from utils import get_active_event_id
    active_event_id = get_active_event_id()
    
    # Create unique keys based on context and event ID
    base_key = f"{context}_{event_id}"
    
    if active_event_id == event_id:
        # Event is active - show deactivate button
        if st.button("Deactivate Event", key=f"deactivate_{base_key}"):
            try:
                st.session_state["recent_event_id"] = event_id
                from events import deactivate_event_mode
                deactivate_event_mode()
                st.success("Event deactivated")
                st.rerun()
            except ImportError:
                st.error("Could not deactivate event")
    
    elif active_event_id and active_event_id != event_id:
        # Another event is active - show switch button
        if st.button("Switch to Event", key=f"switch_{base_key}"):
            try:
                from events import activate_event
                if active_event_id:
                    st.session_state["recent_event_id"] = active_event_id
                activate_event(event_id)
                st.success("Switched events")
                st.rerun()
            except ImportError:
                st.error("Could not switch events")
    
    else:
        # No event active - show activate button
        if st.button("Activate Event", key=f"activate_{base_key}"):
            try:
                from events import activate_event
                activate_event(event_id)
                st.success("Event activated")
                st.rerun()
            except ImportError:
                st.error("Could not activate event")

# ----------------------------
# üîÑ Quick Event Switcher
# ----------------------------

def render_quick_event_switcher() -> None:
    """Render a quick event switcher dropdown"""
    try:
        from firebase_init import db, firestore
        
        # Get recent events
        events_docs = list(
            db.collection("events")
              .where("deleted", "==", False)
              .order_by("start_date", direction=db.query.DESCENDING)
              .limit(5)
              .stream()
        )
        
        events = [doc.to_dict() | {"id": doc.id} for doc in events_docs]
        
        if not events:
            return
        
        # Create options
        options = ["No Event Active"]
        event_mapping = {}
        
        for event in events:
            display_name = f"{event.get('name', 'Unnamed')} ({event.get('start_date', 'No date')})"
            options.append(display_name)
            event_mapping[display_name] = event["id"]
        
        # Current selection
        from utils import get_active_event_id
        active_event_id = get_active_event_id()
        current_index = 0
        
        if active_event_id:
            for i, (display_name, event_id) in enumerate(event_mapping.items()):
                if event_id == active_event_id:
                    current_index = i + 1
                    break
        
        # Render selector
        selected = st.selectbox(
            "Quick Event Switch",
            options,
            index=current_index,
            key="quick_event_switcher"
        )
        
        # Handle selection change
        if selected != options[current_index]:
            if selected == "No Event Active":
                # Deactivate current event
                if active_event_id:
                    st.session_state["recent_event_id"] = active_event_id
                    try:
                        from events import deactivate_event_mode
                        deactivate_event_mode()
                        st.rerun()
                    except ImportError:
                        st.error("Could not deactivate event")
            else:
                # Activate selected event
                new_event_id = event_mapping.get(selected)
                if new_event_id:
                    try:
                        from events import activate_event
                        if active_event_id:
                            st.session_state["recent_event_id"] = active_event_id
                        activate_event(new_event_id)
                        st.rerun()
                    except ImportError:
                        st.error("Could not activate event")
        
    except Exception as e:
        st.error(f"Could not load event switcher: {e}")

# ----------------------------
# üí° Smart Context Messages
# ----------------------------

def show_context_message(message_type: str = "info", custom_message: str = None) -> None:
    """Show context-appropriate messages based on current state"""
    from utils import get_active_event_id
    
    active_event_id = get_active_event_id()
    
    if custom_message:
        if message_type == "info":
            st.info(custom_message)
        elif message_type == "success":
            st.success(custom_message)
        elif message_type == "warning":
            st.warning(custom_message)
        elif message_type == "error":
            st.error(custom_message)
        return
    
    # Default context messages
    if not active_event_id:
        st.info("üí° **Tip:** Activate an event to access event-specific features and AI assistance.")
    else:
        recent_event_id = st.session_state.get("recent_event_id")
        if recent_event_id and recent_event_id != active_event_id:
            st.info("üîÑ **Quick Switch:** You can quickly resume your previous event from the header.")

# ----------------------------
# üìä Event Status Widget
# ----------------------------

def render_event_status_widget(event_id: str) -> None:
    """Render a compact event status widget"""
    if not event_id:
        return
    
    try:
        from utils import get_event_by_id
        event = get_event_by_id(event_id)
        
        if not event:
            return
        
        status = event.get('status', 'planning')
        guest_count = event.get('guest_count', 0)
        
        # Create status widget
        status_colors = {
            'planning': '#ffd54f',
            'active': '#81c784', 
            'complete': '#90a4ae'
        }
        
        status_color = status_colors.get(status, '#90a4ae')
        
        widget_html = f"""
        <div style="
            display: flex; 
            align-items: center; 
            gap: 1rem; 
            padding: 0.5rem 1rem; 
            background: #f8f9fa; 
            border-radius: 8px; 
            border-left: 4px solid {status_color};
            margin: 0.5rem 0;
        ">
            <div>
                <strong>{event.get('name', 'Unknown Event')}</strong><br>
                <small>üë• {guest_count} guests ‚Ä¢ üìä {status.title()}</small>
            </div>
        </div>
        """
        
        st.markdown(widget_html, unsafe_allow_html=True)
        
    except Exception as e:
        st.error(f"Could not load event status: {e}")

# ----------------------------
# üé® Theme Helpers
# ----------------------------

def apply_purple_theme_to_widget(widget_key: str) -> None:
    """Apply purple theme styling to specific widgets"""
    theme_css = f"""
    <style>
    [data-testid*="{widget_key}"] button {{
        background-color: var(--primary-purple, #6C4AB6) !important;
        color: white !important;
        border: none !important;
        border-radius: 8px !important;
    }}
    
    [data-testid*="{widget_key}"] button:hover {{
        background-color: var(--accent-purple, #563a9d) !important;
    }}
    </style>
    """
    st.markdown(theme_css, unsafe_allow_html=True)

# ----------------------------
# üîß Utility Functions
# ----------------------------

def create_unique_key(base: str, context: str = None) -> str:
    """Create a unique key for Streamlit components"""
    if context:
        return f"{context}_{base}_{hash(str([base, context]))}"
    return f"{base}_{hash(base)}"

def safe_button(label: str, key: str, **kwargs) -> bool:
    """Create a button with guaranteed unique key"""
    unique_key = create_unique_key(key, kwargs.get('context', 'default'))
    return st.button(label, key=unique_key, **{k: v for k, v in kwargs.items() if k != 'context'})

def render_tag_group(title, tags, color="blue"):
    if not tags:
        return
    st.markdown(f"#### <span style='background-color:light{color};padding:6px 10px;border-radius:8px;font-weight:600;'>{title}</span>", unsafe_allow_html=True)
    tag_html = " ".join([
        f"<span style='background-color:{color};color:white;padding:4px 10px;margin:3px;border-radius:999px;font-size:12px;display:inline-block;'>{tag}</span>"
        for tag in tags
    ])
    st.markdown(f"<div style='margin-bottom:10px'>{tag_html}</div>", unsafe_allow_html=True)

def edit_metadata_ui(parsed):
    st.markdown("### ‚úèÔ∏è Edit Metadata")

    parsed["title"] = st.text_input("Title", value=parsed.get("title", ""))
    parsed["diet"] = st.text_input("Diet", value=parsed.get("diet", ""))
    parsed["notes"] = st.text_area("Notes", value=parsed.get("notes", ""))

    allergens = st.text_input("Allergens (comma-separated)", value=", ".join(parsed.get("allergens", [])))
    parsed["allergens"] = [a.strip() for a in allergens.split(",") if a.strip()]

    tags = st.text_input("Tags (comma-separated)", value=", ".join(parsed.get("tags", [])))
    parsed["tags"] = [t.strip() for t in tags.split(",") if t.strip()]

    st.info("When you're done editing, use the Save buttons below to commit.")
    return parsed


=== upload.py ===
import streamlit as st
from auth import require_role, get_user, get_user_id
from utils import session_get, format_date, get_active_event_id, value_to_text
from file_storage import save_uploaded_file, file_manager_ui
from upload_integration import save_parsed_menu_ui, show_save_file_actions
from ui_components import render_tag_group, edit_metadata_ui
from firebase_init import get_db
from events import get_all_events
from mobile_helpers import safe_file_uploader
from recipes import save_recipe_to_firestore

# ----------------------------
# üì§ Desktop Upload UI
# ----------------------------
@require_role("user")
def upload_ui_desktop(event_id: str = None):
    st.subheader("üìÑ Upload a File")

    file = safe_file_uploader(
        "Select file to upload",
        type=["pdf", "png", "jpg", "jpeg", "txt", "csv", "docx"],
    )
    user = session_get("user")

    events = get_all_events()
    event_options = {
        f"{e.get('name', 'Unnamed')} ({format_date(e.get('start_date'))} - {e.get('status', 'planning')})": e['id']
        for e in events if not e.get("deleted", False)
    }

    eid_label = st.selectbox(
        "Select Event (optional)",
        ["None"] + list(event_options.keys()),
        key="upload_event_select",
    )
    eid = event_options.get(eid_label) if eid_label != "None" else None

    if file and user:
        uploaded_by = user["id"]
        with st.spinner("Parsing and uploading..."):
            result = save_uploaded_file(file, eid, uploaded_by)

        st.success(f"‚úÖ File uploaded! File ID: {result['file_id']}")

        recipes = result.get("parsed", {}).get("recipes")
        if recipes:
            recipe_draft = recipes if isinstance(recipes, dict) else recipes[0]

            st.markdown("### üß™ Auto-Detected Recipe Preview")
            with st.form("confirm_recipe_from_upload"):
                name = st.text_input(
                    "Recipe Name",
                    recipe_draft.get("name") or recipe_draft.get("title", ""),
                )
                
                ingredients = st.text_area(
                    "Ingredients",
                    value=value_to_text(recipe_draft.get("ingredients")),
                )
                instructions = st.text_area(
                    "Instructions",
                    value=value_to_text(recipe_draft.get("instructions")),
                )
                notes = st.text_area(
                    "Notes",
                    value=value_to_text(recipe_draft.get("notes")),
                )
      
                confirm = st.form_submit_button("Save Recipe")

                if eid:
                    st.markdown("### üçΩÔ∏è Save as Menu Item for Event")
                    st.session_state["parsed_recipe_context"] = {
                        "title": name,
                        "instructions": instructions,
                        "notes": notes,
                        "tags": [],
                        "allergens": [],
                        "event_id": eid,
                    }
                    save_parsed_menu_ui(st.session_state["parsed_recipe_context"])

                if confirm:
                    recipe_draft.update({
                        "name": name,
                        "ingredients": ingredients,
                        "instructions": instructions,
                        "notes": notes,
                        "tags": [],
                        "author_name": user.get("name", uploaded_by),
                    })
                    recipe_id = save_recipe_to_firestore(recipe_draft)
                    if recipe_id:
                        st.success(f"‚úÖ Recipe saved! ID: {recipe_id}")
                    else:
                        st.error("‚ùå Failed to save recipe.")

    st.markdown("---")
    st.markdown("## üìÅ File Manager")
    if user:
        file_manager_ui({"id": user["id"]})

# ----------------------------
# üì± Mobile Upload UI
# ----------------------------
def upload_ui_mobile():
    from mobile_layout import render_mobile_navigation
    st.title("üì§ Upload Files")
    user_id = get_user_id()
    event_id = get_active_event_id()
    db = get_db()

    st.markdown("### Upload a new file")
    uploaded_file = st.file_uploader("Drop or select a file", type=["pdf", "txt", "jpg", "png", "jpeg", "csv", "docx"])

    if uploaded_file:
        with st.spinner("Parsing and uploading..."):
            result = save_uploaded_file(uploaded_file, event_id, user_id)
            st.session_state["last_uploaded_file"] = result

        st.success("‚úÖ File uploaded and parsed.")

        if st.button("View / Edit Data"):
            from file_storage import _render_parsed_data_editor
            _render_parsed_data_editor({
                "id": result["file_id"],
                "name": uploaded_file.name,
                "parsed_data": {"parsed": result.get("parsed", {})}
            }, db)

        show_save_file_actions(st.session_state["last_uploaded_file"])

    st.markdown("---")
    st.markdown("## üìÅ File Manager")
    file_manager_ui({"id": user_id})


=== upload_integration.py ===
import streamlit as st
from firebase_init import db
from utils import get_active_event_id
from auth import get_user_id
from shopping_lists import create_shopping_list
from datetime import datetime
from recipes import save_menu_to_firestore

# ----------------------------
# ‚¨ÜÔ∏è Upload Integration: Save as Menu
# ----------------------------

def save_parsed_menu_ui(parsed_data: dict):
    st.markdown("### üçΩÔ∏è Save as Event Menu Item")

    user_id = get_user_id()
    event_id = get_active_event_id()
    if not event_id:
        st.warning("Please activate or select an event before saving to a menu.")
        return

    with st.form("save_menu_form"):
        day = st.text_input("Day")
        meal = st.selectbox(
            "Meal",
            ["Breakfast", "Lunch", "Dinner", "Note"],
            key="upload_meal_select",
        )
        recipe = st.text_input(
            "Recipe Name",
            value=parsed_data.get("name") or parsed_data.get("title", ""),
        )
        notes = st.text_area("Notes", value=parsed_data.get("notes", ""))
        allergens = st.text_input("Allergens (comma-separated)", value=", ".join(parsed_data.get("allergens", [])))
        tags = st.text_input("Tags (comma-separated)", value=", ".join(parsed_data.get("tags", [])))

        if st.form_submit_button("‚úÖ Save to Event Menu"):
            new_item = {
                "day": day,
                "meal": meal.lower(),
                "recipe": recipe,
                "notes": notes,
                "allergens": [a.strip() for a in allergens.split(",") if a.strip()],
                "tags": [t.strip() for t in tags.split(",") if t.strip()]
            }

            event_file_ref = db.collection("events").document(event_id).collection("meta").document("event_file")
            doc = event_file_ref.get()
            current = doc.to_dict().get("menu", []) if doc.exists else []
            current.append(new_item)

            success = save_menu_to_firestore(current, event_id, user_id)
            if success:
                st.success("‚úÖ Menu item added!")
            else:
                st.error("‚ùå Failed to save menu item.")

# ----------------------------
# üì• Save Parsed File As...
# ----------------------------

def show_save_file_actions(upload_info: dict):
    file_id = upload_info.get("file_id")
    parsed = upload_info.get("parsed", {})
    raw_text = upload_info.get("raw_text", "")
    uploaded_name = parsed.get("title") or parsed.get("name") or "Unnamed File"

    st.markdown("### üíæ Save File As...")
    col1, col2, col3 = st.columns(3)

    with col1:
        if st.button("üç≤ Save as Recipe", key=f"save_as_recipe_{file_id}"):
            recipe_doc = {
                "title": uploaded_name,
                "source_file": file_id,
                "created_at": datetime.utcnow().isoformat(),
                "parsed_data": parsed,
            }
            db.collection("recipes").document().set(recipe_doc)
            st.success("‚úÖ File saved as Recipe")

    with col2:
        if st.button("üìÖ Save as Event", key=f"save_as_event_{file_id}"):
            event_doc = {
                "name": uploaded_name,
                "source_file": file_id,
                "created_at": datetime.utcnow().isoformat(),
                "parsed_data": parsed,
            }
            db.collection("events").document().set(event_doc)
            st.success("‚úÖ File saved as Event")

    with col3:
        if st.button("üìñ Save as Menu", key=f"save_as_menu_{file_id}"):
            db.collection("menus").document().set({
                "title": uploaded_name,
                "source_file": file_id,
                "created_at": datetime.utcnow().isoformat(),
                "parsed_data": parsed,
            })
            st.success("‚úÖ File saved as Menu")

    col4, col5 = st.columns(2)

    with col4:
        if st.button("ü•¨ Save as Ingredient", key=f"save_as_ingredient_{file_id}"):
            db.collection("ingredients").document().set({
                "name": uploaded_name,
                "source_file": file_id,
                "created_at": datetime.utcnow().isoformat(),
                "parsed_data": parsed,
            })
            st.success("‚úÖ File saved as Ingredient")

    with col5:
        if st.button("üõí Save as Shopping List", key=f"save_as_shoplist_{file_id}"):
            create_shopping_list({
                "name": uploaded_name,
                "source_file": file_id,
                "parsed_data": parsed,
                "items": parsed.get("items", []),
            }, user_id=get_user_id())
            st.success("‚úÖ File saved as Shopping List")


=== user_admin.py ===
import streamlit as st
from datetime import datetime, timedelta
from utils import format_timestamp, delete_button
from notifications import send_notification
from auth import require_role, sync_firebase_users, delete_firebase_user
from firebase_init import db  # ‚úÖ Fixed: Use centralized database client
from google.cloud.firestore_v1.base_query import FieldFilter

# ----------------------------
# üë§ User Admin Panel (Admin Only)
# ----------------------------
@require_role("admin")
def user_admin_ui():
    """Main user administration interface with Firebase integration"""
    st.title("üë• User Admin Panel")
    st.caption("View users, update roles, and monitor activity across the app with Firebase authentication.")

    # Sync Firebase users first
    try:
        synced_count = sync_firebase_users()
        if synced_count > 0:
            st.success(f"‚úÖ Synced {synced_count} Firebase users to Firestore")
    except Exception as e:
        st.warning(f"Could not sync Firebase users: {e}")

    # Get all users
    try:
        users_docs = list(db.collection("users").stream())
        users = [doc.to_dict() | {"id": doc.id} for doc in users_docs]
    except Exception as e:
        st.error(f"‚ö†Ô∏è Could not load users: {e}")
        return

    if not users:
        st.info("No users found in the system.")
        return

    # Search and filter
    col1, col2 = st.columns(2)
    with col1:
        search = st.text_input("üîç Search by name or email:", placeholder="Enter search term...")
    with col2:
        role_filter = st.selectbox("Filter by role:", ["All", "admin", "manager", "user", "viewer"])

    # Apply filters
    filtered_users = users
    
    if search:
        search_lower = search.lower()
        filtered_users = [
            u for u in filtered_users 
            if (search_lower in u.get("name", "").lower() or 
                search_lower in u.get("email", "").lower())
        ]
    
    if role_filter != "All":
        filtered_users = [u for u in filtered_users if u.get("role", "viewer") == role_filter]

    if not filtered_users:
        st.info("No matching users found.")
        return

    # User statistics
    st.markdown("### üìä User Statistics")
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Total Users", len(users))
    with col2:
        admin_count = len([u for u in users if u.get("role") == "admin"])
        st.metric("Admins", admin_count)
    with col3:
        verified_count = len([u for u in users if u.get("email_verified", False)])
        st.metric("Verified", verified_count)
    with col4:
        active_count = len([u for u in users if u.get("active", True)])
        st.metric("Active Users", active_count)

    st.markdown("---")
    st.markdown(f"### üë• Users ({len(filtered_users)} shown)")

    # Available roles
    roles = ['viewer', 'user', 'manager', 'admin']
    current_admin = st.session_state.get("firebase_user", {}).get("id")

    # Display users
    for user in sorted(filtered_users, key=lambda x: x.get("name", "").lower()):
        with st.expander(f"üë§ {user.get('name', 'Unnamed')} ({user.get('email', 'No email')})"):
            
            # User details
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown(f"**User ID:** `{user.get('id', 'Unknown')}`")
                st.markdown(f"**Email:** {user.get('email', 'Not provided')}")
                st.markdown(f"**Name:** {user.get('name', 'Not provided')}")
                
                # Email verification status
                if user.get('email_verified', False):
                    st.markdown("**Email:** ‚úÖ Verified")
                else:
                    st.markdown("**Email:** ‚ö†Ô∏è Unverified")
                
                # Join date
                created_at = user.get('created_at')
                if created_at:
                    st.markdown(f"**Joined:** {format_timestamp(created_at)}")
                else:
                    st.markdown("**Joined:** Unknown")
            
            with col2:
                # Current role
                current_role = user.get("role", "viewer")
                st.markdown(f"**Current Role:** `{current_role}`")
                
                # Last login
                last_login = user.get('last_login')
                if last_login:
                    st.markdown(f"**Last Login:** {format_timestamp(last_login)}")
                
                # Account status
                if user.get('active', True):
                    st.markdown("**Status:** üü¢ Active")
                else:
                    st.markdown("**Status:** üî¥ Inactive")

            # Role management
            st.markdown("---")
            st.markdown("**üëë Role Management**")
            
            # Prevent admins from changing their own role or demoting the last admin
            can_change_role = True
            warning_message = None
            
            if user.get('id') == current_admin:
                can_change_role = False
                warning_message = "Cannot change your own role"
            elif current_role == "admin":
                # Check if this is the last admin
                other_admins = [u for u in users if u.get("role") == "admin" and u.get("id") != user.get("id")]
                if not other_admins:
                    can_change_role = False
                    warning_message = "Cannot demote the last admin"
            
            if warning_message:
                st.warning(warning_message)
            
            if can_change_role:
                new_role = st.selectbox(
                    "Assign Role",
                    roles,
                    index=roles.index(current_role),
                    key=f"role_{user['id']}",
                    help="Select the new role for this user"
                )
                
                if new_role != current_role:
                    col_save, col_cancel = st.columns(2)
                    
                    with col_save:
                        if st.button(f"üíæ Update to {new_role}", key=f"save_{user['id']}", type="primary"):
                            try:
                                # Update user role
                                db.collection("users").document(user["id"]).update({"role": new_role})
                                
                                # Log the change
                                db.collection("logs").add({
                                    "action": "role_change",
                                    "user_id": user["id"],
                                    "timestamp": datetime.utcnow(),
                                    "details": {
                                        "from_role": current_role,
                                        "to_role": new_role,
                                        "target_user": user.get("name", user.get("email", user["id"])),
                                        "changed_by": current_admin
                                    }
                                })
                                
                                # Send notification to admins
                                send_notification(
                                    f"Role changed for {user.get('name', user.get('email', 'Unknown'))}: {current_role} ‚Üí {new_role}",
                                    role="admin"
                                )
                                
                                st.success(f"‚úÖ Role updated to **{new_role}**")
                                st.rerun()
                                
                            except Exception as e:
                                st.error(f"‚ùå Failed to update role: {e}")
                    
                    with col_cancel:
                        if st.button("‚ùå Cancel", key=f"cancel_{user['id']}"):
                            st.rerun()
            else:
                # Show current role as read-only
                st.info(f"Current role: **{current_role}** (cannot be changed)")
            
            # Additional user actions
            st.markdown("---")
            st.markdown("**‚öôÔ∏è User Actions**")
            
            col_actions = st.columns(4)
            
            with col_actions[0]:
                if st.button("üìß Send Message", key=f"msg_{user['id']}"):
                    # This could open a modal or redirect to messaging
                    st.info("Messaging feature coming soon!")
            
            with col_actions[1]:
                if st.button("üìä View Activity", key=f"activity_{user['id']}"):
                    show_user_activity(user)
            
            with col_actions[2]:
                # Email verification action
                if not user.get('email_verified', False):
                    if st.button("üìß Resend Verification", key=f"verify_{user['id']}"):
                        try:
                            from firebase_admin import auth as firebase_auth
                            verification_link = firebase_auth.generate_email_verification_link(user.get('email'))
                            st.success("‚úÖ Verification email sent!")
                            st.info("Email verification link generated (integrate with email service)")
                        except Exception as e:
                            st.error(f"Failed to send verification: {e}")
            
            with col_actions[3]:
                # Delete user action (only for non-admins, not current user)
                if (current_role != "admin" and 
                    user.get('id') != current_admin):
                    
                    if delete_button("üóëÔ∏è Delete User", key=f"delete_{user['id']}", type="secondary"):
                        if delete_firebase_user(user['id']):
                            st.success("‚úÖ User deleted from Firebase and Firestore")
                            st.rerun()

# ----------------------------
# üìä User Activity Details
# ----------------------------
def show_user_activity(user):
    """Show detailed user activity"""
    user_id = user.get("id")
    
    st.markdown(f"### üìä Activity for {user.get('name', 'Unknown')}")
    
    try:
        # Get user's events
        events_created = list(db.collection("events").where("created_by", "==", user_id).stream())
        
        # Get user's suggestions
        suggestions_made = list(db.collection("suggestions").where("user_id", "==", user_id).stream())
        
        # Get user's files
        files_uploaded = list(db.collection("files").where("uploaded_by", "==", user_id).stream())
        
        # Get user's active sessions
        active_sessions = list(db.collection("active_sessions").where("user_id", "==", user_id).where("active", "==", True).stream())
        
        # Get user's logs (with proper ordering and fallback)
        try:
            user_logs = list(db.collection("logs").where(filter=FieldFilter("user_id", "==", user_id))
                .order_by("timestamp", direction=firestore.Query.DESCENDING)
                .limit(10).stream())
        except Exception:
            # Fallback if ordering fails (no index)
            user_logs = list(db.collection("logs").where("user_id", "==", user_id).limit(10).stream())
        
        # Display metrics
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Events Created", len(events_created))
        with col2:
            st.metric("Suggestions Made", len(suggestions_made))
        with col3:
            st.metric("Files Uploaded", len(files_uploaded))
        with col4:
            st.metric("Active Sessions", len(active_sessions))
        
        # Show Firebase-specific info
        st.markdown("#### üîê Firebase Account Info")
        try:
            from firebase_admin import auth as firebase_auth
            firebase_user = firebase_auth.get_user(user_id)
            
            col1, col2 = st.columns(2)
            with col1:
                st.write(f"**Firebase UID:** `{firebase_user.uid}`")
                st.write(f"**Email Verified:** {'‚úÖ Yes' if firebase_user.email_verified else '‚ùå No'}")
            with col2:
                st.write(f"**Account Created:** {format_timestamp(datetime.fromtimestamp(firebase_user.user_metadata.creation_timestamp / 1000))}")
                st.write(f"**Last Sign In:** {format_timestamp(datetime.fromtimestamp(firebase_user.user_metadata.last_sign_in_timestamp / 1000)) if firebase_user.user_metadata.last_sign_in_timestamp else 'Never'}")
        except Exception as e:
            st.warning(f"Could not load Firebase user data: {e}")
        
        # Show recent activity
        if user_logs:
            st.markdown("#### üïí Recent Activity")
            for log_doc in user_logs:
                log_data = log_doc.to_dict()
                timestamp = format_timestamp(log_data.get('timestamp'))
                action = log_data.get('action', 'Unknown action')
                st.write(f"‚Ä¢ **{timestamp}** - {action}")
        
        # Show created events
        if events_created:
            st.markdown("#### üé™ Events Created")
            for event_doc in events_created:
                event_data = event_doc.to_dict()
                st.write(f"‚Ä¢ **{event_data.get('name', 'Unnamed')}** - {event_data.get('status', 'unknown')} status")
        
        # Show active sessions
        if active_sessions:
            st.markdown("#### üì± Active Sessions")
            for session_doc in active_sessions:
                session_data = session_doc.to_dict()
                created_at = format_timestamp(session_data.get('created_at'))
                expires_at = format_timestamp(session_data.get('expires_at'))
                st.write(f"‚Ä¢ Session created: {created_at}, expires: {expires_at}")
                
                # Option to revoke session
                if st.button(f"üö™ Revoke Session", key=f"revoke_{session_doc.id}"):
                    try:
                        from firebase_auth_ui import auth_manager
                        auth_manager._revoke_session(session_doc.id)
                        st.success("Session revoked")
                        st.rerun()
                    except Exception as e:
                        st.error(f"Failed to revoke session: {e}")
        
    except Exception as e:
        st.error(f"Could not load user activity: {e}")

# ----------------------------
# üîç Advanced User Search
# ----------------------------
def advanced_user_search():
    """Advanced search and filtering for users"""
    st.markdown("### üîç Advanced Search")
    
    with st.form("advanced_search"):
        col1, col2, col3 = st.columns(3)
        
        with col1:
            name_search = st.text_input("Name contains:")
            email_search = st.text_input("Email contains:")
        
        with col2:
            role_search = st.multiselect("Roles:", ["admin", "manager", "user", "viewer"])
            verified_only = st.checkbox("Email verified only")
        
        with col3:
            joined_after = st.date_input("Joined after:", value=None)
            joined_before = st.date_input("Joined before:", value=None)
        
        submitted = st.form_submit_button("üîç Search")
        
        if submitted:
            # Implement advanced search logic here
            filters = {}
            if name_search:
                filters['name_contains'] = name_search
            if email_search:
                filters['email_contains'] = email_search
            if role_search:
                filters['roles'] = role_search
            if verified_only:
                filters['verified_only'] = verified_only
            if joined_after:
                filters['joined_after'] = joined_after
            if joined_before:
                filters['joined_before'] = joined_before
            
            st.info(f"Advanced search with filters: {filters}")
            # TODO: Implement actual filtering logic
            st.write("Advanced search results would appear here based on:")
            for key, value in filters.items():
                st.write(f"- {key}: {value}")

# ----------------------------
# üìà User Analytics
# ----------------------------
def show_user_analytics():
    """Show user analytics and trends"""
    st.markdown("### üìà User Analytics")
    
    try:
        users = [doc.to_dict() for doc in db.collection("users").stream()]
        
        if not users:
            st.info("No user data available")
            return
        
        # Role distribution
        role_counts = {}
        verified_count = 0
        active_count = 0
        
        for user in users:
            role = user.get("role", "viewer")
            role_counts[role] = role_counts.get(role, 0) + 1
            
            if user.get("email_verified", False):
                verified_count += 1
            if user.get("active", True):
                active_count += 1
        
        st.markdown("#### üë• User Overview")
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("Total Users", len(users))
        with col2:
            st.metric("Verified Users", verified_count, f"{(verified_count/len(users)*100):.1f}%")
        with col3:
            st.metric("Active Users", active_count, f"{(active_count/len(users)*100):.1f}%")
        with col4:
            admin_count = role_counts.get("admin", 0)
            st.metric("Admins", admin_count)
        
        # Role distribution chart
        st.markdown("#### üë• Role Distribution")
        col1, col2 = st.columns(2)
        
        with col1:
            for role, count in role_counts.items():
                percentage = (count / len(users)) * 100
                st.write(f"**{role.title()}:** {count} users ({percentage:.1f}%)")
        
        with col2:
            # Role distribution chart would go here
            st.write("üìä Role Distribution Chart")
            for role, count in role_counts.items():
                # Simple text-based bar chart
                bar_length = int((count / len(users)) * 20)
                bar = "‚ñà" * bar_length + "‚ñë" * (20 - bar_length)
                st.write(f"`{role:8} {bar} {count:3d}`")
        
        # User registration trends (if creation dates are available)
        users_with_dates = [u for u in users if u.get('created_at')]
        
        if users_with_dates:
            st.markdown("#### üìÖ Registration Trends")
            # Group by month
            monthly_registrations = {}
            for user in users_with_dates:
                created_at = user.get('created_at')
                if hasattr(created_at, 'strftime'):
                    month_key = created_at.strftime("%Y-%m")
                    monthly_registrations[month_key] = monthly_registrations.get(month_key, 0) + 1
            
            if monthly_registrations:
                st.write("**Monthly Registration Counts:**")
                for month, count in sorted(monthly_registrations.items()):
                    st.write(f"**{month}:** {count} new users")
            else:
                st.info("No registration date data available")
        
    except Exception as e:
        st.error(f"Could not generate user analytics: {e}")

# ----------------------------
# üßπ User Management Tools
# ----------------------------
def user_management_tools():
    """Additional user management tools"""
    st.markdown("### üßπ User Management Tools")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("#### üìß Bulk Operations")
        
        if st.button("üì¢ Send Announcement to All Users"):
            announcement = st.text_area("Announcement message:", key="bulk_announcement")
            if announcement and st.button("Send to All", key="send_bulk"):
                try:
                    users = [doc.to_dict() for doc in db.collection("users").stream()]
                    for user in users:
                        send_notification(announcement, user_id=user.get('id'))
                    st.success(f"Announcement sent to {len(users)} users")
                except Exception as e:
                    st.error(f"Failed to send announcements: {e}")
        
        if st.button("üîÑ Sync Firebase Users"):
            try:
                synced_count = sync_firebase_users()
                st.success(f"‚úÖ Synced {synced_count} Firebase users")
            except Exception as e:
                st.error(f"Sync failed: {e}")
    
    with col2:
        st.markdown("#### üìä Export Options")
        
        if st.button("üì• Export User List"):
            try:
                users = [doc.to_dict() for doc in db.collection("users").stream()]
                user_data = []
                for user in users:
                    user_data.append({
                        'ID': user.get('id', ''),
                        'Name': user.get('name', ''),
                        'Email': user.get('email', ''),
                        'Role': user.get('role', 'viewer'),
                        'Verified': user.get('email_verified', False),
                        'Active': user.get('active', True),
                        'Created': format_timestamp(user.get('created_at', ''))
                    })
                
                # Convert to CSV format (simplified)
                csv_content = "ID,Name,Email,Role,Verified,Active,Created\n"
                for user in user_data:
                    csv_content += f"{user['ID']},{user['Name']},{user['Email']},{user['Role']},{user['Verified']},{user['Active']},{user['Created']}\n"
                
                st.download_button(
                    label="üì• Download CSV",
                    data=csv_content,
                    file_name=f"users_export_{datetime.now().strftime('%Y%m%d')}.csv",
                    mime="text/csv"
                )
                
            except Exception as e:
                st.error(f"Failed to export user list: {e}")

# Enhanced user admin UI with analytics
def enhanced_user_admin_ui():
    """Enhanced user admin interface with additional features"""
    
    # Tabs for different sections
    tab1, tab2, tab3, tab4 = st.tabs(["üë• User Management", "üìà Analytics", "üîç Advanced Search", "üßπ Tools"])
    
    with tab1:
        user_admin_ui()
    
    with tab2:
        show_user_analytics()
    
    with tab3:
        advanced_user_search()
    
    with tab4:
        user_management_tools()


=== user_session_initializer.py ===
# ‚úÖ PATCHED user_session_initializer.py
import streamlit as st
from firebase_admin import auth as firebase_auth
from firebase_init import db


def enrich_session_from_token(token: str) -> dict:
    try:
        decoded_token = firebase_auth.verify_id_token(token)
        user_id = decoded_token.get("uid")
        user_doc = db.collection("users").document(user_id).get()

        if user_doc.exists:
            user_data = user_doc.to_dict()
        else:
            user_data = {
                "id": user_id,
                "email": decoded_token.get("email", ""),
                "name": decoded_token.get("name", ""),
                "role": "viewer",
                "email_verified": decoded_token.get("email_verified", False),
                "active": True,
                "created_at": decoded_token.get("auth_time"),
            }
            db.collection("users").document(user_id).set(user_data)

        st.session_state["user"] = user_data  # ‚úÖ Persist user in session
        exp = decoded_token.get("exp")
        if exp:
            st.session_state["token_expiry"] = exp
        return user_data

    except Exception as e:
        st.error(f"Authentication failed: {e}")
        return None


=== utils.py ===
import streamlit as st
import uuid
from datetime import datetime
from fractions import Fraction

# ‚úÖ Fixed: Avoid circular import by lazy loading db when needed
def get_db():
    """Get database client lazily to avoid circular imports"""
    try:
        from firebase_init import db, firestore
        return db
    except ImportError:
        st.error("‚ùå Database client not available")
        return None

# ----------------------------
# üíæ Session Helpers
# ----------------------------

# Add these helper functions to your utils.py or create a new event_scoping.py file

def get_scoped_query(collection_name: str, base_query=None):
    """
    Returns a Firestore query that's scoped to the active event if event mode is on.
    If no event mode is active, returns all data.
    """
    from firebase_init import db, firestore
    
    # Start with base query or create new one
    if base_query is None:
        query = db.collection(collection_name)
    else:
        query = base_query
    
    # Check if event mode is active
    active_event_id = get_active_event_id()
    
    if active_event_id:
        # Event mode is ON - scope to active event
        query = query.where("event_id", "==", active_event_id)
    
    # If event mode is OFF, return unscoped query (all data)
    return query

def is_event_scoped():
    """Check if event mode is currently active"""
    return get_active_event_id() is not None

def get_event_scope_message():
    """Get a message about current event scope for UI display"""
    active_event_id = get_active_event_id()
    
    if active_event_id:
        event = get_event_by_id(active_event_id)
        if event:
            return f"üîç Viewing data for: **{event.get('name', 'Unknown Event')}**"
        return "üîç Event mode active (unknown event)"
    
    return "üëÅÔ∏è Viewing all data (no event filter)"

# Example usage in your components:

# In menu_editor_ui function:
def menu_editor_ui_scoped(user: dict) -> None:
    """Example of how to update menu_editor_ui with proper scoping"""
    st.title("üçΩÔ∏è Menu Editor")
    
    # Show current scope
    st.info(get_event_scope_message())
    
   # role = get_user_role(user)
    
    # Use scoped query
    query = get_scoped_query("menus")
    
    try:
        menus = [doc.to_dict() for doc in query.stream()]
    except Exception as e:
        st.error(f"‚ö†Ô∏è Failed to load menus: {e}")
        return
    
    if not menus:
        if is_event_scoped():
            st.info("No menu items found for this event.")
            if st.button("Create Menu Item"):
                # Add menu item creation for this event
                pass
        else:
            st.info("No menu items found. Create your first menu item!")
        return
    
    # Rest of the function continues as normal...

# In file_manager_ui function:
def file_manager_ui_scoped(user):
    """Example of how to update file_manager_ui with proper scoping"""
    st.subheader("üìÅ File Manager")
    
    # Show current scope
    st.info(get_event_scope_message())
    
    if not user:
        st.warning("Please log in to manage files.")
        return
    
    role = get_user_role(user)
    user_id = get_user_id(user)
    
    # File upload section (always available)
    st.markdown("### Upload New File")
    # ... upload code ...
    
    # Show existing files with proper scoping
    st.markdown("### Uploaded Files")
    
    # Get files based on current scope
    if is_event_scoped():
        # Show only files for active event
        files = list_files_for_event(get_active_event_id(), include_deleted=show_deleted)
    else:
        # Show all files
        files = list_files(include_deleted=show_deleted)
    
    # ... rest of file display code ...

def session_get(key, default=None):
    return st.session_state.get(key, default)

def session_set(key, value):
    st.session_state[key] = value

# ----------------------------
# ‚ùì Delete Confirmation Button
# ----------------------------

def delete_button(label: str, key: str, **kwargs) -> bool:
    """Button that asks for confirmation before returning True."""
    confirm_key = f"{key}_confirm"
    if st.session_state.get(confirm_key):
        col_msg, col_yes, col_no = st.columns([2, 1, 1])
        with col_msg:
            st.markdown(
                "<div style='background:white;color:black;padding:0.5rem;border-radius:4px;'>Are you sure?</div>",
                unsafe_allow_html=True,
            )
        yes_clicked = col_yes.button("Yes", key=f"{confirm_key}_yes")
        no_clicked = col_no.button("No", key=f"{confirm_key}_no")
        if yes_clicked:
            st.session_state.pop(confirm_key, None)
            return True
        if no_clicked:
            st.session_state.pop(confirm_key, None)
        return False

    if st.button(label, key=key, **kwargs):
        st.session_state[confirm_key] = True
    return False

# ----------------------------
# üßÇ Normalize Ingredient Name
# ----------------------------

def normalize_ingredient(name: str) -> str:
    """Normalize ingredient names for consistency (lowercase, trimmed)"""
    return name.strip().lower()

# ----------------------------
# üîë Unique ID Generator
# ----------------------------

def generate_id(prefix=None):
    uid = str(uuid.uuid4())[:8]
    return f"{prefix}_{uid}" if prefix else uid

# ----------------------------
# üìÜ Timestamp Formatter
# ----------------------------

def format_date(ts):
    if not ts:
        return "Unknown"
    if isinstance(ts, datetime):
        return ts.strftime("%m/%d/%y")
    try:
        return ts.to_datetime().strftime("%m/%d/%y")
    except (AttributeError, Exception):
        return str(ts)


def format_day_label(date_str: str) -> str:
    """Return a short label like 'Mon 01 Jan' for a YYYY-MM-DD date string."""
    if not date_str:
        return "Unknown"
    try:
        d = datetime.fromisoformat(date_str).date()
        return d.strftime("%a %d %b")
    except Exception:
        return date_str

def format_timestamp(ts):
    """Alias for format_date for backward compatibility"""
    return format_date(ts)

# ----------------------------
# üß¨ Safe Dict Merge
# ----------------------------

def safe_dict_merge(base, update):
    """Merge update into base, skipping None values."""
    for key, val in update.items():
        if val is not None:
            base[key] = val
    return base

# ----------------------------
# üìë Normalize Dict Keys
# ----------------------------

def normalize_keys(obj):
    """Recursively lowercase dictionary keys for consistent access."""
    if isinstance(obj, dict):
        return {str(k).lower(): normalize_keys(v) for k, v in obj.items()}
    if isinstance(obj, list):
        return [normalize_keys(v) for v in obj]
    return obj

# ----------------------------
# ü•Ñ Quantity Formatting
# ----------------------------

def format_fraction(value, max_denominator: int = 8) -> str:
    """Convert numeric values like 0.5 into nice cooking fractions."""
    if value is None:
        return ""

    # Preserve existing fraction strings
    if isinstance(value, str):
        stripped = value.strip()
        if "/" in stripped:
            return stripped
        try:
            value = float(stripped)
        except ValueError:
            return stripped

    try:
        frac = Fraction(value).limit_denominator(max_denominator)
    except Exception:
        return str(value)

    numerator, denominator = frac.numerator, frac.denominator
    whole = numerator // denominator
    remainder = numerator % denominator

    if remainder == 0:
        return str(whole)
    if whole == 0:
        return f"{remainder}/{denominator}"
    return f"{whole} {remainder}/{denominator}"

def normalize_recipe_quantities(data):
    """Recursively apply fraction formatting to recipe ingredient quantities."""
    if isinstance(data, dict):
        ingredients = data.get("ingredients")
        if isinstance(ingredients, list):
            for ing in ingredients:
                if isinstance(ing, dict):
                    qty_key = "quantity" if "quantity" in ing else "qty" if "qty" in ing else None
                    if qty_key and ing.get(qty_key) is not None:
                        ing[qty_key] = format_fraction(ing[qty_key])
    elif isinstance(data, list):
        for item in data:
            normalize_recipe_quantities(item)
    return data

# ----------------------------
# üìù Convert Parsed Values
# ----------------------------

def value_to_text(value):
    """Convert parsed lists or dicts into a newline-separated string."""
    if isinstance(value, list):
        lines = []
        for item in value:
            if isinstance(item, dict):
                parts = []
                qty = item.get("quantity") or item.get("qty")
                if qty:
                    parts.append(format_fraction(qty))
                unit = item.get("unit")
                if unit:
                    parts.append(str(unit))
                name = item.get("item") or item.get("name")
                if name:
                    parts.append(str(name))
                else:
                    parts.append(" ".join(str(v) for v in item.values()))
                lines.append(" ".join(parts).strip())
            else:
                lines.append(str(item))
        return "\n".join(lines)
    if isinstance(value, dict):
        return "\n".join(f"{k}: {v}" for k, v in value.items())
    return str(value or "")

# ----------------------------
# üîç Deep Get Utility
# ----------------------------

def deep_get(dictionary, keys, default=None):
    """Safely get nested dict values like deep_get(data, ['a', 'b'])"""
    for key in keys:
        try:
            dictionary = dictionary[key]
        except (KeyError, TypeError):
            return default
    return dictionary

# ----------------------------
# üß† Active Event Utilities
# ----------------------------

def get_active_event_id():
    """Get the currently active event ID from global config"""
    db = get_db()
    if not db:
        return None
        
    try:
        doc = db.collection("config").document("global").get()
        if doc.exists:
            return doc.to_dict().get("active_event")
        return None
    except Exception as e:
        st.error(f"‚ö†Ô∏è Could not fetch active event: {e}")
        return None

def get_active_event():
    """Get the full active event document"""
    event_id = get_active_event_id()
    if not event_id:
        return None
        
    db = get_db()
    if not db:
        return None
        
    try:
        doc = db.collection("events").document(event_id).get()
        return doc.to_dict() if doc.exists else None
    except Exception as e:
        st.error(f"‚ö†Ô∏è Could not fetch active event data: {e}")
        return None

def get_event_by_id(event_id):
    """Get a specific event by ID"""
    if not event_id:
        return None
        
    db = get_db()
    if not db:
        return None
        
    try:
        doc = db.collection("events").document(event_id).get()
        return doc.to_dict() if doc.exists else None
    except Exception as e:
        st.error(f"‚ö†Ô∏è Could not fetch event {event_id}: {e}")
        return None

# ----------------------------
# ‚úçÔ∏è Suggestion Box for Locked Fields
# ----------------------------

def suggest_edit_box(
    field_name: str,
    current_value: str,
    user: dict,
    target_id: str,
    doc_type: str = "event_field"
) -> str:
    """
    Renders a locked field with a suggestion input box.
    Submits suggestion if changed and confirmed.
    """
    st.markdown(f"üîí **{field_name}** (locked)")
    suggested_value = st.text_input(
        f"üí° Suggest a new value for {field_name}:", 
        value=current_value, 
        key=f"suggest_{field_name}_{target_id}"  # ‚úÖ Added unique key
    )

    if suggested_value != current_value and suggested_value:
        if st.button(f"üí¨ Submit Suggestion for {field_name}", key=f"submit_{field_name}_{target_id}"):
            # Import here to avoid circular dependency
            try:
                from suggestions import create_suggestion
                create_suggestion(
                    document_type=doc_type,
                    document_id=target_id,
                    field=field_name,
                    current_value=current_value,
                    suggested_value=suggested_value,
                    user=user,
                    edited_by="user",
                )
                st.success("‚úÖ Suggestion submitted for review.")
            except ImportError:
                st.error("‚ùå Suggestion system not available")
            except Exception as e:
                st.error(f"‚ùå Failed to submit suggestion: {e}")
    
    return current_value  # return original value, not suggested

# ----------------------------
# üìú Role-Based Action Logger
# ----------------------------

def log_user_action(user_id: str, role: str, action_type: str, context: dict = None):
    """Log an action performed by a user for audit trail."""
    try:
        db = get_db()
        if not db:
            return

        from datetime import datetime
        log_entry = {
            "user_id": user_id,
            "role": role,
            "action_type": action_type,
            "timestamp": datetime.utcnow(),
            "context": context or {}
        }
        db.collection("logs").document().set(log_entry)
    except Exception as e:
        st.warning(f"Failed to log user action: {e}")



